

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.556
 :16.1648
 fun:15.1698
  :14.2217
    :12.8526
                :11.997
 function:11.983	rejected
 \:11.6472	rejected
     :11.5326
   :11.5063
 (:11.162
      :11.0561
 #:11.0323	rejected
 {:11.014	rejected
	:10.8333	rejected
        :10.7351
 ?:10.6177	rejected
 (*:10.4737	prefix accepted: (
       :10.3602
fun:10.2928
            :10.0001

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:20.5905
 fun:15.6727
 (*:13.2384	prefix accepted: (
 function:13.1648	rejected
 {:12.5598	rejected
 ?:12.4237	rejected
	:12.4184	rejected
 #:12.3363	rejected
 (:13.2384
0:11.5683
 \:11.2685	rejected
 ~:11.2365	rejected
 *:10.9291	rejected
1:10.8083
 [:10.6353
 id:10.587	rejected
 func:10.5568	rejected
 ():10.4195
2:10.4111
 in:10.364
 <:10.3615	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :19.0312
fun:16.4717
  :16.0431
   :15.2033
 fun:14.7565

:14.7245
	:14.3035	rejected
     :13.2665
    :13.2225
#:12.7248	rejected
let:12.4757
(:12.0668
(*:11.9669	prefix accepted:(
       :11.9011
 let:11.6112
{:11.2863	rejected
func:11.1439	rejected
      :11.1418
function:10.9985	rejected
 (*:10.5221	prefix accepted: (
 func:10.4175	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
 

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:18.7147
 #:13.7325	rejected
 let:13.5462
 (*:13.0006	prefix accepted: (
 function:12.6037	rejected
 (:13.0006
 match:11.0928	rejected
 ?:11.0559	rejected
 {:11.0045	rejected
 ~:10.926	rejected
 |:10.7957	rejected
 lambda:10.5707	rejected
 func:10.5641	rejected
 ##:10.3076	rejected
 f:10.2119
 *:10.2084	rejected
 //:10.1161	rejected
 switch:9.89714	rejected
 [:9.84855
 @:9.7478	rejected
 update:9.69935	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 play:16.4957
 (:14.8803
 model:14.2251
 pl:13.873
 p:13.3013
 old:13.2772
 current:13.0206
 state:12.9223
 m:12.7938
 ((:12.7803	prefix accepted: (
 song:12.1036
 [:12.0014
 prev:11.9257
 s:11.9118
 ({:11.8818	prefix accepted: (
(:11.848
 {:11.7647	rejected
 app:11.5711
 ([:11.1116	prefix accepted: (
 a:11.0812
 player:11.058

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {play: (PlayList, PlayListAction), update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: play
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
list:19.0828
_:16.0702
List:15.973
lists:13.3446
,:13.2506
lst:12.9826
l:12.789
ist:12.5832
ls:12.2308
state:11.729
lis:11.6101
State:11.0805
L:10.8358
lit:10.7493
ListItem:10.194
S:10.1738
ListView:10.0625
back:9.57627
 list:9.42325	rejected
lt:9.39526
ilst:9.31879

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: (PlayList, PlayListAction), update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:17.6725
_:13.5722
 action:13.1279	rejected
 ->:12.2585
 ,:12.1177
0:11.7204
1:10.8776
 act:10.8372	rejected
_,:10.3746	prefix accepted:_
 play:10.1235	rejected
 state:10.0685	rejected
 a:9.82097	rejected
 actions:9.69562	rejected
->:9.6548
 model:9.47061	rejected
::9.34027	rejected
 pl:9.24619	rejected
 p:9.13491	rejected
 current:9.1099	rejected
 x:9.09237	rejected
@:8.9609	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: (([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected)), (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: (([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected)), (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int)))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 action:16.6653
 act:14.2203
 a:13.5742
 play:12.742
 msg:12.2725
 event:11.5242
 command:11.235
 cmd:11.1268
 song:10.9968
 x:10.9588
 actions:10.9566
 p:10.9468
 message:10.8891
action:10.8888
 new:10.7168
 current:10.6487
 input:10.5861
 pl:10.5249
 player:10.4583
 e:10.2439
 next:10.2192

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.6457
->:14.6992
 :13.5711
 =>:13.4582	rejected
_:11.6844
::11.316	rejected

:11.1112
 =:10.7871	rejected
 ::10.4964	rejected
 â†’:10.2569	rejected
,:9.97484
?:9.96263	rejected
 +:9.91615	rejected
 -:9.90882
  :9.88769
':9.63155	rejected
 {:9.57056	rejected
0:9.45827
1:9.36418
 -->:9.34583	prefix accepted: -
 ?:9.34295	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.7748
 :17.0847
  :15.6299
 match:15.3238	rejected
    :13.9888
 case:13.009
   :12.6611
 ?:12.5948	rejected
                :12.5435
 {:12.5055	rejected
 (*:12.4494	prefix accepted: (
     :12.3542
 play:12.1745
      :12.1234
        :11.861
 begin:11.6616	rejected
	:11.6308	rejected
       :11.4474
 #:11.2876	rejected
 (:12.4494
         :11.1229

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :18.6496
    :16.104
  :16.0215
     :15.8446
 :15.4294

:14.7118
       :13.8919
      :13.2916
	:12.9307	rejected
case:12.5265
        :12.4116
match:12.2939	rejected
         :12.0423
#:11.3872	rejected
 match:11.1449	rejected
switch:11.118	rejected
          :11.0045
           :10.9717
 case:10.7933
let:10.7578
                :10.4801

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
   

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:17.5789
 match:16.9103	rejected
 let:16.8274
 switch:13.8685	rejected
 #:13.0529	rejected
 (*:12.6544	prefix accepted: (
 print:12.4275	rejected
 play:11.649
 if:11.6156
 (:12.6544
 {:10.7878	rejected
 open:10.7221	rejected
 ?:10.6679	rejected
 Play:10.6019
 printf:10.4264	rejected
 Print:10.2064	rejected
 un:10.063	rejected
 fun:10.0156
 begin:10.0095	rejected
 action:9.91041
 type:9.90495

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:16.3356
 play:15.4248
 get:13.5257
 (:11.2015
 :10.7728
 song:9.86996	rejected

:9.856
 player:9.67826	rejected
 actions:9.41965	rejected
 act:9.24137
 state:9.12573	rejected
(:9.11064
 let:9.01434
play:8.9774
 *:8.84163	rejected
 {:8.82897	rejected
 [:8.75583
 current:8.68048	rejected
 List:8.56539	rejected
 is:8.32014
 a:8.15984

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.8256
 :16.7151
,:16.2386
  :15.0383
 of:14.5206	rejected
 with:13.4387	rejected
    :13.366
 {:12.5913	rejected
::12.3783
 |:12.3147
     :12.2877
 ::12.1504
      :12.1273
   :11.8593
 in:11.5327	rejected
                :11.4756
;:11.3473	rejected
 ,:11.342
 //:11.2477	prefix accepted: /
 +:11.1698
 #:10.946	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.2691
    :16.0762
     :15.98

:15.0828
  :14.1473
      :13.5586
       :13.1569
 :13.0758
        :12.9897
#:12.0724	rejected
	:11.9311	rejected
|:11.802
         :11.3951
 |:10.8019
          :10.7716
(*:10.7702	prefix accepted:(
                :10.3695
            :10.2989
           :9.59199
             :9.45301
 #:9.20781	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
   

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.2878
 #:16.7121	rejected
 (*:13.9581	prefix accepted: (
 match:12.7694	rejected
 {:12.0963	rejected
 ||:11.8797	prefix accepted: |
 ,:11.8534
 #{:11.8511	rejected
 +:11.7397
 ##:11.6334	rejected
 /*:11.314	prefix accepted: /
 ~:11.2823	rejected
 <:11.1426
 //:11.0911	prefix accepted: /
 *:10.9082
 let:10.7539	rejected
 when:10.5933	rejected
 if:10.4562	rejected
 ###:10.2972	rejected
 --:10.2742	prefix accepted: -
 !:10.23

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Add:16.6765
 Play:16.5183
 P:15.37
 Remove:14.1521
 No:13.3637
 _:12.5639
 #:11.057	rejected
 :10.6916
Play:10.691
 (:10.4967
 Player:10.3161	rejected
 {:9.82938	rejected
 _,:9.61295	prefix accepted: _
Add:9.60077
 Get:9.48369	rejected
 +:9.47207	rejected
P:9.43571
 Song:9.39216	rejected
 Stop:9.38665	rejected
>:9.38498	rejected
 ?:9.13882	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | Add

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | Add
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Add>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Add"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Add
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Add
LSP: Generating Completions for prefix: Add
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:20.4747
(:13.4095	rejected
song:12.0009	rejected
_:10.9563	rejected
 song:10.6779	rejected
To:10.6341	rejected
New:10.0262	rejected
 Song:10.0092	rejected
s:9.99936	rejected
(_:9.68262	rejected
Id:9.02499	rejected
 ->:8.86433	rejected
 a:8.77418	rejected
 =>:8.67003	rejected
 (:8.65092	rejected
    :8.60164	rejected
():8.43984	rejected
Play:8.42686	rejected
     :8.37183	rejected
Sound:8.36066	rejected

:8.35491	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "AddS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  AddS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: AddS
LSP: Generating Completions for prefix: AddS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:24.3754
ongs:17.0051	rejected
on:12.5709
song:11.7556	rejected
ongo:10.8782	rejected
(:10.7536	rejected
ang:10.7216	rejected
oon:10.5853	rejected
n:10.529	rejected
 song:10.188	rejected
ng:10.1522	rejected
ame:10.0039	rejected
ond:9.9441	rejected
ug:9.93943	rejected
ons:9.41482	rejected
oup:9.32044	rejected
one:9.29511	rejected
old:8.87693	rejected
om:8.81712	rejected
un:8.76697	rejected
g:8.70333	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Int -> (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  AddSong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: AddSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: AddSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.169
 id:14.6759	rejected
 song:14.3246	rejected
(_:12.4146	rejected
 x:12.0391	rejected
 s:11.8818	rejected
 i:11.6605	rejected
 sid:11.5487	rejected
 new:11.3632	rejected
 (:10.9534
 a:10.1419	rejected
 k:9.94915	rejected
 _:9.91738	rejected
  :9.48102
 track:9.4051	rejected
 =>:9.25683
 :9.17877
((:9.036	prefix accepted:(
 idx:8.98062	rejected
    :8.97445
([:8.90315	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
id:18.2723
song:18.166
x:15.2573
new:15.0589
s:14.9032
i:14.5769
Id:13.0016	rejected
idx:12.7348
track:12.691
n:12.6363
next:12.4302
current:12.1453
a:11.9535
k:11.5815
index:11.4371
selected:10.9636
name:10.9324
to:10.8213
vid:10.7847
play:10.7702
v:10.7323

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
_:18.3414
):17.2599
Id:16.9785
id:15.7466
ID:14.3432
),:13.4069
)->:13.1091	prefix accepted:)
s:12.6222
To:11.4895
)=:11.1668	prefix accepted:)
1:10.6721
 as:10.4674	rejected
)::10.3415	prefix accepted:)
_):10.2931	prefix accepted:_
,:10.0181
 ):9.73483
Name:9.72385
)|:9.6899	prefix accepted:)
Index:9.62786
 id:9.54574	rejected
){:9.39477	prefix accepted:)

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.4132
 ->:15.287	rejected
 when:13.6513	rejected
 if:13.1801	rejected
  :13.0628
 :12.9296
    :12.3398
     :12.338
      :12.0971
       :11.9485

:11.7723
        :11.5833
         :11.44
 as:11.4279	rejected
   :11.4206
          :11.3198
                :10.9499
           :10.8489
            :10.4618
 =:10.3968
 :::10.3364	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:16.9294
 :15.9594
  :14.1365
 add:14.0352	rejected
 let:13.5996
 ?:13.4943	rejected
 (:13.4395
 (*:12.9672	prefix accepted: (
 List:12.8075	rejected
 [:12.6223
    :12.5578
 if:12.4728
 {:12.2859	rejected
 update:12.1922
 play:12.176
                :12.0281
 #:11.7554	rejected
 f:11.6047
     :11.5451
      :11.5243
 ([:11.4409	prefix accepted: (

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :22.2089
       :20.2588
      :19.3952
        :16.8797
    :16.8402
	:16.1255	rejected
         :16.0219
   :15.5747

:14.6267
          :14.4362
           :14.1872
#:13.4178	rejected
  :13.2545
            :13.0968
                :12.9378
 :12.461
             :12.4445
               :12.2437
              :12.1111
(*:10.3766	prefix accepted:(
if:10.2277

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:19.1751
 if:16.8935
 #:16.0307	rejected
 (*:14.7687	prefix accepted: (
 (:14.7687
 case:14.4988
 begin:14.208	rejected
 add:14.023	rejected
 List:13.5517	rejected
 play:13.3813
 match:13.2455	rejected
 {:13.0297	rejected
 get:13.0021
 update:12.8976
 ((:12.6187	prefix accepted: (
 [:12.2393
 Play:12.1869
 song:11.7938
 ([:11.7296	prefix accepted: (
 f:11.6904
 fun:11.4742

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:17.4987
 current:13.2323
 song:12.9784
 ids:12.325
 new:12.2716
 play:11.9678
 add:11.6176
 old:11.5817
 xs:11.5532
 _,:11.4861	prefix accepted: _
 all:11.1212
 cur:10.9879
 _:11.4861
 existing:10.8916
 (:10.8471
 id:10.6112
 list:10.4358
 curr:10.3568
 s:10.3153
 get:10.2312
 state:9.83589

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:19.4588
 =:17.7528
_:15.5485
',:14.2275	rejected
 ,:13.7395
 ::13.4014
1:13.3963
  :13.3087
_,:12.8509	prefix accepted:_
::12.8014
':12.723	rejected
=:12.6194
 :12.5616
0:12.4565
    :12.1798
      :11.8326
2:11.7635
 :=:11.5944	prefix accepted: :
   :11.4932
       :11.3903
        :11.1539

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:17.0046
 state:16.2003
 _:15.5358
 playing:12.4701
 song:12.3751
 play:12.2215
 old:12.0753
 curr:11.9949
 status:11.851
 s:11.7642
 selected:11.2076
state:10.9968
 p:10.766
 cur:10.7057
 st:10.6538
 x:10.4949
_:10.4749
 player:10.2699
 id:10.2385
current:10.1442
 prev:10.0996

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: ?, songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:19.5441
_:17.9704
State:15.8104
=:14.2708
 :14.1316
state:13.11
S:12.8457
  :12.7219
,:11.3613
 ->:11.1352	rejected
    :11.0088
 ::10.9014
Play:10.8185
 ==:10.5482	prefix accepted: =
::10.5364
   :10.4271
 as:10.3796	rejected
 state:10.2898	rejected
':10.1891	rejected

:10.1215
Id:10.0774

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:18.8549
 get:13.3475
 :13.1928

:12.9859
 List:12.0864	rejected
play:11.8589
 (:11.1349
 add:10.8887	rejected
 f:10.7011
 action:10.1353
 match:10.131	rejected
 if:10.011
 pl:9.81299
 Tu:9.77272	rejected
 update:9.75011
 current:9.64865	rejected
 p:9.64543
  :9.59797
 !:9.5211
 Play:9.49331
 in:9.42554

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:21.5709
List:13.4164	rejected
ist:13.2476	rejected
 list:12.7089	rejected
_:12.676	rejected
l:12.0529
lists:11.2462	rejected

:11.1991	rejected
lst:11.0636	rejected
lis:10.5314
ling:10.0413	rejected
 in:9.49046	rejected
,:9.42506	rejected
last:9.40769	rejected
.:9.39818	rejected
play:9.38856	rejected
lista:9.31881	rejected
ls:9.26659	rejected
state:9.0885	rejected
 :8.93931	rejected
 =:8.93579	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:20.8024
,:15.1417

:14.3875
 :13.9566
;:13.4194	rejected
 and:13.3666	rejected
.:12.5609	rejected
  :12.0666
 ,:11.051
                :10.7094
    :10.4445
 &&:10.3345
      :10.2589
   :9.78913
 |:9.73731	rejected
 +:9.67411
 ;:9.63685	rejected
       :9.57031
        :9.33666
 #:9.32079	rejected
,(:9.27616	prefix accepted:,

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.5997
 :17.3619
  :16.1916
    :14.8373
      :14.5858
        :13.3945
       :13.0551
   :13.0483
     :12.962
                :12.8518
            :12.7679
         :12.7419
 (*:12.7295	prefix accepted: (
          :12.4059
 (:12.7295
 [:12.1896
           :11.672
	:11.5758	rejected
 {:11.4498	rejected
             :11.4317
              :11.4122

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :20.1483
       :18.1643
      :17.7817

:15.8382
    :15.5557
        :15.4979
         :15.31
	:14.7627	rejected
          :13.6371
   :13.5506
#:13.2795	rejected
           :13.2299
  :13.2193
(*:12.5582	prefix accepted:(
                :12.2107
            :12.1455
 :12.1021
             :11.4903
               :10.9569
              :10.7055
##:9.91974	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:17.3062
 let:15.7668
 (:15.1627
 ([:14.7264	prefix accepted: (
 List:14.0539	rejected
 #:13.9995	rejected
 match:13.9193	rejected
 songs:13.7083
 song:13.5476
 (*:13.5395	prefix accepted: (
 case:13.4321
 [:13.2023
 ((:13.0266	prefix accepted: (
 add:12.6688	rejected
 play:11.8166
 get:11.7695
 Play:11.7034
 begin:11.6063	rejected
 {:11.5418	rejected
 !:11.152
 update:10.9738

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:16.9698	rejected
 not:14.4312	rejected
 !:13.0308
 song:12.2137
 (:11.985
 current:11.8208
 get:11.6588
 songs:11.1495
 Id:10.6974	rejected
 Play:10.6597
 :10.596
 Song:10.5315	rejected
  :10.1862
 Songs:10.054	rejected
 is:10.0198
 list:9.55816	rejected
 contains:9.52449	rejected
 f:9.40318
    :9.34166
 ~:9.33412	rejected
(:9.23842
Rejected the highest logit candidate  List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
List:15.5195	rejected
not:13.8582	rejected
current:12.5203
get:12.1859
song:11.8048
 List:11.1521	rejected
play:10.8639
Id:10.4467	rejected
Play:10.2998
#:10.1795	rejected
contains:10.0779	rejected

:10.0123
in:9.96299
Int:9.63227	rejected
is:9.48844
Option:9.46216	rejected
exists:9.38414	rejected
~:9.19801	rejected
find:9.18545	rejected
mem:9.16598	rejected
Not:9.04815	rejected
Rejected the highest logit candidate List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  current
Nature of error: Expecting type Bool but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ==:16.4661
 =:15.5917
 !=:14.7993
 <>:14.7286	prefix accepted: <
 \:13.3753
 ===:13.0687	prefix accepted: ==
=:11.8123
 is:11.7553	rejected
 <:14.7286
 &&:10.9529
.:10.9338	rejected
 !==:10.6463	prefix accepted: !=
):10.5106
==:10.4654
 >:10.3808
,:10.3318
 as:9.92072	rejected
 :=:9.91622	prefix accepted: :
 >=:9.90305
 ||:9.8635	rejected
 in:9.65265	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current ==

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 No:17.3933
 P:14.4845
 Play:12.5512
 (:11.9596
 :10.7686
 ?:10.7374	rejected
?:10.1422	rejected
 no:10.0471	rejected
 None:10.0463	rejected
 [:9.44274
 get:9.3734
 NO:9.31361	rejected
 ":9.08889
 ):8.96445	rejected
 Get:8.90046	rejected
 @:8.88943	rejected
No:8.82978
 Not:8.82219	rejected
 -:8.74835
 Id:8.4775	rejected
.:8.46777

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == No

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == No
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  No
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:20.5847
Selected:14.0237	rejected
Current:13.5974	rejected
_:13.31	rejected
State:12.0953	rejected
Selection:11.7193	rejected
 Song:10.823	rejected
Sound:10.8086	rejected
P:10.6189	rejected
Play:10.5334	rejected
Sing:10.1473	rejected
SON:10.1335	rejected
 song:10.0659	rejected
Music:9.74608	rejected
SS:9.6235	rejected
C:9.50421	rejected
):9.4922	rejected
Select:9.39332	rejected
Player:9.31033	rejected
Track:9.25737	rejected
Se:8.93053	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  NoS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:23.2042
on:14.4629
ongs:14.0197	rejected
song:12.1028	rejected
oup:11.8198	rejected
one:11.4623	rejected
ung:11.2926	rejected
ng:11.1411	rejected
 song:10.6738	rejected
onic:10.5903	rejected
ongo:10.4639	rejected
ound:10.4273	rejected
ond:10.2303	rejected
pon:10.1954	rejected
play:10.0829	rejected
oon:9.67476	rejected
ony:9.56459	rejected
ONG:9.38026	rejected
On:9.20772	rejected
ons:9.19314	rejected
uch:9.15061	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  NoSong
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:22.2347
Select:13.8927
Se:13.3214
selected:12.7544	rejected
):12.4085	rejected
Selection:11.7909	rejected
S:11.6609
 &&:11.3282	rejected
Selector:11.0709	rejected
 ||:11.057	rejected
Available:10.9933	rejected
Add:10.8779	rejected
SELECT:10.8713	rejected
 Selected:10.7818	rejected
Play:10.7502	rejected
Start:10.5644	rejected
 and:10.4915	rejected
 selected:10.2988	rejected
Set:10.0048	rejected
 or:9.98895	rejected
Id:9.88685	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):15.5741
 &&:15.5186
 \:14.8508
 ||:14.5698	rejected
 /\:13.8746	prefix accepted: /
 and:12.3146	rejected
 ):12.0976
 or:11.87	rejected
 :11.4756

:11.4377
 &:10.9834
 /:13.8746
)\:10.3895	prefix accepted:)
 |:10.3236	rejected
 ?:10.286	rejected
){:9.77641	prefix accepted:)
),:9.6887	prefix accepted:)
 ^:9.57508	rejected
 then:9.29927	rejected
 +:9.24396
()):9.23555	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:16.7928
 &&:15.9177
 \:15.5365

:15.4976
 ||:15.401	rejected
 :14.6776
 /\:13.7609	prefix accepted: /
 {:13.3097	rejected
 or:12.5526	rejected
 and:12.3089	rejected
  :12.1201
 &:12.0862
 #:12.0433	rejected
 /:13.7609
 ?:11.6771	rejected
 //:11.5455	prefix accepted: /
 (*:10.9094	prefix accepted: (
 (\:10.8188	prefix accepted: (
 (:10.9094
 in:10.4308	rejected
                :10.3545

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:16.8796
 :15.457
 (:15.4116
 ([:14.7849	prefix accepted: (
 [:14.2695
  :13.2099
 ((:13.1789	prefix accepted: (
 {:13.1338	rejected
 play:12.9299
 song:12.8381
 [(:12.5641	prefix accepted: [
 songs:12.1359
 add:12.032	rejected
 P:11.9215
 Play:11.8589
 []:11.5888
 (*:11.406	prefix accepted: (
    :11.2019
 current:10.9757
 begin:10.9739	rejected
      :10.953

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :20.9284
        :17.3808
         :17.3646
      :16.0633
	:16.0505	rejected
     :15.3322
          :14.4746
           :14.2028
#:12.968	rejected
            :12.8541
                :12.6912
             :12.6502

:12.6063
    :12.4434
               :12.1019
              :11.7816
   :11.7176
  :11.5351
 :11.018
(*:10.6472	prefix accepted:(
(:10.6472

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 ([:18.5575	prefix accepted: (
 (:18.5575
 [:15.8872
 #:15.3232	rejected
 let:14.9712
 if:14.8463
 ((:14.3106	prefix accepted: (
 songs:14.1269
 song:14.0008
 match:13.8968	rejected
 List:13.6001	rejected
 [(:13.3594	prefix accepted: [
 (*:13.262	prefix accepted: (
 add:13.1968	rejected
 [],:12.9408	prefix accepted: []
 get:12.9331
 Play:12.6399
 play:12.5566
 begin:12.4598	rejected
 case:11.9923
 P:11.91
Rejected the highest logit candidate  ([ with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:16.4318
play:13.1654
List:12.8495	rejected
 song:11.8083
 [:11.7945
if:11.637
get:11.6065
add:11.5368	rejected
current:11.3691
sing:10.9065	rejected

:10.8667
[]:10.7095
 songs:9.98733
([:9.84408	prefix accepted:(
list:9.82381	rejected
Add:9.5757
Play:9.25616
 List:9.13434	rejected
S:9.04543	rejected
cons:8.90951	rejected
update:8.89068

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "PlayList"); syn = (Var "Id")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Expecting type PlayList but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
:::18.4252
 :::16.9738
s:16.9584
 @:13.363
@:12.0001
,:11.599
 +:10.3537
 ::10.0669
::9.67509
_:9.56806	rejected
[:9.53391	rejected
 *:9.26415
.:9.0629	rejected
 [:8.88506	rejected
):8.75843
 #:8.69918	rejected
 in:8.48423	rejected
*:8.3796
:@:8.30074	prefix accepted::
+:8.29103
 //:8.15713	prefix accepted: /

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
song:18.112
[:14.466
get:12.7379
play:12.5927
(:12.0744
[]:12.0242
 songs:11.9534
List:11.3294	rejected
Nil:10.9944	rejected
s:10.359
@:10.1054	rejected
sing:10.0876	rejected
nil:10.0317	rejected
empty:9.54334	rejected
 [],:9.48915	prefix accepted: []
list:9.31714	rejected
0:9.18233
(),:9.00612	prefix accepted:()
plays:8.8467	rejected
Get:8.84544	rejected
reverse:8.80624	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal)); syn = (Var "Id")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  song :: song
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  song
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
s:22.3937
,:13.2816
:::10.492
.:9.62943	rejected
_:9.61824	rejected
[:9.54012	rejected
ss:9.05188	rejected
es:9.02973	rejected
sl:9.00732	rejected
List:8.90945	rejected
sp:8.64619	rejected
st:8.60593	rejected
 ,:8.56356
list:8.40073	rejected
sn:8.35514	rejected
):8.34001
sd:8.24487	rejected
),:8.22688	prefix accepted:)
 :::8.02766
Ids:7.80279	rejected
so:7.79347	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  song :: songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:18.6476
),:15.3429	prefix accepted:)
 ,:14.4723
 @:13.4637
):15.3429
@:12.0914
,[:11.3936	prefix accepted:,
 ::10.8705
 |:10.6916	rejected
.:10.3192	rejected
 as:10.2932	rejected
::10.1444
 +:9.94372
  :9.74132
,(:9.74041	prefix accepted:,

:9.6028
 :9.36315
,\:9.24447	prefix accepted:,
                :9.10077
 \:9.03008
).:8.77535	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 P:16.3675
 Play:15.3977
 current:13.9574
 No:13.8365
 playing:11.6488	rejected
 :10.7445
 state:10.6214	rejected
P:10.4235
 (:10.4033
 Current:10.2326	rejected
Play:10.1852
 Player:10.0885	rejected
 song:9.98842
 get:9.8623
 Song:9.62184	rejected

:9.51026
 play:9.14731
current:8.94105
 List:8.93254	rejected
 no:8.88471	rejected
 new:8.85504	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, P

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, P
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "auseCurrentSong" | "ausedOn" | "laySong" | "laying"
root ::= completions

Top 20 Logits:
aused:21.6027
ause:16.5892
ending:14.0027	rejected
LAY:13.7668	rejected
aus:13.6974
ushed:12.156	rejected
lain:11.4337	rejected
rep:11.2727	rejected
icked:11.125	rejected
au:11.0004
leased:10.9918	rejected
lay:10.7741
 paused:10.7533	rejected
ued:10.7159	rejected
osed:10.2371	rejected
Play:9.77218	rejected
play:9.65198	rejected
 playing:9.56884	rejected
air:9.55508	rejected
ushing:9.45728	rejected
uzz:9.3898	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, Paused

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, Paused
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:22.124
(:14.5234	rejected
):12.6989	rejected
S:11.6007	rejected
Current:11.1615	rejected
At:11.1287	rejected
on:11.1203	rejected
()):11.0817	rejected
State:10.9853	rejected
 On:10.8574	rejected
 song:10.8294	rejected
O:10.7593
 on:10.6126	rejected
In:10.5798	rejected
Play:10.4738	rejected
Of:10.2466	rejected
 (:10.2066	rejected
One:10.1826	rejected
_:10.1474	rejected
),:10.0681	rejected
No:9.76061	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Int -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:19.6747
 song:16.6036	rejected
(-:12.7187	prefix accepted:(
 (:12.5197
()):11.6417	prefix accepted:(
((:11.5251	prefix accepted:(
 :10.6879
([:10.6798	prefix accepted:(
):10.5569
(?:10.3445	prefix accepted:(
[:10.297	rejected
(_:9.92142	rejected
 Song:9.78463	rejected
 songs:9.6681	rejected
song:9.60059	rejected
(!:9.50409	prefix accepted:(
:::9.2807
(@:9.24327	prefix accepted:(
(*:9.23408	prefix accepted:(
(":9.17007	prefix accepted:(
 current:9.02176	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:20.6266
0:17.4023
get:14.3151
1:13.9295
List:13.7757	rejected
play:13.3791
No:13.1302
current:12.9069
Int:12.8125	rejected
 song:12.6244
Id:12.265	rejected
Play:12.2112
id:12.1997	rejected
P:11.7941
last:11.7765	rejected
sing:11.5897	rejected
first:11.4093	rejected
S:11.326	rejected
2:11.2008
s:11.1814
no:11.091	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
)):21.4619
)),:17.4037	prefix accepted:))
):14.7743
));:13.87	prefix accepted:))
),:13.5165	prefix accepted:)
s:13.4735
))\:13.4708	prefix accepted:))
))::13.1392	prefix accepted:))
))):12.2898	prefix accepted:))
)).:12.1302	prefix accepted:)
))]:11.2729	prefix accepted:))
)\:11.2523	prefix accepted:)
:::10.8963
 @:10.8582
,:10.8109
 :10.7033
_:10.6909	rejected
))`:10.631	prefix accepted:))
)))):10.6081	prefix accepted:))
)::10.5552	prefix accepted:)
 +:10.5529

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:18.9302
 else:17.3653
 :16.2105
 #:15.5113	rejected
  :15.3894
 :::14.6317
    :14.2989
 (*:13.7416	prefix accepted: (
 @:13.581
 \:13.4225
      :13.2656
   :13.123
        :12.9472
:::12.9427
 end:12.4124	rejected
                :12.3192
	:11.755	rejected
#:11.7432	rejected
 ,:11.7385
     :11.7125
 ::11.6791

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
     :21.3029
      :18.1811
       :17.6184
        :16.4393
    :16.0409
         :15.5543

:15.4103
	:15.3081	rejected
#:15.2838	rejected
   :15.114
          :14.8601
           :14.3207
                :13.9487
            :13.4348
  :13.018
else:12.9001
               :12.7214
              :12.6988
             :12.6608
 :12.5563
(*:12.5514	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:22.4181
 #:17.8463	rejected
 elif:17.0697	rejected
 els:15.9169
 (*:14.2284	prefix accepted: (
 end:14.1021	rejected
 el:12.9684
 if:12.9472	rejected
 \:12.7336
 ~:12.0013	rejected
 (:14.2284
 otherwise:11.7508	rejected
 //:11.5706	prefix accepted: /
 {:11.5171	rejected
 (\:11.4473	prefix accepted: (
 !:11.3995
 ##:11.3438	rejected
 |:11.0902	rejected
 Else:10.8792	rejected
 _:10.6583	rejected
 /:11.5706

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.747
 if:16.6566
 (:16.6139
 :16.3212
  :14.2243
 play:14.1584
 ((:14.0347	prefix accepted: (
 (*:13.6674	prefix accepted: (
    :12.9445
 ([:12.7515	prefix accepted: (
 match:12.6842	rejected
if:12.019
      :11.9307
        :11.8585
 List:11.7971	rejected
 {:11.7793	rejected
   :11.7633
 [:11.7519
(:11.7092
 #:11.7086	rejected
                :11.6766

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :21.496
      :18.8739
        :18.5158
         :17.4951
     :17.1279
	:16.4281	rejected
          :14.7565
    :14.3787
#:14.2448	rejected
           :14.1171

:13.7826
   :13.6609
  :13.1273
(*:12.8937	prefix accepted:(
            :12.6617
             :12.3694
 :12.1942
                :12.054
               :11.8343
              :11.7296
 #:11.075	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:19.8015
 if:17.8706
 ((:17.8627	prefix accepted: (
 let:17.7712
 ([:17.4763	prefix accepted: (
 match:17.3356	rejected
 #:16.8469	rejected
 play:16.5499
 (*:16.529	prefix accepted: (
 List:15.7402	rejected
 case:15.7033
 add:15.2517	rejected
 update:14.9963
 begin:14.8221	rejected
 ?:14.5417	rejected
 songs:14.5025
 [:14.3307
 song:14.2747
 get:14.1122
 go:13.8776	rejected
 (!:13.8685	prefix accepted: (

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:16.5403
List:15.4	rejected
if:15.3506
play:13.5958

:12.35
get:11.6684
add:11.6068	rejected
 song:11.4887
match:11.1846	rejected
Play:10.7753
Utils:10.4277	rejected
 if:10.2235
unique:10.2201	rejected
Set:10.1561	rejected
sing:10.0582	rejected
remove:9.91774	rejected
case:9.83017
 List:9.80841	rejected
set:9.72969	rejected
current:9.69091
update:9.65935

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "PlayList"); syn = (Var "Id")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Expecting type PlayList but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
:::18.2026
 :::16.5103
s:15.5465
@:12.7359
 @:12.5322
 +:11.4978
,:11.225
::11.0095
_:10.479	rejected
 ::10.474
#:10.3831	rejected
 #:10.2716	rejected
+:9.85026
.:9.48412	rejected
@@:8.81554	prefix accepted:@
 in:8.76656	rejected
|:8.65704	rejected
List:8.59383	rejected
 //:8.55397	prefix accepted: /
;:8.51461	rejected
 *:8.38248

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  song :: ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
song:18.7636
play:14.1811
get:14.1716
(:13.5701
List:13.5334	rejected
[:11.782
filter:11.6939	rejected
remove:11.5356	rejected
 songs:11.5256
if:10.7014
sing:10.1358	rejected
Get:10.074	rejected
((:9.98625	prefix accepted:(
set:9.92288	rejected
Play:9.53639
Filter:9.41136	rejected
 (:9.3761
s:9.2701
[]:9.15695
unique:9.12523	rejected
Remove:8.90052

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown Internal)); syn = (Var "Id")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song :: song
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
s:20.0237
,:13.4489
es:11.7876	rejected
ers:11.3025	rejected
:::10.521
.:9.97689	rejected
):9.96161
is:9.84271	rejected
List:9.70632	rejected
_:9.47383	rejected
ls:9.29322	rejected
ss:9.21195	rejected
(:9.1454
(),:9.14336	prefix accepted:(
[:9.10469	rejected
),:9.08063	prefix accepted:)
als:8.98891	rejected
ings:8.9515	rejected
sBy:8.74027	rejected
 :::8.73675
ies:8.70054	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  song :: songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.384
 @:14.7111
 ,:13.4567
@:12.6989
 \:11.926
),:11.588	prefix accepted:)
 |:10.8395	rejected
,\:10.5629	prefix accepted:,
):11.588

:10.0902
 :10.0433
,[:9.95678	prefix accepted:,
 ++:9.60915
 ::9.47318
:::9.2881
 \\:9.26596	prefix accepted: \
.:9.23477	rejected
 :::9.23252
::9.1943
  :9.05146
,,:9.0395	prefix accepted:,

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 current:18.2605
 Play:14.0474
 No:13.5987
 P:13.3083
 get:13.1788
current:12.4988
 :12.2504
 state:12.0888	rejected
 if:11.3862
 Current:11.0936	rejected
 song:10.952
 List:10.6676	rejected
 play:10.6632
 (:10.4351
 Song:10.2924	rejected
 add:10.198	rejected
 Player:10.064	rejected

:9.95288
 ?:9.93283	rejected
 Get:9.87468	rejected
 no:9.71897	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):20.2591
),:15.5657	prefix accepted:)
 ):14.7537
);:14.7038	prefix accepted:)
 end:13.1465	rejected
)\:12.5995	prefix accepted:)
 +:12.3661
 :12.1847
 @:11.9705

:11.3396
)):11.309
)::11.0304	prefix accepted:)
,:11.0231
 -:10.9385
 ||:10.6428	rejected
)]:10.5448	prefix accepted:)
 \:10.3814
 (*:10.2821	prefix accepted: (
)":10.1317	prefix accepted:)
@:10.1168
)}:9.99932	prefix accepted:)

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.2949
 :16.9081
 end:16.2482
  :15.2711
    :14.2135
        :14.1648
      :14.1278
 #:13.863	rejected
 (*:13.7972	prefix accepted: (
 in:12.8609	rejected
   :12.7137
                :12.4713
          :12.0011
            :11.7733
     :11.7601
 @:11.7247
       :11.585
         :11.437
	:10.9645	rejected
end:10.8633
           :10.8226

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:21.5613
 end:18.5642
 #:18.1313	rejected
 (*:16.7708	prefix accepted: (
	:15.6087	rejected
 in:14.866	rejected
 @:14.5509
 *:13.1958
 //:13.1855	prefix accepted: /
 fi:12.6883	rejected
 ##:12.3045	rejected
 \:11.9383
 (**:11.703	prefix accepted: (
1:11.6644	rejected
 #(:11.5673	rejected
 --:11.4876	prefix accepted: -
 <:11.4174
0:11.3442	rejected
 ::11.3118
 /*:11.2147	prefix accepted: /
 ###:11.212	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :17.3802
    :16.2085
     :15.694

:15.2334
      :14.8748
  :14.5197
        :14.058
#:12.8633	rejected
 :12.5914
          :12.1536
       :11.9656
	:11.8015	rejected
                :11.7708
            :11.3579
(*:11.2245	prefix accepted:(
         :11.0982
|:10.9966
end:10.9281
              :10.456
           :10.1882
             :9.43584

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
   

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:19.744
 #:18.0313	rejected
 (*:15.5434	prefix accepted: (
 end:15.3024
 else:13.8084	rejected
 //:12.8802	prefix accepted: /

:12.8017
 elif:12.6962	rejected
 <:12.1694
 ~:12.1062	rejected
 case:11.8792	rejected
 (**:11.5485	prefix accepted: (
 ||:11.4989	prefix accepted: |
 (:15.5434
 _:11.2631	rejected
 ,:11.1825
 *:11.1527
 in:11.1019	rejected
 if:11.0284	rejected
 let:10.9104	rejected
 match:10.8824	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Play:17.9301
 Remove:17.6157
 P:14.8818
 _:14.5181
 Rem:11.0947
 :10.6379
Play:10.5999
 Player:10.4147	rejected
Remove:10.3531
 remove:9.60519
 Delete:9.53609	rejected

:9.37271
 #:9.34327	rejected
 Start:9.19496	rejected
 Add:9.14939
 Stop:9.12232	rejected
 Next:8.7971	rejected
 play:8.78331
 Clear:8.71939	rejected
P:8.70189
 Move:8.65587	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | Play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | Play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song" | "ing"
root ::= completions

Top 20 Logits:
S:20.0916
ing:12.2626
P:12.1453	rejected
Current:12.0141	rejected
List:10.9553	rejected
 song:10.9207	rejected
(:10.8144	rejected
_:10.7162	rejected
Sound:10.6301	rejected
Or:10.3035	rejected
 Song:9.83076	rejected
list:9.74612	rejected
p:9.09051	rejected
song:9.0578	rejected
ed:9.05439	rejected
Music:8.98508	rejected
Action:8.93726	rejected
Selected:8.73362	rejected
 ->:8.72782	rejected
Next:8.67426	rejected
Sing:8.61419	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlayS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlayS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PlayS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PlayS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PlayS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PlayS
LSP: Generating Completions for prefix: PlayS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:24.3806
ongs:16.4388	rejected
 song:13.0677	rejected
on:12.3371
song:11.8799	rejected
ongo:11.6903	rejected
ame:9.67328	rejected
ug:9.62521	rejected
oup:9.58354	rejected
ond:9.55992	rejected
n:9.3889	rejected
(:9.13832	rejected
onic:9.11788	rejected
oon:9.07819	rejected
ou:9.01375	rejected
ng:8.81894	rejected
one:8.72692	rejected
inger:8.56994	rejected
ang:8.53808	rejected
ONG:8.42212	rejected
ound:8.15163	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PlaySong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Int -> (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PlaySong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PlaySong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PlaySong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:18.0552
(_:14.6313	rejected
 song:14.6202	rejected
 id:13.4041	rejected
(-:12.1742	prefix accepted:(
 (:11.1678
(?:11.0636	prefix accepted:(
 _:10.9676	rejected
():10.8166	prefix accepted:(
((:10.6159	prefix accepted:(
 s:10.1884	rejected
 next:10.0878	rejected
 i:10.0834	rejected
 ->:9.76879	rejected
 None:9.5033	rejected
 x:9.42097	rejected
 new:9.35666	rejected
 current:9.32854	rejected
([:9.28774	prefix accepted:(
 selected:9.1526	rejected
 p:9.08215	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:17.981
id:17.1036
play:14.3824
selected:14.014
new:13.8841
next:13.8061
idx:13.6675
i:13.4796
Id:13.1635	rejected
x:13.0046
index:12.8535
current:12.7392
0:12.7266
target:12.3701
None:12.3568	rejected
p:12.232
n:12.1189
s:11.883
Play:11.8049
1:11.4041
sound:11.3389

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):19.3949
_:17.6873
Id:16.296
id:15.4251
ID:13.7015
)=:13.49	prefix accepted:)
),:13.2979
)->:13.2526	prefix accepted:)
1:12.9288
s:12.3469
To:12.2194
_):11.7529	prefix accepted:_
Index:11.6451
)|:11.6319	prefix accepted:)
2:11.5032
 ):11.4363
 as:11.3742	rejected
'):10.9095	rejected
0:10.7313
 =:10.5624	rejected
)::10.5158	prefix accepted:)

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.704
 ->:14.9589	rejected
 when:13.8204	rejected
 :13.4341
 if:12.666	rejected
  :12.1977

:12.0458
    :10.8002
      :10.3712
   :10.317
 :=:10.0804	rejected
=>:10.0505
 =:9.99404
 |:9.96625	rejected
        :9.67346
     :9.44635
 ?:9.4165	rejected
         :9.39337
          :9.34698
 ||:9.24739	rejected
 {:9.23209	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.9356
 (:16.4322
 :16.25
  :14.4202
 songs:13.7695	rejected
 ([:13.5569	prefix accepted: (
 get:13.2809
 [:13.2104
 if:13.0056
 play:12.8635
 song:12.7413
    :12.6611
 (*:12.4757	prefix accepted: (
 List:12.3048	rejected
 #:11.9464	rejected
      :11.8569
 ?:11.8182	rejected
        :11.737
 ((:11.6628	prefix accepted: (
 let:11.3741
                :11.3053

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :21.9638
      :20.366
       :18.6498
    :18.195
        :17.2603
         :16.6095
	:16.2117	rejected
   :15.8963
#:15.4315	rejected

:14.9407
          :14.7447
           :14.6568
  :14.1585
            :13.75
                :13.2247
             :12.967
 :12.8619
               :12.5641
              :12.3551
 #:11.5434	rejected
(*:11.2055	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:19.7971
 (:17.946
 if:17.6302
 case:17.3097
 #:17.1557	rejected
 match:16.6185	rejected
 ([:16.4525	prefix accepted: (
 get:15.9586
 (*:15.8095	prefix accepted: (
 List:15.2505	rejected
 song:14.9411
 ((:14.8579	prefix accepted: (
 begin:14.1269	rejected
 play:14.0269
 assert:13.7773	rejected
 [:13.7652
 ?:13.4576	rejected
 songs:13.2346	rejected
 update:13.2081
 [],:12.9752	prefix accepted: []
 _,:12.6389	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:16.8376
 song:13.6519
 _,:13.492	prefix accepted: _
 _:13.492
 current:11.8403
 is:11.5213
 xs:11.2392
 s:11.0404
 new:11.0225
 play:10.9916
 (:10.9181
 all:10.9048
 state:10.8759
 ids:10.3061
 add:10.242
 id:10.1905
 rec:10.0687
 cur:10.0426
 old:9.83075
 list:9.80965
 Songs:9.77314	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:20.0795
 =:17.3288
 ,:14.2342
_:13.664
::12.5084
_,:12.4595	prefix accepted:_
=:12.4403
 ::11.8718
1:11.8357
  :11.679
 :11.5819
',:11.219	rejected
 in:10.999	rejected
0:10.5796
    :10.5513
 _,:10.5333	rejected
      :10.5216
2:10.3065
   :10.3027
 _:9.98005	rejected
In:9.95659

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 _:18.1718
 current:17.3596
 state:16.6103
_:13.3614
 old:13.155
 song:12.8779
 curr:11.6136
 previous:11.4887
 status:11.2772
 prev:11.1939
 playing:11.1456
 play:10.9262
 x:10.9032
 p:10.8615
 c:10.8609
 :10.7781
current:10.7629
 s:10.7528
 cur:10.7414
 selected:10.6975
 paused:10.4301

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= new-tokens

Top 20 Logits:
 =:18.1399
=:13.8993
current:13.7946	rejected
 ->:13.6048	rejected
 :13.4524
    :13.2932
state:13.0756	rejected
 as:12.9312	rejected
  :12.378
old:11.765	rejected
   :11.6953
curr:11.391	rejected
      :11.0191
     :11.0138
play:10.7454	rejected
previous:10.45	rejected
prev:10.3989	rejected
__:10.2903	rejected
____:9.97705	rejected
 current:9.80326	rejected
 in:9.72265	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:19.6481
 :13.0286
play:12.7519
 List:11.6891	rejected
 get:11.6581
 (:11.2625

:10.707
 current:10.5939	rejected
 song:10.5753
 pl:10.4463
 action:10.358
 list:10.3467	rejected
 p:10.2153
 songs:10.0373	rejected
  :9.89321
 remove:9.78293	rejected
 Play:9.67654
 player:9.52623	rejected
 pal:9.46197	rejected
 find:9.25831	rejected
 update:9.1563

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:22.1575
List:15.3463	rejected
l:12.7694
 list:12.7693	rejected
_:12.7668	rejected
ist:12.6632	rejected
.:11.1099	rejected
lists:10.4918	rejected
let:10.4886	rejected
line:10.4401	rejected
lib:10.4355	rejected
lis:10.4149
link:10.2884	rejected
,:10.1696	rejected

:10.0842	rejected
label:9.82956	rejected
load:9.82548	rejected
lst:9.8033	rejected
lit:9.41067	rejected
li:9.38385
 :9.34566	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:19.1409
 :13.7251

:13.6907
,:12.6993
 and:11.6933	rejected
  :11.5889
;:11.1976	rejected
.:11.0127	rejected
in:9.57036
    :9.33843
 ,:9.24586
   :9.15915
                :9.06895
      :8.90121
 #:8.88618	rejected
 ?:8.81461	rejected
 |:8.69818	rejected
	:8.46297	rejected
 is:8.40908	rejected
 &&:8.35437
 ;:8.26293	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.5551
 :16.6464
  :15.6647
      :14.4502
    :14.3467
        :12.945
 (:12.8746
   :12.5827
 songs:12.3941
 (*:12.3735	prefix accepted: (
                :12.2263
     :12.206
          :12.1124
         :12.1105
            :12.0634
 song:12.0323
 #:11.5634	rejected
 List:11.5274	rejected
       :11.4915
	:11.4101	rejected
 [:11.2073

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :21.06
      :18.1984
    :16.6666
       :16.628

:15.4887
         :15.1327
        :15.0291
	:14.6811	rejected
   :14.3611
  :13.9804
#:13.8071	rejected
          :13.4551
           :13.3737
(*:12.6555	prefix accepted:(
 :12.3608
            :12.1607
                :11.7213
             :11.6257
(:12.6555
if:10.8786
               :10.8418

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:19.4801
 if:18.8849
 case:18.2453
 let:17.3085
 ([:17.0279	prefix accepted: (
 #:16.6634	rejected
 List:16.6469	rejected
 (*:16.2749	prefix accepted: (
 match:16.2095	rejected
 songs:15.3774
 ((:14.8334	prefix accepted: (
 assert:14.261	rejected
 get:14.0829
 song:14.069
 begin:13.9485	rejected
 update:13.727
 [:13.4573
 (!:13.3326	prefix accepted: (
 print:13.2717	rejected
 play:13.0789
 //:12.7256	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:17.2917	rejected
 (:16.0777
 song:15.4105
 not:14.6665	rejected
 get:12.8833
 ((:12.8214	prefix accepted: (
 songs:12.7504
 Song:12.0403	rejected
 !:12.0334
 current:11.812	rejected
(:11.7714
 (!:11.6872	prefix accepted: (
 is:11.5731
 :11.2721
 Songs:10.7921	rejected
 Play:10.7904
 list:10.525	rejected
 f:10.3828
 play:10.3147
 contains:10.153	rejected
 Int:10.1072	rejected
Rejected the highest logit candidate  List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = (Var "Id")})))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Expecting type Bool but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 ==:14.1727
 =:13.6009
 !=:13.268
 in:13.1651	rejected
 \:12.9499
 `:12.9112	rejected
 <:12.7952
 <>:12.3027	prefix accepted: <
_:12.1939	rejected
 :::11.7442
 not:11.3249	rejected
 >=:11.2405
:::10.9497
 is:10.9174	rejected
 >:10.869
 <=:10.5268
 IN:10.4614	rejected
 !:10.3374
 |:10.3142	rejected
 @:10.1601
 #:10.1182	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song ==

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 List:13.7844	rejected
 get:13.3065
 h:12.8493	rejected
 ?:11.9861	rejected
 None:11.7961	rejected
 Id:11.7467	rejected
 :11.4468
 (:11.3698
 -:11.2917
 Int:10.7228	rejected
 head:10.3573	rejected
 !:10.194
 f:10.0695
 No:9.98292
 P:9.7305
 #:9.57093	rejected
 Play:9.55249
 Song:9.43516	rejected
 songs:9.38854
 current:9.36559	rejected
 ":9.24057
Rejected the highest logit candidate  List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get"))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  get
Nature of error: Variable get is not bound
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get
LSP: Generating Completions for prefix: get
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_songs" | "_state"
root ::= completions

Top 20 Logits:
_:20.2826
State:12.3604	rejected
Id:11.9932	rejected
Play:11.4568	rejected
Current:11.2261	rejected
S:11.072	rejected
(:10.849	rejected
state:10.6718	rejected
First:10.0697	rejected
.:9.819	rejected
<:9.60209	rejected
List:9.58506	rejected
_(:9.47677	prefix accepted:_
P:9.45861	rejected
 state:9.29224	rejected
Last:9.13094	rejected
id:8.99772	rejected
Player:8.91701	rejected
-:8.80116	rejected
Selected:8.74741	rejected
Music:8.5058	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get_"))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  get_
Nature of error: Variable get_ is not bound
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get_
LSP: Generating Completions for prefix: get_
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "songs" | "state"
root ::= completions

Top 20 Logits:
state:20.8241
song:17.376
id:16.3918	rejected
play:16.206	rejected
current:16.2023	rejected
selected:16.2016	rejected
first:15.4547	rejected
last:15.0692	rejected
next:14.3266	rejected
p:13.9973	rejected
cur:13.7638	rejected
top:13.3714	rejected
curr:13.364	rejected
active:13.2444	rejected
head:13.1132	rejected
new:12.973	rejected
now:12.8616	rejected
player:12.7879	rejected
most:12.7273	rejected
sing:12.6233	rejected
default:12.4878	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected)) -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id");
           syn = (Arrow ((Var "PlayList"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state
Nature of error: Expecting type Id but got inconsistent type (PlayList -> PlayListState)
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: get_state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: get_state
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
(:17.7186
 play:14.2052	rejected
():12.5036	prefix accepted:(
.:12.3546	rejected
 then:11.9059
.(:11.2789	rejected
 (:11.2052
_:10.9025	rejected

:10.8646
((:10.8021	prefix accepted:(
(*:10.541	prefix accepted:(
([:10.1923	prefix accepted:(
 song:10.1343	rejected
 in:10.0733	rejected
[:9.79148	rejected
(@:9.7128	prefix accepted:(
 {:9.56885	rejected
({:9.42998	prefix accepted:(
().:9.31935	prefix accepted:(
play:9.24658	rejected
(_:9.22156	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
play:21.1562
song:14.1568
No:13.2466
List:13.155	rejected
Play:12.9123
current:12.7651	rejected
get:12.7026
p:12.4842
pl:12.1768
action:11.9035
 play:11.4661
player:11.4631	rejected
P:11.4151
pal:11.3347	rejected
remove:11.2837	rejected
no:11.2059	rejected
add:10.7319	rejected
update:10.7197
new:10.5089	rejected
Current:10.321	rejected
next:10.2429	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(play)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:22.125
List:15.3468	rejected
lists:13.4679	rejected
ist:13.4369	rejected
lis:12.8701
l:12.5467
lit:12.0388	rejected
ing:11.9126	rejected
lst:11.9122	rejected
ls:11.8435	rejected
_:11.4973	rejected
 list:11.2492	rejected
):11.1716	rejected
ers:9.89006	rejected
ilst:9.82861	rejected
state:9.76156	rejected
li:9.72969
.:9.59727	rejected
State:9.52788	rejected
ed:9.39935	rejected
L:9.3667	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):19.5366
).:14.3834	rejected
)\:12.7603	prefix accepted:)
)::12.277	prefix accepted:)
);:12.1778	prefix accepted:)
 ):12.1185
,:11.9668
)?:11.9051	prefix accepted:)
)(:11.778	prefix accepted:)
::11.5103
)[:11.4117	prefix accepted:)
),:11.3455	prefix accepted:)
.:11.2239	rejected
)->:11.1543	prefix accepted:)
)!:11.0346	prefix accepted:)
 =:10.6248
){:10.5861	prefix accepted:)
)=:10.2854	prefix accepted:)
)^:9.96601	prefix accepted:)
 then:9.9053	rejected
()):9.88295	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:17.5234

:16.019
 :15.5065
 &&:14.7871
 ||:14.6317	rejected
 #:14.0721	rejected
 \:13.0502
  :12.5818
 or:11.563	rejected
 (*:11.4082	prefix accepted: (
 //:11.3471	prefix accepted: /
 and:11.3292	rejected
 -:10.7974
 =:10.7233
 {:10.6408	rejected
    :10.6207
then:10.5552
 ->:10.3687	prefix accepted: -
 +:10.233
      :10.1521
                :10.1125

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.2391
 :16.224
 play:15.8402
 (:15.7962
  :13.9965
 ([:13.9441	prefix accepted: (
 [:13.6348
 #:13.5381	rejected
 (*:13.5252	prefix accepted: (
 ():13.5163
 []:12.8857
    :12.2571
 songs:12.1817
      :11.9857
 ?:11.7312	rejected
        :11.5106
 {:11.2628	rejected
   :11.1392
 ((:11.1132	prefix accepted: (
 [],:11.0865	prefix accepted: []
 song:10.8951

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :20.9428
        :18.808
         :18.2856
      :17.9251
	:16.8008	rejected
          :15.8556
     :15.7687
           :15.0617
            :13.9374
             :13.7505
    :13.5989
#:13.0419	rejected

:13.0388
                :13.0349
               :12.7838
              :12.5384
  :12.3797
   :12.3734
 :11.5349
(*:11.3764	prefix accepted:(
 #:10.2363	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:19.3503
 (:17.478
 #:16.7911	rejected
 let:15.9084
 ([:15.4628	prefix accepted: (
 (*:15.4127	prefix accepted: (
 ?:14.9621	rejected
 List:14.7111	rejected
 if:14.6309
 fail:14.2469	rejected
 raise:13.9922	rejected
 [:13.8458
 ((:13.5447	prefix accepted: (
 case:13.0588
 f:12.9233
 print:12.8681	rejected
 match:12.8572	rejected
 get:12.6746
 update:12.5657
 error:12.2814	rejected
 return:12.2658	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:20.3345
List:13.4586	rejected
ist:12.4706	rejected
(:11.8307	rejected
_:11.364	rejected
lists:10.7784	rejected
lit:10.6657	rejected
l:10.6427
play:10.3508	rejected
():10.1842	rejected
 list:10.1537	rejected
lst:9.74627	rejected

:9.69949	rejected
Play:9.29646	rejected
lis:9.15467
state:8.9502	rejected
let:8.89217	rejected
ls:8.76949	rejected
S:8.61384	rejected
ilst:8.34135	rejected
State:8.28067	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:19.2451
 #:16.9589	rejected
 :16.758
  :15.7194
 (*:15.2718	prefix accepted: (
 @:14.0408
    :14.0016
      :13.8807
        :13.5425
                :13.401
   :12.8746
;:12.6806	rejected
            :12.5983
,:12.4001
 else:12.358
          :12.2274
         :12.2159
#:12.1287	rejected
     :11.9933
       :11.9497
 *:11.9158

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
     :22.0593
      :17.3146
       :16.4376
    :15.9169
        :14.9085
	:14.7218	rejected
#:14.7217	rejected

:14.5602
   :14.3798
         :14.0335
          :13.2927
           :12.7965
  :12.7655
(*:12.738	prefix accepted:(
                :12.4868
 :12.1397
else:12.0865
            :11.9245
             :11.3949
               :11.1346
              :11.1253

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:21.2919
 elif:18.214	rejected
 #:17.417	rejected
 els:15.8139
 (*:15.1743	prefix accepted: (
 if:13.7594	rejected
 el:13.4626
 (:15.1743
 end:12.2704	rejected
 ((:12.1129	prefix accepted: (
 let:12.0357	rejected
 {:11.7449	rejected
 Else:11.7032	rejected
 #(:11.5145	rejected
 ~:11.3153	rejected
 match:11.1591	rejected
 ##:11.1486	rejected
 [:10.9575	rejected
 otherwise:10.9416	rejected
 (**:10.8731	prefix accepted: (
 //:10.7655	prefix accepted: /

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.5466
 if:17.0009
 :16.5379
 (:15.8761
  :14.6662
    :13.5438
 case:13.5087
 (*:12.7408	prefix accepted: (
 begin:12.7366	rejected
      :12.6852
 ((:12.5748	prefix accepted: (
        :12.4085
 [:12.2419
 match:12.1007	rejected
   :12.0297
 List:11.9345	rejected
 ([:11.9258	prefix accepted: (
 songs:11.8725
 play:11.8264
                :11.7938
 #:11.6917	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :22.6658
      :20.4346
        :19.8917
         :18.7326
     :18.1942
	:17.1809	rejected
    :15.7048
          :15.6658
           :15.4345

:14.9278
#:14.7772	rejected
  :14.5071
   :14.1711
            :13.9133
             :13.7731
                :13.4289
              :13.111
               :13.1027
 :12.9843
(:12.7933
(*:12.778	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:20.1678
 ([:18.4607	prefix accepted: (
 case:17.9263
 match:17.4412	rejected
 let:17.1884
 if:16.8564
 List:16.5287	rejected
 #:16.4183	rejected
 (*:16.1491	prefix accepted: (
 ((:15.5795	prefix accepted: (
 songs:14.8969
 begin:14.6751	rejected
 play:14.6467
 update:14.6128
 [:14.0306
 get:13.7714
 add:13.641	rejected
 remove:13.226	rejected
 (!:12.9744	prefix accepted: (
 //:12.9432	rejected
 try:12.828	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:18.6267
List:15.253	rejected
get:15.2362
remove:12.3563	rejected
if:12.2552
play:11.8812

:11.8353
filter:11.7926	rejected
 songs:11.4934
let:11.1305
set:10.7554	rejected
f:10.6689
sing:10.3376	rejected
update:10.1382
find:10.0865	rejected
in:9.86454
add:9.86067	rejected
Play:9.82891
list:9.78181	rejected
reverse:9.71883	rejected
delete:9.48016	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = (Var "PlayList"); syn = (Var "Id")})))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Expecting type PlayList but got inconsistent type Id  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
s:19.9905
:::15.9535
 :::14.0359
,:11.8252
 @:11.489
@:11.4235
es:10.575	rejected
.:10.5444	rejected
 +:10.1685
::10.1196
 in:9.73529	rejected
_:9.63746	rejected
List:9.26571	rejected
sBy:9.26422	rejected
[:9.23727	rejected
 -:9.13386
ss:8.74961	rejected
 ::8.74353
):8.533
->:8.39906	prefix accepted:-
 //:8.26357	prefix accepted: /

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:19.8416
 @:14.6281
 ,:14.5141
@:12.951
 ++:11.5108
 +:11.2053
,(:11.0602	prefix accepted:,
::11.0111
 ::10.8662
,[:10.7566	prefix accepted:,
.:10.7232	rejected
 |:10.1473	rejected
[:10.0119	rejected

:9.85529
_:9.73202	rejected
 List:9.56808	rejected
 [:9.36953	rejected
 \:9.32757
 :9.27766
[@:9.19647	rejected
,\:9.14993	prefix accepted:,

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 P:18.298
 Play:17.1771
 No:13.7469
 playing:12.3875	rejected
 current:12.3795	rejected
Play:12.3509
 if:11.7423
 (:11.5278
P:11.4858
 :11.424
 get:11.2035
 Player:10.7824	rejected
 Current:10.698	rejected
 song:10.4567
 Song:10.176	rejected

:9.85516
 play:9.70955
 state:9.09717	rejected
  :9.01292
 Running:8.8893	rejected
 ((:8.57481	prefix accepted: (

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, P

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, P
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "auseCurrentSong" | "ausedOn" | "laySong" | "laying"
root ::= completions

Top 20 Logits:
aused:23.4774
ause:16.3542
LAY:14.5399	rejected
aus:13.5481
ending:13.0449	rejected
ushed:12.4488	rejected
lay:12.0147
leased:11.5783	rejected
 paused:11.3236	rejected
lain:11.1893	rejected
au:10.8795
icked:10.7619	rejected
osed:10.6353	rejected
anned:10.4311	rejected
rep:10.2007	rejected
ained:10.0369	rejected
Play:9.91588	rejected
ushing:9.73784	rejected
 playing:9.72137	rejected
anning:9.63818	rejected
lapsed:9.63434	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, Paused

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, Paused
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  Paused
Nature of error: Constructor is not defined  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:23.9371
(:13.6916	rejected
on:12.713	rejected
S:12.4263	rejected
Off:12.0027	rejected
ON:11.8886	rejected
To:11.6642	rejected
Play:11.6335	rejected
If:11.5499	rejected
In:11.4829	rejected
Of:11.3301	rejected
):10.9022	rejected
At:10.8735	rejected
Or:10.7943	rejected
O:10.6437
 on:10.5856	rejected
From:10.5445	rejected
State:10.5215	rejected
Current:10.4847	rejected
By:10.369	rejected
And:10.337	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Int -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:21.5389
 song:14.8758	rejected
((:13.8426	prefix accepted:(
 (:13.3556
()):12.2093	prefix accepted:(
):11.0289
(_:10.8455	rejected
(-:10.6697	prefix accepted:(
([:10.6688	prefix accepted:(
(@:10.6413	prefix accepted:(
[:10.5729	rejected
({:10.3944	prefix accepted:(
(?:10.2444	prefix accepted:(
.(:10.1106	rejected
song:10.0255	rejected
(!:9.96458	prefix accepted:(
(\:9.93133	prefix accepted:(
(*:9.74918	prefix accepted:(
(":9.44841	prefix accepted:(
)(:9.23255	prefix accepted:)
():9.22508	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:21.5153
get:16.8125
current:14.4089	rejected
List:14.1455	rejected
play:13.953
Play:13.7085
0:13.5275
No:13.1689
if:12.7576
P:12.4612
 song:12.2247
next:11.8857	rejected
id:11.7118	rejected
f:11.5817
Int:11.5237	rejected
1:11.4862
S:11.3297	rejected
sound:11.1446	rejected
Id:11.1441	rejected
find:11.1349	rejected
hd:11.1216	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
)):22.7317
)),:15.6507	prefix accepted:))
):15.0601
))):14.369	prefix accepted:))
),:14.1141	prefix accepted:)
));:14.049	prefix accepted:))
)).:13.0219	prefix accepted:)
s:12.9734
))\:12.6658	prefix accepted:))
))::11.8046	prefix accepted:))
)))):11.4982	prefix accepted:))
 :11.4348
 @:11.3674
))`:11.1892	prefix accepted:))
);:11.1108	prefix accepted:)
))]:11.0691	prefix accepted:))
 +:10.6643
)));:10.53	prefix accepted:))
 -:10.4907
::10.4862
@:10.4838

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.6283
 end:17.9894
 :17.7115
  :16.8752
      :15.8056
    :15.7057
        :15.4165
 #:15.2634	rejected
 (*:14.8145	prefix accepted: (
 in:14.4828	rejected
   :14.2506
                :13.7362
          :13.6193
         :13.5397
            :13.3118
       :13.2656
     :13.2598
 @:12.8639
           :12.733
end:12.5749
	:12.5291	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.471
    :15.469

:14.5018
     :14.2759
  :14.0293
      :13.6082
        :13.2769
#:12.9273	rejected
 :12.7085
       :12.1712
(*:11.5784	prefix accepted:(
end:11.5328
	:11.2383	rejected
         :11.135
          :10.9876
                :10.573
            :10.4774
|:9.87277
           :9.75998
in:9.65902	rejected
 #:9.50256	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
   

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.1253
 #:17.6967	rejected
 end:15.851
 (*:15.7888	prefix accepted: (
 //:13.3191	prefix accepted: /
 case:12.5956	rejected
 ...:12.3756	rejected
 ():11.9977	prefix accepted: (
 <:11.7922

:11.6809
 /*:11.6588	prefix accepted: /
 --:11.5055	prefix accepted: -
 (**:11.4679	prefix accepted: (
 else:11.4616	rejected
 (:15.7888
 in:11.3587	rejected
 P:11.3098	rejected
 {:11.3009	rejected
 ||:11.2372	prefix accepted: |
 ##:11.1035	rejected
 *:11.0873

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Remove:18.3131
 P:17.8788
 _:13.1483
 Play:12.4384
 Stop:11.476	rejected
 Rem:11.3185
Remove:11.033
P:11.0272
 :10.8698
 Res:10.2752	rejected
 Next:10.0986	rejected
 #:10.0159	rejected
 No:9.87113
 Delete:9.65648	rejected
 Current:9.36046	rejected
 Move:9.15919	rejected
 Rest:9.04034	rejected
 Get:8.95918	rejected
 Add:8.95115
 Re:8.93684
 remove:8.92941

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | Remove

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | Remove
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Remove>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Remove"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  Remove
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Remove
LSP: Generating Completions for prefix: Remove
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:20.809
Current:12.8986	rejected
(:11.8888	rejected
All:11.4502	rejected
 Song:11.4044	rejected
From:10.5297	rejected
Selected:10.426	rejected
 song:10.2987	rejected
_:10.0283	rejected
Sound:10.0252	rejected
Last:9.64887	rejected
Id:9.02136	rejected
Play:9.01374	rejected
Sing:8.99937	rejected
(_:8.97676	rejected
song:8.86934	rejected
SON:8.8567	rejected
T:8.62883	rejected

:8.47298	rejected
First:8.46081	rejected
P:8.41697	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "RemoveS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  RemoveS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: RemoveS
LSP: Generating Completions for prefix: RemoveS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:23.6199
ongs:16.0098	rejected
on:13.3682
song:12.8508	rejected
ongo:11.3294	rejected
ond:11.0192	rejected
 song:10.8578	rejected
n:10.4999	rejected
oon:10.4029	rejected
ng:10.3973	rejected
og:10.2313	rejected
one:10.0013	rejected
ang:9.40112	rejected
ogn:9.33505	rejected
ame:9.30049	rejected
ou:9.25024	rejected
(:9.19869	rejected
ONG:9.17846	rejected
om:9.14769	rejected
ont:9.12797	rejected
g:9.09699	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <RemoveSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Int -> (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int)))
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  RemoveSong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: RemoveSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: RemoveSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.5013
(_:16.8994	rejected
 song:13.3091	rejected
 id:13.2224	rejected
 (:12.5105
():11.9501	prefix accepted:(
 _:11.5698	rejected
((:10.8692	prefix accepted:(
 ->:10.5574	rejected
 s:10.478	rejected
(?:10.2856	prefix accepted:(
([:10.0967	prefix accepted:(
 =>:10.0199
 x:9.60548	rejected
 (_:9.59595	rejected
 i:9.37278	rejected
 sid:9.21852	rejected
 :9.0911
(...):8.93957	rejected

:8.93937
(-:8.92771	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:18.7869
id:17.4201
to:14.1936
remove:14.0257
rem:13.7658
idx:13.5156
i:13.4075
target:13.1718
index:12.932
current:12.9198
x:12.8164
Id:12.6207	rejected
s:12.2234
selected:12.1757
n:12.0622
key:11.8088
0:11.7947
sound:11.693
1:11.676
play:11.4411
rm:11.3188

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | ","
root ::= completions | new-tokens

Top 20 Logits:
):20.0371
Id:16.2668
_:16.2392
id:15.3851
To:14.6156
)->:13.8254	prefix accepted:)
)=:13.7476	prefix accepted:)
ID:13.6165
s:13.2288
),:12.4919
1:12.4023
_):12.3477	prefix accepted:_
2:11.9439
 ):11.8533
'):11.5547	rejected
t:11.3815
Index:11.1943
 as:11.174	rejected
::10.965	rejected
)|:10.881	prefix accepted:)
)::10.579	prefix accepted:)

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.634
 ->:14.5975	rejected
 when:13.7021	rejected
 :13.6372

:13.1023
 if:12.8445	rejected
  :11.6734
 as:11.1988	rejected
    :10.5457
 :=:10.44	rejected
 in:10.3457	rejected
=>:9.97977
      :9.86669
 =:9.84371
	:9.81897	rejected
   :9.74335
 then:9.56989	rejected
 |:9.48667	rejected
 :::9.31483	rejected
        :9.25311
 ==>:9.18034	prefix accepted: =

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.2665
 :16.907
  :15.3423
 (:13.7443
    :13.6733
 (*:13.4967	prefix accepted: (
      :13.4179
 #:13.2327	rejected
        :13.2017
 ?:12.4333	rejected
                :12.2819
 update:12.1233
   :12.1211
 ():12.0926
         :12.0712
            :11.7748
 {:11.7113	rejected
 remove:11.6615	rejected
     :11.6542
          :11.6174
 let:11.428

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :22.1506
      :19.7504
    :18.2762
       :17.9417
        :16.5955
         :16.2843
   :16.0047
	:15.7782	rejected
#:15.5882	rejected

:15.1619
  :14.4721
           :14.4347
          :14.3731
            :13.4474
 :13.0265
                :12.9254
             :12.5683
               :11.966
let:11.9345
 #:11.9299	rejected
              :11.8368

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:20.574
 #:17.5775	rejected
 (:17.3224
 if:16.5766
 case:16.1893
 List:16.0934	rejected
 (*:15.6376	prefix accepted: (
 ((:14.5464	prefix accepted: (
 remove:14.3998	rejected
 get:14.0124
 ([:13.9909	prefix accepted: (
 filter:13.986	rejected
 match:13.9355	rejected
 ?:13.7775	rejected
 begin:13.7095	rejected
 play:13.5971
 update:13.5148
 {:13.1969	rejected
 fail:13.1455	rejected
 fun:12.9002
 Play:12.8413

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:16.3867
 go:12.5223
 current:12.2313
 remove:12.1558
 xs:12.0631
 song:11.8266
 _,:11.7552	prefix accepted: _
 filter:11.2591
 filtered:11.2345
 rec:11.0957
 all:10.7775
 new:10.5311
 cur:10.5191
 s:10.2877
 _:11.7552
 Songs:9.99471	rejected
 ids:9.97168
 (:9.96138
 old:9.9397
 play:9.85476
 not:9.78357

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:19.5978
 =:16.5634
',:13.8425	rejected
_:13.6421
_,:13.637	prefix accepted:_
 ,:13.5688
1:12.7575
0:12.1432
::12.0418
2:11.993
':11.6568	rejected
 :11.564
=:11.3672
 ::11.354
To:10.9263
@:10.8963	rejected
In:10.7762
  :10.5128
 _,:10.3671	rejected
 :::10.1738
List:9.93878

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:18.4234
 state:17.3154
 _:15.5286
 old:12.2147
 playing:12.1318
 curr:12.0393
 play:11.7257
 song:11.7048
 s:11.7007
 p:11.4663
current:11.3068
 status:11.1828
 c:11.1013
 cur:11.0914
 :11.0518
 selected:10.9778
 x:10.8472
_:10.4012
 new:10.3604
 st:10.3063
 cs:10.259

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: ?, songs: ?, song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:20.4388
 :15.8802
_:15.7914
=:15.6162
State:15.5153
S:13.1667
 ->:12.908	rejected
Play:12.2907
  :11.7956
state:11.58
1:11.5581
Id:11.4681
':11.1064	rejected
 as:10.9962	rejected
::10.8523
,:10.7944
2:10.5564
 ==:10.4948	prefix accepted: =
0:10.2326
 state:10.2055	rejected
    :10.0328

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:19.3492
 :14.3587
 List:14.2078	rejected

:12.4931
 get:12.4771
 remove:12.3638	rejected
 filter:11.7724	rejected
play:11.6442
 (:11.591
 list:10.6525	rejected
 Play:10.4041
 f:9.94021
 delete:9.72102	rejected
 pal:9.44932	rejected
 Tu:9.40834	rejected
 songs:9.24799	rejected
 pl:9.21417
  :9.15064
 map:9.05798	rejected
 p:8.84496
 update:8.80997

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:21.6543
List:15.3312	rejected
l:13.0431
 list:12.582	rejected
ist:12.3559	rejected
lis:11.6847
_:11.6164	rejected
lst:11.5303	rejected
let:11.3885	rejected
ls:11.1482	rejected
lists:10.6937	rejected

:10.2178	rejected
lit:10.0173	rejected
.:9.79247	rejected
test:9.62696	rejected
 :9.32417	rejected
,:8.84761	rejected
lib:8.84083	rejected
st:8.69211	rejected
listen:8.67052	rejected
link:8.63062	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:19.6039
 :15.4236
,:14.1289

:13.9742
.:12.0722	rejected
  :11.8021
;:11.6622	rejected
 and:11.6545	rejected
in:10.7741
 ,:10.2184
    :9.98044
 where:9.73715	rejected
                :9.6454
	:9.6143	rejected
   :9.49873
 #:9.22948	rejected
      :9.1344
 |:8.697	rejected
 with:8.58643	rejected
 ?:8.5689	rejected
 ;:8.56452	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.4393
 :17.5938
  :15.1748
      :14.3225
    :14.1646
        :12.973
   :12.0314
     :12.0174
            :11.9755
                :11.8838
          :11.8512
         :11.7024
	:11.1361	rejected
       :10.973
 (:10.9179
              :10.8271
           :10.6297
 #:10.5964	rejected
 List:10.3373	rejected
 (*:10.1809	prefix accepted: (
             :10.0801

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :20.8025
      :17.6707
       :16.3229
    :16.2117

:15.716
         :15.1027
        :14.9494
	:14.0707	rejected
   :14.0322
#:13.9132	rejected
  :13.8354
 :13.6302
          :13.2195
           :13.0573
                :12.1342
(*:12.0871	prefix accepted:(
            :11.9124
             :11.4869
if:11.056
 #:10.8998	rejected
               :10.8439

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:19.85
 if:19.7511
 (:19.4559
 case:18.8944
 match:18.352	rejected
 #:17.9761	rejected
 ((:17.0762	prefix accepted: (
 (*:17.0365	prefix accepted: (
 List:16.8462	rejected
 ([:15.6673	prefix accepted: (
 Play:15.068
 remove:14.839	rejected
 songs:14.5119
 filter:14.4537	rejected
 {:14.2098	rejected
 print:13.78	rejected
 (!:13.5526	prefix accepted: (
 assert:13.484	rejected
 //:13.4653	rejected
 ~:13.2925	rejected
 list:13.161	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:13.804
 new:13.6381
 filtered:12.5979
 remaining:11.7912
 idx:11.5806
 is:11.4159
 index:11.3135
 updated:11.2996
 current:11.2564
 remove:11.103
 next:10.9713
 song:10.935
 xs:10.912
 go:10.8487
 rest:10.765
 state:10.6486
 filter:10.5835
 not:10.4584
 removed:10.4132
 no:10.2085
 update:10.1703

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new: ?, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
_:17.1184
S:14.9371
Play:14.4157
List:13.2853
Current:13.1964
State:13.1611
 =:12.7311
song:12.1567
list:11.9905
current:11.6688
play:11.5219
Id:11.1339
state:10.9439
P:9.73007
p:9.71399
Ids:9.60638
pl:9.56441
id:9.43757
 Songs:9.30504	rejected
lst:9.21549
Queue:9.20227

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_: ?, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new_
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
song:18.9192
current:17.9855
play:16.8801
state:16.2656
list:15.9878
pl:13.9101
queue:13.8659
id:13.751
curr:13.7343
p:13.5534
index:13.2078
selected:13.0239
cur:12.9665
set:12.8461
status:12.8396
ids:12.828
lst:12.6934
plays:12.586
states:12.5037
player:12.3098
s:12.2846

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_song: ?, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new_song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_song
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
s:20.8765
_:16.3926
 =:16.2128
,:14.0434
list:13.822
List:12.265
ss:11.7997
::11.7747
id:11.6112
set:11.3982
 :11.3901
=:11.3792
ids:11.351
sl:11.2442
es:11.0017
Ids:10.9022
 ::10.7516
  :10.4212
Id:10.378
z:10.2203
ls:10.1477

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: ?, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: new_songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:19.8852
,:16.4429
::15.7688
 :15.6813
=:14.5879
 ::14.3844
    :13.9595
  :13.8844
_:13.7724
     :13.0135
      :12.8477
   :12.518
1:11.8371
 :=:11.683	prefix accepted: :

:11.6664
 ,:11.2517
       :10.7105
        :10.669
 list:10.4394	rejected
0:10.3597
 :::10.2465

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:17.5247	rejected
 :15.2753

:14.4078
 filter:13.9047	rejected
 [:11.7789
 remove:11.6142	rejected
 (:11.5485
 songs:11.277
 list:11.1121	rejected
 if:10.8762
  :10.6965
 song:10.6072
 get:10.4221
 case:10.2824
 Filter:10.1182	rejected
 Play:9.95823
 f:9.8108
 []:9.80358
 fun:9.63373
 Song:9.58686	rejected
 Songs:9.34653	rejected
Rejected the highest logit candidate  List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.9551
 List:18.8847	rejected
 filter:15.0038	rejected
 [:13.6325
0:13.5047
 (:13.0575
1:13.0539
 songs:12.7648
 #:12.6396	rejected
 Filter:12.6127	rejected
	:12.5164	rejected
 song:12.4633
 list:12.4425	rejected
 remove:12.3727	rejected
 Play:12.1645
 Song:11.975	rejected
 if:11.9642
 case:11.8646
 f:11.8138
 get:11.6771
 (*:11.4962	prefix accepted: (

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :18.3414
         :15.6144
        :14.9965
      :14.8635
     :14.4911
	:13.6489	rejected
           :13.3299
          :12.421
            :11.6282
             :11.5808
                :11.448
   :10.9793
    :10.9626
               :10.7859
              :10.6484
 :10.6377

:10.4117
  :10.3139
#:10.1676	rejected
List:10.0395	rejected
if:9.43963

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:19.7922	rejected
 case:15.8171
 if:15.6013
 filter:14.952	rejected
 #:14.5205	rejected
 songs:14.1818
 let:13.5524
 match:13.5437	rejected
 (:13.4807
 fun:13.0464
 list:12.8136	rejected
 song:12.6227
 [:12.5932
 remove:12.4258	rejected
 get:12.3138
 f:12.1655
 (*:12.0088	prefix accepted: (
 Play:11.7798
 Filter:11.5069	rejected
 ((:11.3868	prefix accepted: (
 Song:11.2719	rejected
Rejected the highest logit candidate  List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 |:15.0341	rejected

:14.5504
 :14.4161
 -:13.7227
 @:13.5857
.:13.49	rejected
 \:12.2597
 #:11.977	rejected
 in:11.6655
 =:11.54
 --:11.4218	prefix accepted: -
 //:11.1852	prefix accepted: /
  :11.0104
 ->:10.9398	prefix accepted: -
@:10.8695
 filter:10.8204	rejected
 :=:10.6791	prefix accepted: :
|:10.5826	rejected
#:10.5227	rejected
 where:10.4403	rejected
 &&:10.2528
Rejected the highest logit candidate  | with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
       :19.8895
         :18.6801
        :16.7733
     :16.2598
           :15.7175
	:15.6422	rejected
      :15.3196
          :15.04
             :13.9515
                :13.7473
            :13.625
#:13.443	rejected
               :13.1708
    :12.8223
              :12.7606
   :12.6561

:12.4478
  :11.7232
 :11.3163
|:9.92124	rejected
 #:9.84729	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 |:18.1953	rejected
 #:17.0845	rejected
 @:14.2808
 -:13.7009
 //:13.1838	prefix accepted: /
 --:12.7139	prefix accepted: -
 (*:12.6655	prefix accepted: (
 &:12.4709
 ->:12.4626	prefix accepted: -
 \:12.4204
 /:13.1838
 ?:12.2713	rejected
 ~:12.1636	rejected
 List:11.738	rejected
 %:11.5349	rejected
 ||:11.4207	rejected
 .:11.3447	rejected
 +:11.3087
 >>:11.1716	prefix accepted: >
 <:10.9241
 *:10.8609
Rejected the highest logit candidate  | with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        -

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        -
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >-<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Subtraction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Integer Subtraction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: -
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: -
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 [:12.1255
 List:12.1179	rejected
 song:11.2799
 filter:10.9275	rejected
@:10.5486	rejected
 (:10.3962
<:10.2804	rejected
|:10.1778	rejected
 {:10.177	rejected
/:9.7071	rejected
*:9.65543	rejected
[:9.63474

:9.62391
 :9.1158
 if:9.10899
.:9.08615
>:9.03831	rejected
::9.01602	rejected
{:8.8629	rejected
 fun:8.85356
?:8.80603	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  ?
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  ?
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  ?
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:13.7651
 song:12.3031
if:11.0079
x:10.9935	rejected
fun:10.5136
 if:9.8877
filter:9.86355	rejected
i:9.45785
s:9.38839
List:9.28766	rejected

:9.24704
 x:8.88757	rejected
a:8.65213
 fun:8.57513
?:8.25491	rejected
id:8.196	rejected
|:8.07821	rejected
e:8.01645
get:8.01436
some:7.97296	rejected
remove:7.80954	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= completions | new-tokens

Top 20 Logits:
]:17.4752
 ->:12.4836	prefix accepted: -
,:11.4234
 |:11.1002	rejected
s:11.0698
:::10.9475
::10.6348
]):10.6335	prefix accepted:]
 ::10.4087
 =>:10.3317	prefix accepted: =
](:10.2344	prefix accepted:]
->:10.0584	prefix accepted:-
1:9.80848	rejected
;:9.71646	rejected
|:9.63419	rejected
 ||:9.62418	rejected
_:9.61334	rejected
']:9.57795	rejected
 \:9.55679
],:9.55659	prefix accepted:]
 as:9.5014	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song]

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:

:16.6877
 in:16.3485
 :16.0737
 #:14.6571	rejected
  :13.6317
 +:13.4511
 -:12.9953
 @:12.9675
 end:12.938	rejected
 (*:12.924	prefix accepted: (
 *:12.1247
 --:11.7719	prefix accepted: -
 |:11.6859	rejected
                :11.6802
 ->:11.5639	prefix accepted: -
 ++:11.4124
#:11.377	rejected
    :11.3239
 ~:11.2096	rejected
 //:11.1591	prefix accepted: /
        :10.9013

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:

:20.8327
 #:17.4301	rejected
 in:16.9909
 (*:15.9187	prefix accepted: (
	:13.2447	rejected
 +:13.2114
 -:13.1251
 --:12.9229	prefix accepted: -
 //:12.9134	prefix accepted: /
 *:12.84
 @:12.0264
 ~:11.9531	rejected
 <:11.5478
 (-:11.3114	prefix accepted: (
 ##:11.2046	rejected
 |:11.0975	rejected
 :::11.0397
 {-:10.9795	rejected
 end:10.9751	rejected
 /*:10.9006	prefix accepted: /
0:10.797	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
       :21.6074
     :21.0436
         :18.4002
      :17.8547
        :17.8542
	:16.214	rejected
#:16.1194	rejected

:15.9522
          :15.6667
           :15.6432
    :15.6217
in:15.2164
                :15.0776
   :14.9888
             :14.811
               :14.5883
            :14.375
              :14.0679
  :14.0407
(*:13.3998	prefix accepted:(
 :13.312

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Int; syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 -:15.3323
 |:15.0085	rejected
 #:14.8275	rejected
 +:14.7722
 @:14.2707
 in:13.7041
 (*:12.5909	prefix accepted: (
 --:12.5755	prefix accepted: -
 *:12.0743
 end:12.0559	rejected
 ~:11.9656	rejected
 /:11.8412
 &:11.5492
 ++:11.5041
 =:11.4273
 \:11.3984
 ?:11.1139	rejected
 >:11.0688
 <:10.8219
 ::10.8101
 ->:10.6233	prefix accepted: -

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        -

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        -
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >-<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Subtraction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Integer Subtraction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: -
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: -
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 [:14.4281
 get:13.3717
 List:13.1441	rejected
 (:12.5909
 []:12.5858
 if:12.5548
 case:11.9148
 [(:11.3577	prefix accepted: [
 filter:11.1672	rejected
 match:11.0856	rejected
[:10.696
 song:10.5255
 ((:10.3672	prefix accepted: (
 :10.2211
 f:10.0086
>:9.93508	rejected
 ?:9.67457	rejected
 @:9.56039	rejected
 ([:9.55565	prefix accepted: (
 songs:9.51732
 [-:9.44026	prefix accepted: [

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
case:15.8234
if:15.564
match:14.581	rejected
List:13.9463	rejected
get:13.8981
fun:13.0754
current:12.8968

:12.6363
let:11.6671
 case:11.5351
 if:11.4993
filter:10.9938	rejected
 match:10.3629	rejected
song:10.3236
#:10.2366	rejected
function:10.1807	rejected
f:10.0122
play:9.8691
 :9.771
Option:9.51448	rejected
():9.47793

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 song:16.374
 current:15.2997
 get:14.7792
 (:13.8046
 List:12.9891	rejected
 not:12.5133	rejected
 Some:12.2722	rejected
 is:11.224
 some:11.2169	rejected
(:10.5961
 Option:10.393	rejected
 :10.2879
 !:10.2828
 eq:10.2768	rejected
 ((:10.2644	prefix accepted: (
 Int:9.8976	rejected
 s:9.80279
 f:9.76842
 Song:9.71471	rejected
 None:9.65207	rejected
 Play:9.62568

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = (Var "Id")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Expecting type Bool but got inconsistent type Id  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 ==:20.3481
 =:15.5015
 <:15.1214
 !=:14.4651
==:14.3578
 >:13.8383
 <=:13.1913
 ===:13.152	prefix accepted: ==
 >=:12.9476
 in:12.806	rejected
 <>:12.3921	prefix accepted: <
=:12.0612
 is:11.6582	rejected
 :11.6565
 \:11.6125
 -:11.6043
 +:11.2819
.:11.2301	rejected
_:11.1478	rejected
 ->:11.0581	prefix accepted: -
 /:10.6791

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song ==

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 get:17.1973
 current:15.1482
 List:12.1217	rejected
 No:11.5394
 Play:11.3975
 :11.3592
 (:11.3497
 P:10.9956
 Id:10.4002	rejected
 Int:9.92553	rejected
 h:9.83493	rejected
 head:9.77639	rejected
 f:9.71355
 play:9.48347
 Option:9.27587	rejected
 ?:9.16097	rejected
current:8.95443
 no:8.91118	rejected
 s:8.78238
 None:8.62709	rejected
get:8.50858

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get
Nature of error: Variable get is not bound  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get
LSP: Generating Completions for prefix: get
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_songs" | "_state"
root ::= completions

Top 20 Logits:
_:19.401
S:10.4789	rejected
 state:10.0423	rejected
state:10.001	rejected
State:9.63512	rejected
(:9.598	rejected
Current:9.5674	rejected
Id:9.05406	rejected
.:8.95418	rejected
current:8.77041	rejected
 current:8.71795	rejected
Selected:8.59857	rejected
P:8.50639	rejected
Play:8.38322	rejected
No:8.15396	rejected
 id:8.09745	rejected
First:8.03077	rejected
List:7.82463	rejected
id:7.6909	rejected
New:7.66906	rejected
-:7.62392	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get_"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_
Nature of error: Variable get_ is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get_
LSP: Generating Completions for prefix: get_
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "songs" | "state"
root ::= completions

Top 20 Logits:
state:25.1727
current:19.3944	rejected
song:16.9181
play:16.6289	rejected
id:16.0619	rejected
first:15.7666	rejected
selected:15.3609	rejected
status:15.1814	rejected
last:14.4954	rejected
p:14.3754	rejected
sing:14.2459	rejected
State:14.2121	rejected
s:14.0649
curr:14.0579	rejected
next:13.9731	rejected
cur:13.8459	rejected
st:13.7098
stat:13.6468
start:13.205	rejected
player:13.1573	rejected
active:12.9396	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected)) -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id");
           syn = (Arrow ((Var "PlayList"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state
Nature of error: Expecting type Id but got inconsistent type (PlayList -> PlayListState)  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: get_state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: get_state
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
(:19.4297
 play:14.0059	rejected
 then:13.946
():12.931	prefix accepted:(
((:12.8551	prefix accepted:(
 (:11.8684
([:11.4606	prefix accepted:(
 current:11.3428	rejected

:10.3378
.:10.0302	rejected
({:9.86658	prefix accepted:(
 song:9.82934	rejected
(*:9.73502	prefix accepted:(
[:9.69209	rejected
.(:9.6147	rejected
(_:9.5805	rejected
(&:9.44265	prefix accepted:(
(...):9.32805	rejected
(@:9.26033	prefix accepted:(
 &&:9.24493
_:9.22103	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
play:22.3329
current:15.4632
pl:14.1385
p:13.5776
song:13.5169
Play:13.1415
new:12.9826	rejected
pal:12.2077	rejected
x:12.1343	rejected
player:11.7653	rejected
model:11.655	rejected
state:11.5772	rejected
self:11.5575	rejected
No:11.4597
plays:11.4567	rejected
 play:11.1811
List:11.1613	rejected
Current:10.8758	rejected

:10.841
action:10.8159
P:10.6044

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(play)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  play
Nature of error: Variable play is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:20.8999
List:14.4021	rejected
lists:12.8225	rejected
l:12.4859
let:12.4212	rejected
ist:12.2353	rejected
lis:12.0322
lst:11.7679	rejected
view:11.6068	rejected
):11.3299	rejected
 list:10.8086	rejected
ls:10.5857	rejected
li:10.5784
-:10.3904	rejected
_:10.2359	rejected
ly:10.1102	rejected
less:9.98079	rejected
link:9.88511	rejected
.:9.84742	rejected
el:9.66911	rejected
load:9.66534	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):19.6117
 then:12.8388	rejected
),:12.5079	prefix accepted:)
 ):12.1716
).:11.5736	rejected
)\:11.4808	prefix accepted:)
.:11.0532	rejected
)::10.8759	prefix accepted:)
);:10.8618	prefix accepted:)
)?:10.7313	prefix accepted:)
,:10.4755
)(:10.3615	prefix accepted:)

:10.3266
 &&:10.2443
)):10.1267
 &:10.0418
)/:10.0288	prefix accepted:)
)=:9.85341	prefix accepted:)
){:9.75258	prefix accepted:)
 :9.47791
 \:9.29919

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:19.1227
 :15.6135

:15.0755
 &&:14.3518
 \:11.595
  :11.5872
 ||:11.4652	rejected
 [:11.3088	rejected
 #:10.9614	rejected
then:10.9177
 and:10.7538	rejected
 &:10.3659
 ->:10.2784	prefix accepted: -
 (*:9.86776	prefix accepted: (
 //:9.8589	prefix accepted: /
 -:10.2784
 the:9.66399
 =:9.59684
 @:9.3848
 /:9.8589
 []:9.2752	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:16.1265

:15.0912
 :14.4729
 []:14.4571
 get:13.1954
 List:12.8949	rejected
 Some:12.6761	rejected
 [],:12.0813	prefix accepted: []
 current:11.8213
 (:11.7464
 song:11.6455
 [(:11.6084	prefix accepted: [
  :11.0468
 ?:10.9203	rejected
 songs:10.597
 some:10.559	rejected
 [-:10.5161	prefix accepted: [
 !:10.4828
 ([:10.4282	prefix accepted: (
 Song:10.4059	rejected
[:10.3637

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  ?
Nature of error: Expecting type Int but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  ?
Nature of error: Expecting type Int but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  ?
Nature of error: Expecting type Int but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
get:15.3858
song:14.3642
current:14.2149
0:13.662
1:13.0295
List:12.0906	rejected
P:11.6657
?:11.6571	rejected
hd:11.6426	rejected
Play:11.2184
head:10.9261	rejected
Int:10.6568	rejected
No:10.6487
f:10.0966
Id:9.9466	rejected
some:9.89437	rejected
@:9.87949	rejected
play:9.87401
Some:9.75899	rejected
first:9.74481	rejected
():9.5374

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get
Nature of error: Variable get is not bound  
Error in term:
  get
Nature of error: Expecting type Int but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get
LSP: Generating Completions for prefix: get
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_songs" | "_state"
root ::= completions

Top 20 Logits:
_:19.7327
State:12.8088	rejected
(:11.9769	rejected
 state:11.293	rejected
Current:11.2603	rejected
Id:11.2259	rejected
First:11.1897	rejected
state:10.4726	rejected
Next:10.4403	rejected
Play:10.2422	rejected
S:10.1825	rejected
P:9.56122	rejected
]:9.38845	rejected
-:9.31803	rejected
New:9.23803	rejected
():8.88729	rejected
.:8.88465	rejected
Index:8.70009	rejected
((:8.66271	rejected
current:8.57572	rejected
 current:8.55607	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get_"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_
Nature of error: Variable get_ is not bound  
Error in term:
  get_
Nature of error: Expecting type Int but got inconsistent type [?]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get_
LSP: Generating Completions for prefix: get_
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "songs" | "state"
root ::= completions

Top 20 Logits:
state:22.141
song:19.3573
current:18.9179	rejected
next:17.9122	rejected
first:17.4595	rejected
id:16.3118	rejected
sing:15.5685	rejected
selected:15.3421	rejected
play:15.2617	rejected
new:15.1412	rejected
last:14.7612	rejected
curr:14.5639	rejected
prev:14.4875	rejected
status:14.3889	rejected
p:14.3445	rejected
previous:14.3037	rejected
best:14.1967	rejected
most:14.0958	rejected
top:13.8969	rejected
states:13.7524	rejected
max:13.7355	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected)) -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state
Nature of error: Expecting type Int but got inconsistent type [(PlayList -> PlayListState)]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: get_state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: get_state
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
(:18.8362
():13.3882	prefix accepted:(
]:13.3589
((:13.1318	prefix accepted:(
([:11.7104	prefix accepted:(
 play:11.5457	rejected
(?:11.4515	prefix accepted:(
.:11.1018	rejected
[:11.0259	rejected
_:10.8029	rejected
 (:10.5325
.(:10.4997	rejected
]):10.0208	prefix accepted:]
(...:9.6659	rejected
::9.59683
 song:9.44014	rejected
({:9.4146	prefix accepted:(
(*:9.27794	prefix accepted:(
(\:9.22971	prefix accepted:(
(_:9.21312	rejected
!(:9.19392	prefix accepted:!

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(?)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(?)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(?)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
play:19.8174
current:14.9902
Play:13.5379
song:13.1828
pl:12.9681
p:12.8997
new:12.3184	rejected
No:12.2436
pal:12.0301	rejected
next:11.7128	rejected
List:11.5342	rejected
plays:11.25	rejected
x:11.1741	rejected
player:11.0625	rejected
get:10.955
P:10.9283

:10.7102
Current:10.3647	rejected
ps:10.3312	rejected
remove:10.2313	rejected
no:10.2152	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(play)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:21.3022
List:14.2577	rejected
l:13.5462
let:13.2856	rejected
lst:13.0629	rejected
ist:12.6631	rejected
lists:12.3517	rejected
lit:11.1663	rejected
ls:11.1538	rejected
 list:11.086	rejected
#:10.9938	rejected
light:10.8834	rejected
lib:10.5886	rejected
ling:10.5689	rejected
link:10.4999	rejected
ll:10.4614	rejected
lis:10.2687
_:10.2562	rejected
play:10.1613	rejected
load:10.1334	rejected
line:10.0504	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
)]:19.7219	prefix accepted:)
):19.7219
),:13.1756	prefix accepted:)
).:12.2591	rejected
))]:12.0068	prefix accepted:))
)];:11.2698	prefix accepted:)
)!:10.9094	prefix accepted:)
)::10.888	prefix accepted:)
)](:10.8061	prefix accepted:)
)[:10.6667	prefix accepted:)
)):12.0068
.:10.4028	rejected
)-:10.0224	prefix accepted:)
);:9.92679	prefix accepted:)
()):9.58812	prefix accepted:(
)|:9.55535	prefix accepted:)
)+:9.53955	prefix accepted:)
 ):9.40817
)\:9.3879	prefix accepted:)
]):9.3684	rejected
)(:9.35765	prefix accepted:)
Rejected the highest logit candidate )] with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
]):17.9116	prefix accepted:]
],:16.6952	prefix accepted:]
].:14.1363	rejected
 ]:13.9769
 +:13.9569
 -:13.7663
 ::12.5919
:::12.4679
 else:12.454	rejected
 ->:12.3634	prefix accepted: -
][:11.7437	prefix accepted:]
 @:11.5638
 :::11.4479
 =:11.3728

:11.3687
 |:10.985	rejected
 :10.9214
 \:10.8992
 /:10.6786
 as:10.6727	rejected
@:10.6268
Rejected the highest logit candidate ]) with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)]

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)]
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [(Playing(Int) + PausedOn(Int) + NoSongSelected)]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Int; syn = (List (Var "PlayListState"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:19.5376

:13.8173
 :13.7071
 []:12.8934	rejected
 end:12.4248	rejected
 \:11.8062
else:10.6835
 elif:10.4877	rejected
  :10.339
 [:10.2925	rejected
 els:10.1008
 otherwise:9.98365	rejected
 el:9.97048
 @:9.93952
 #:9.89498	rejected
 ):9.88894	rejected
[]:9.75729	rejected
 ::9.14305
 in:8.74128	rejected
 ?:8.68645	rejected
?:8.68069	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:18.8781
 []:16.9315
 [],:13.4965	prefix accepted: []
 :12.9591
[]):12.6485	prefix accepted:[]

:12.4144
 (:11.4553
 List:11.0324	rejected
 ?:10.7105	rejected
 \:10.5815	rejected
):10.5574	rejected
 [-:10.5101	prefix accepted: [
 nil:10.2793	rejected
 {:10.2505	rejected
 ([:10.0331	prefix accepted: (
 ):9.94231	rejected
  :9.90005
 _):9.65839	rejected
 None:9.65522	rejected
 !:9.47612
 [];:9.3985	prefix accepted: []

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in end in
  LSP: Info: ALL errors:
Error in term:
  ?
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in end in
  LSP: Info: ALL errors:
Error in term:
  ?
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) in end in
  LSP: Info: ALL errors:
Error in term:
  ?
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
]):21.1824	prefix accepted:]
?:13.2547	rejected
song:12.8941
0:12.2856
[]:11.9296
 :11.6234
Int:11.5859	rejected
():10.268
get:10.1944
 ]:10.1837	rejected
@:10.1298	rejected
][:9.92727	prefix accepted:]
current:9.84171
](:9.73871	prefix accepted:]
1:9.66815
None:9.53081	rejected
||:9.50664	rejected
  :9.42264
No:9.22509
Id:9.22248	rejected
none:9.14792	rejected
Rejected the highest logit candidate ]) with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else []

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else []
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Int; syn = (List (Unknown Internal))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: If expression
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 end:15.6614	rejected
 ):15.0725

:12.0016
 :11.446
 in:11.2243	rejected
 ::11.1729
)::11.0951	prefix accepted:)
)\:10.3529	prefix accepted:)
:::9.58555
end:9.5751	rejected
()):9.4627	prefix accepted:(
 |:9.4108	rejected
  :9.17706
 fi:9.01311	rejected
)$:8.70633	prefix accepted:)
 :::8.62617
 if:8.47196	rejected
 @:8.43331
 (*:8.34264	prefix accepted: (
 (:8.34264
 ?:8.02519	rejected
Rejected the highest logit candidate  end with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:17.0917

:16.5967
in:16.591
 :15.9714
  :14.6134
 end:13.0873	rejected
   :12.6543
 -:12.1881
    :12.0946
      :11.597
 #:11.3459	rejected
end:11.25	rejected
        :11.1796
 |:11.023	rejected
                :10.4445
     :10.3513
         :10.2569
[:10.1228	rejected
       :9.94068
?:9.91471	rejected
 []:9.90755	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
     :18.4082
       :16.9843
      :15.9861
         :14.8012
        :14.6682
   :14.6277
                :14.2432
    :13.9016

:13.3197
           :12.9345
in:12.7962
          :12.6638
	:12.5924	rejected
               :12.5406
            :12.3729
  :12.3325
#:12.2061	rejected
             :12.1713
              :11.9644
 :11.9348
 in:10.8855

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:17.6785
 if:14.3563	rejected
 and:14.0894	rejected
 |:13.7174	rejected
 #:13.1399	rejected
 end:12.8138	rejected
 match:12.4254	rejected
 List:12.3287	rejected
 (*:11.9378	prefix accepted: (
 (:11.9378
 let:11.3247	rejected
 -:11.2166
 ~:11.1559	rejected
 val:11.1199	rejected
 ():10.9235	prefix accepted: (
 {:10.6293	rejected
 @:10.5311
 case:10.4857	rejected
 fun:10.2124	rejected
 new:10.0513	rejected
 ;:10.0257	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.7695
 :16.4228
  :15.3402
 (:14.6852
 if:14.1627
    :13.859
   :13.6824
      :13.5641
        :12.7153
                :12.6616
 case:12.6
 new:12.5201
 List:12.2978	rejected
 (*:12.0108	prefix accepted: (
     :11.8975
            :11.8818
          :11.8259
         :11.483
	:11.3876	rejected
 ((:11.3647	prefix accepted: (
 #:11.3278	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :20.6764
      :18.3791
       :17.4619
    :16.9575
   :16.5071
        :16.1419

:15.9334
         :15.7587
  :14.2225
	:14.0116	rejected
          :13.6582
           :13.6549
#:13.3816	rejected
 :12.7005
            :12.5575
                :12.4314
             :11.8998
(*:11.5941	prefix accepted:(
               :11.4669
              :11.1273
(:11.5941

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:21.5974
 case:19.9433
 (:19.6129
 let:18.5595
 match:18.1462	rejected
 #:17.5085	rejected
 (*:17.1101	prefix accepted: (
 ([:17.0809	prefix accepted: (
 List:16.2281	rejected
 new:16.1401
 ((:16.064	prefix accepted: (
 Play:13.9322
 begin:13.8992	rejected
 get:13.8422
 current:13.7275
 assert:13.6972	rejected
 update:13.585
 print:13.5698	rejected
 {:13.5318	rejected
 [:13.4061
 (!:13.3297	prefix accepted: (

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:16.6655	rejected
 new:14.5163
 current:14.196
 (:13.7205
 not:13.3964	rejected
 song:13.0539
 get:12.7544
 songs:11.5593
 is:11.2764
 Play:11.0937
 :10.7457
 Song:10.6897	rejected
 !:10.6196
 Songs:10.4898	rejected
 ((:10.2601	prefix accepted: (
 Int:10.0437	rejected
 length:10.0261	rejected
 list:9.91171	rejected
(:9.60751
 len:9.35831	rejected
 [:9.28215
Rejected the highest logit candidate  List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
List:16.4598	rejected
current:16.299
new:15.4379
not:13.3812	rejected
get:13.1622
song:12.6322
Play:11.2935
 List:10.5047	rejected
Int:10.486	rejected
length:10.4508	rejected
is:10.1155
size:10.0617	rejected
len:9.82345	rejected
0:9.82102
S:9.73971	rejected
play:9.62439
 current:9.35662
int:9.17744
New:9.11118	rejected
f:9.0613
list:8.97294	rejected
Rejected the highest logit candidate List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  current
Nature of error: Expecting type Bool but got inconsistent type PlayListState  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ==:18.9221
 !=:17.2615
 =:15.3431
 <>:14.0651	prefix accepted: <
==:13.7101
 <:14.0651
 >:13.3403
 :::12.7779
 >=:12.6128
 \:12.6068
,:12.2286
):12.1975
 :12.0622
 ===:12.0117	prefix accepted: ==
=:11.7354
.:11.5801	rejected
::11.5316
:::11.5222
 as:11.5018	rejected
 ~:11.4771	rejected
 is:11.4545	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current !=

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current !=
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >!=<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Inequality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Integer Inequality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: !=
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: !=
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 No:18.1654
 P:15.7244
 Play:14.0761
 song:12.552
 get:11.7253
 current:11.7105
 None:11.4015	rejected
 Remove:11.2453
 :11.0702
 (:11.0437
 Song:10.8659	rejected
No:10.7065
 Get:10.4733	rejected
 no:10.2922	rejected
 Rem:9.49367
 null:9.44937	rejected
 N:9.11879
 Not:9.10309	rejected
 playing:8.98887	rejected
 NO:8.95499	rejected
song:8.886

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != No

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != No
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  No
Nature of error: Constructor is not defined  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:23.1301
Selected:12.4875	rejected
State:12.4277	rejected
Current:12.2068	rejected
 Song:11.7135	rejected
_:11.3947	rejected
P:11.1755	rejected
Sing:11.0455	rejected
Play:10.9212	rejected
Selection:10.7397	rejected
SON:10.6479	rejected
Sound:10.4123	rejected
SS:10.0117	rejected
 song:9.91277	rejected
song:9.57346	rejected
Sh:9.33819	rejected
C:9.27436	rejected
New:9.23729	rejected
Session:9.21591	rejected
Empty:9.19034	rejected
M:9.17478	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  NoS
Nature of error: Constructor is not defined  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:24.3722
ongs:12.5622	rejected
on:11.9421
ung:11.7037	rejected
ame:11.1773	rejected
oon:10.8941	rejected
song:10.8816	rejected
one:10.2327	rejected
ug:10.169	rejected
ng:10.1642	rejected
ig:10.0298	rejected
ugg:10.0024	rejected
om:9.86943	rejected
oup:9.72591	rejected
uch:9.68213	rejected
aved:9.63853	rejected
 song:9.59154	rejected
n:9.49568	rejected
 Song:9.42332	rejected
ure:9.38239	rejected
ue:9.30075	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  NoSong
Nature of error: Constructor is not defined  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:23.3167
Selection:15.5229	rejected
Select:15.293
Current:14.5208	rejected
selected:13.999	rejected
Se:12.9029
SELECT:12.651	rejected
Play:12.5354	rejected
S:12.5048
):12.0804	rejected
Selector:11.6612	rejected
Start:11.2395	rejected
Available:11.2119	rejected
 selected:11.0487	rejected
State:10.9547	rejected
 &&:10.858	rejected
 Selected:10.8397	rejected
Is:10.3385	rejected
Id:10.0927	rejected
P:9.9435	rejected
Status:9.88278	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 &&:17.1823
):16.606
 \:15.8186
 /\:13.9535	prefix accepted: /
 ||:13.5121	rejected
 and:12.5672	rejected
 :12.1512
 ):12.1314

:12.0037
)\:11.347	prefix accepted:)
 &:10.982
 /:13.9535
,:10.2294
 or:9.85245	rejected
 ^:9.75618	rejected
 ?:9.42261	rejected
)?:9.18279	prefix accepted:)
 AND:9.17496	rejected
 |:9.11716	rejected
)/:8.88082	prefix accepted:)
),:8.85164	prefix accepted:)

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected &&

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected &&
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >&&<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Boolean Conjunction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Boolean Conjunction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: &&
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: &&
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:15.5076	rejected
 current:15.3736
 not:13.8736	rejected
 song:13.5036
 new:13.2538
 get:13.1261
 (:12.6032
 !:12.55
 :11.9927
 length:11.6717	rejected

:11.3646
 is:10.3498
 songs:10.3419
 ((:9.93135	prefix accepted: (
 \:9.87196	rejected
 list:9.6329	rejected
 Int:9.48516	rejected
 Song:9.43666	rejected
 (!:9.33836	prefix accepted: (
 f:9.26944
 Some:9.21183	rejected
Rejected the highest logit candidate  List with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  current
Nature of error: Expecting type Bool but got inconsistent type PlayListState  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ==:17.3959
 !=:17.0704
 =:14.5851
.:14.3236	rejected
 <>:14.2141	prefix accepted: <
 <:14.2141
 \:12.7956
 >:12.7955
 as:12.5337	rejected
==:12.5205
!=:12.507
 ->:12.4685	prefix accepted: -
 ~:12.3136	rejected
 <=:12.1257
 >=:12.0912
 -:12.4685
 /:11.6667
 !:11.6404
 +:11.5331
 !==:11.4617	prefix accepted: !=
 :11.4242

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current ==

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 P:18.0046
 Play:16.8205
 song:16.1543
 Remove:14.2586
 Some:12.8624	rejected
 (:12.5501
 get:12.2233
 Rem:12.0238
 current:11.5372
 Get:11.0635	rejected
 play:11.0501
 Song:11.0236	rejected
 :10.8762
song:10.2965
 remove:10.2057	rejected
 None:10.0354	rejected
 removed:9.96937	rejected
 some:9.71334	rejected
 @:9.65368	rejected
Play:9.40958
 playing:9.40675	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  Play
Nature of error: Constructor is not defined  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song" | "ing"
root ::= completions

Top 20 Logits:
ing:23.3801
S:16.2286
(:13.4143	rejected
List:13.2885	rejected
ed:13.0089	rejected
On:12.9509	rejected
ling:12.7257	rejected
P:12.2843	rejected
in:12.0121
ng:11.5284	rejected
list:11.3003	rejected
):11.2016	rejected
Sing:11.1386	rejected
State:10.9561	rejected
i:10.9301
ong:10.8686	rejected
ings:10.7615	rejected
ning:10.6447	rejected
eing:10.4902	rejected
Play:10.3695	rejected
ting:10.2994	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Int -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:19.5724
 song:14.787	rejected
()):12.4679	prefix accepted:(
 (:11.8856
):11.8752
(_:11.624	rejected
((:11.4099	prefix accepted:(
([:10.4045	prefix accepted:(
(-:10.3901	prefix accepted:(
():10.3058	prefix accepted:(
 current:9.85516	rejected
(":9.55057	prefix accepted:(
({:9.49115	prefix accepted:(
 &&:9.41389
(`:9.24752	prefix accepted:(
)(:9.20926	prefix accepted:)
(?:9.13102	prefix accepted:(
(*:9.08271	prefix accepted:(
[:9.05335	rejected
(!:8.98875	prefix accepted:(
 songs:8.96031	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:20.8652
get:14.8558
current:14.0379
0:13.2516
new:13.0975
 song:12.6857
remove:12.1623	rejected
1:11.9851
S:11.6107	rejected
sing:11.4668	rejected
id:11.4382	rejected
P:11.118
some:11.1165	rejected
sound:11.0389	rejected
next:10.8315	rejected
play:10.7919
Some:10.5401	rejected
p:10.4796
Get:10.4121	rejected
old:10.3973	rejected
Play:10.3634

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
)):21.598
):16.915
))\:14.6821	prefix accepted:))
)\:13.1022	prefix accepted:)
))):12.6749	prefix accepted:))
s:12.5649
)){:11.9741	prefix accepted:))
)),:11.4565	prefix accepted:))
),:11.4477	prefix accepted:)
 :10.9298
 \:10.7925
,:10.7484
))::10.6441	prefix accepted:))
)).:10.6314	prefix accepted:)
 ||:10.3985	rejected
::9.87545
.:9.7975	rejected
));:9.66813	prefix accepted:))
 +:9.6573
 ):9.56431
)))):9.55491	prefix accepted:))

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song))

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:18.0778
 ||:16.316	rejected

:15.8719
 :15.5574
 \:13.148
then:12.871
  :12.8467
 &&:12.3632
 or:11.3984	rejected
 {:11.3652	rejected
 #:11.3177	rejected
||:10.9709	rejected
   :10.5794
 //:10.3943	prefix accepted: /
    :10.2566
 |:10.2312	rejected
 ?:9.91452	rejected
 (*:9.84502	prefix accepted: (
      :9.81253
                :9.4164
 ->:9.39466	prefix accepted: -

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.4276
 :16.9608
  :15.3006
 (:14.7811
      :13.8386
 #:13.6177	rejected
    :13.606
   :13.4436
        :13.4219
 P:12.8704
 ():12.6941
         :12.4609
 (*:12.3617	prefix accepted: (
 new:12.358
 current:12.3244
 {:12.3028	rejected
 play:12.064
                :12.0598
            :12.0162
     :11.7875
 begin:11.7461	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :21.2434
        :18.8952
         :18.7151
      :18.2316
     :15.8459
          :15.6946
	:15.6492	rejected
           :15.5283

:14.0825
            :14.0564
             :13.9397
    :13.6571
   :13.6165
                :13.344
               :13.2122
#:13.1794	rejected
  :12.9601
              :12.9113
 :11.9649
(*:11.2144	prefix accepted:(
(:11.2144

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:19.877
 let:18.3876
 new:18.3512
 ([:17.7571	prefix accepted: (
 match:17.1951	rejected
 #:17.1937	rejected
 case:17.1211
 (*:17.0038	prefix accepted: (
 if:16.7703
 List:16.6209	rejected
 ((:15.2215	prefix accepted: (
 play:14.142
 ?:13.8436	rejected
 P:13.599
 update:13.5156
 [:13.4862
 add:13.3264	rejected
 {:13.3037	rejected
 get:13.2965
 ():13.1367
 (?:13.0855	prefix accepted: (

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
new:19.8917
List:14.1531	rejected
song:14.0164
 new:13.584
current:12.3
get:11.9646
if:11.9232

:11.5849
Play:10.9535
play:10.8818
remove:10.84	rejected
let:10.7994
[]:10.7769
match:10.1928	rejected
set:10.0534	rejected
P:9.8458
0:9.80102
case:9.70363
first:9.6612	rejected
filter:9.64815	rejected
([:9.51011	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new"))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new
Nature of error: Variable new is not bound  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new
LSP: Generating Completions for prefix: new
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_songs"
root ::= completions

Top 20 Logits:
_:21.0515
S:12.9062	rejected
song:11.5442	rejected
 songs:11.4572	rejected
-:11.3661	rejected
 Songs:10.4143	rejected
Play:9.73611	rejected
.:9.68193	rejected
List:9.57184	rejected
,:9.47297	rejected
 _:8.84838	rejected
 new:8.57047	rejected
__:8.53624	rejected
 song:8.11784	rejected
est:7.86082	rejected
(:7.80176	rejected
 (:7.60546	rejected
 play:7.58159	rejected
 Song:7.41971	rejected
\_:7.2392	rejected
State:7.1441	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_"))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_
Nature of error: Variable new_ is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_
LSP: Generating Completions for prefix: new_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "songs"
root ::= completions

Top 20 Logits:
song:19.0066
s:14.2424
son:11.5243
 songs:11.4481	rejected
samples:11.431	rejected
images:11.2253	rejected
sound:11.2089	rejected
scripts:10.7031	rejected
sing:10.6187	rejected
words:10.542	rejected
sun:10.4278	rejected
music:10.4034	rejected
sent:10.3541	rejected
messages:10.2332	rejected
play:10.1666	rejected
strings:10.1465	rejected
ships:10.1224	rejected
names:10.0803	rejected
seconds:10.0777	rejected
files:9.93472	rejected
year:9.90262	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_song"))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  new_song
Nature of error: Variable new_song is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_song
LSP: Generating Completions for prefix: new_song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:23.5447
,:14.1207	rejected
 =:11.643	rejected
es:11.0608	rejected
S:10.7001	rejected
_:10.5231	rejected
song:10.3224	rejected
ss:9.45187	rejected
=:9.28695	rejected
):9.15031	rejected
sh:9.13738	rejected
.:9.10717	rejected
[:9.08638	rejected
 :9.01394	rejected
(:8.83651	rejected
 ,:8.78495	rejected
is:8.75505	rejected
(),:8.74213	rejected
ls:8.54338	rejected
as:8.47837	rejected
 songs:8.32845	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = (Var "PlayList"); syn = Int})))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type PlayList but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: new_songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.8664
 @:15.7066
 ,:14.7759
 +:13.029
 -:12.73
 ++:12.1737
@:11.5497
,[:11.5245	prefix accepted:,
 |:11.4209	rejected

:10.6832
.:10.4724	rejected
 :10.2653
[:10.2304	rejected
 [],:10.135	rejected
::10.1312
 ::10.0832
 --:10.0317	prefix accepted: -
 \:9.85148
,(:9.83419	prefix accepted:,
,,:9.58778	prefix accepted:,
 [:9.57447	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: (?, (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: (?, (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 P:16.7021
 No:15.6507
 Play:12.8964
 get:12.2972
 if:11.9711
 current:11.9521
 :11.038
 (:10.7658
No:10.5787
 play:10.2214

:10.1751
P:10.1349
 no:9.99637	rejected
 List:9.66834	rejected
 next:9.19668	rejected
 paused:9.14076	rejected
 song:9.05595
 remove:8.96887	rejected
 songs:8.88574
 Current:8.8195	rejected
 None:8.7899	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, No

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, No
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  No
Nature of error: Constructor is not defined  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:21.6807
State:13.3618	rejected
Current:13.1037	rejected
Play:12.1498	rejected
Selected:11.5564	rejected
_:11.5089	rejected
Sound:11.194	rejected
Selection:11.1248	rejected
 Song:10.7677	rejected
P:10.7499	rejected
SON:10.3964	rejected
C:10.2528	rejected
Sing:10.0626	rejected
Action:9.8466	rejected
New:9.83274	rejected
Se:9.80299	rejected
Sh:9.65773	rejected
 song:9.51638	rejected
M:9.49327	rejected
Next:9.3021	rejected
Player:9.22102	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  NoS
Nature of error: Constructor is not defined  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:22.656
on:15.5457
ongs:13.777	rejected
ung:12.3213	rejected
oup:12.2221	rejected
ony:11.2639	rejected
song:11.2583	rejected
onic:10.77	rejected
one:10.6887	rejected
ng:10.6613	rejected
ons:10.5877	rejected
ond:10.5562	rejected
oon:10.3509	rejected
ound:10.2115	rejected
now:10.1693	rejected
pon:10.1466	rejected
ongo:10.1202	rejected
onn:10.1128	rejected
son:9.97077	rejected
om:9.834	rejected
 song:9.7777	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoSong
Nature of error: Constructor is not defined  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:22.542
Select:15.745
Se:15.141
selected:15.0844	rejected
Selection:13.8114	rejected
S:13.7228
Play:13.0829	rejected
Selector:13.0072	rejected
P:12.6961	rejected
):12.6632	rejected
Current:12.5913	rejected
SELECT:12.5886	rejected
Available:11.8881	rejected
State:11.7942	rejected
 Selected:11.6048	rejected
(:11.2075	rejected
Updated:10.9401	rejected
Sec:10.9013	rejected
()):10.8597	rejected
Pressed:10.836	rejected
Set:10.8036	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):19.8436
 ):15.2185
 @:13.4951
);:13.4339	prefix accepted:)
),:12.6895	prefix accepted:)
:::12.5213
,:12.3357
 :::11.9288

:11.7025
 :11.6747
()):11.4316	prefix accepted:(
)\:11.3583	prefix accepted:)
 +:11.1979
 \:11.0582
(*:11.036	prefix accepted:(
@:10.8374
 (*:10.5889	prefix accepted: (
 ::10.4036
)::10.3237	prefix accepted:)
::10.1675
  :10.0922

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:20.5726
 :17.6668
  :16.9877
 #:16.0063	rejected
    :15.4892
 (*:15.3751	prefix accepted: (
   :15.3047
        :15.2418
      :14.4257
 @:13.6613
                :13.6388
          :13.0732
 :::13.0367
         :12.9212
     :12.8438
            :12.7133
       :12.6059
              :12.4222
:::12.3506
           :12.3202
	:12.319	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
     :22.0426
      :17.231
       :16.1176
   :15.8777
    :15.708
        :15.1556

:14.8709
         :14.3963
#:13.9511	rejected
          :13.9142
	:13.7666	rejected
 :13.4696
           :13.405
                :13.0808
  :13.0614
            :12.7972
(*:12.1418	prefix accepted:(
              :11.9865
             :11.9859
else:11.7968
               :11.5133

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:22.2975
 elif:20.0105	rejected
 #:18.51	rejected
 els:17.14
 (*:15.6658	prefix accepted: (
 if:14.4656	rejected
 end:14.2538	rejected
 el:13.6036
 (:15.6658
 ##:12.6498	rejected
 {:12.4785	rejected
 //:12.1423	prefix accepted: /
 ((:12.0245	prefix accepted: (
 Else:11.916	rejected
 |:11.7966	rejected
 ELSE:11.7266	rejected
 #(:11.687	rejected
 --:11.6391	prefix accepted: -
 *:11.5437
 otherwise:11.3652	rejected
 \:11.3379

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.2224
 :19.0175
 if:17.7531
 (:16.655
  :15.4144
    :14.4293
   :13.9629
        :13.498
      :13.2361
 current:12.9811
 match:12.7412	rejected
 new:12.6278
 ((:12.5986	prefix accepted: (
                :12.1804
 play:12.0236
(:11.8335
            :11.7882
 (*:11.7481	prefix accepted: (
     :11.6815
         :11.5898
 case:11.5771

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :23.3733
      :20.5712
        :19.8906
         :18.2788
     :18.2637
	:16.3832	rejected
   :15.78
    :15.5608
          :15.2584
           :14.7427

:14.5848
 :14.3724
  :14.2886
#:13.8598	rejected
            :13.3754
             :12.9812
                :12.6821
              :12.6717
               :12.4732
(:12.1349
(*:11.9465	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:21.9642
 let:18.65
 match:17.9225	rejected
 case:17.8066
 new:17.1177
 if:16.6454
 ((:16.616	prefix accepted: (
 #:16.4723	rejected
 List:16.2786	rejected
 ([:16.2442	prefix accepted: (
 (*:15.815	prefix accepted: (
 play:14.5481
 current:14.537
 begin:14.4519	rejected
 get:13.6097
 ?:13.5363	rejected
 [:13.362
 #(:13.2273	rejected
 update:12.9101
 @:12.8484	rejected
 {:12.8056	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
new:20.0106
song:14.6932
if:14.4152
 new:14.2298
List:14.2093	rejected

:12.3593
current:12.199
get:11.8056
remove:11.6735	rejected
case:11.6173
play:11.478
match:11.2062	rejected
let:10.8284
Play:10.5995
filter:10.3681	rejected
n:10.2857
set:10.0359	rejected
 songs:9.96692
news:9.78957	rejected
 :9.78028
list:9.63148	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new"))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new
Nature of error: Variable new is not bound  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new
LSP: Generating Completions for prefix: new
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_songs"
root ::= completions

Top 20 Logits:
_:19.8899
Play:9.81319	rejected
-:9.46809	rejected
S:9.45857	rejected
 _:9.26847	rejected
s:8.99657	rejected
 play:8.78182	rejected
_,:8.70115	prefix accepted:_
,:8.56989	rejected
 songs:8.49591	rejected
 song:8.46458	rejected
 Songs:8.38387	rejected
song:8.2372	rejected
_):7.60798	prefix accepted:_
\_:7.47492	rejected
List:7.40368	rejected
 :7.27753	rejected
 list:7.20658	rejected
.:7.15215	rejected
 Play:7.06352	rejected
 m:6.94138	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_"))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  new_
Nature of error: Variable new_ is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_
LSP: Generating Completions for prefix: new_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "songs"
root ::= completions

Top 20 Logits:
song:25.405
s:17.3381
sound:15.8878	rejected
son:15.7129
story:15.2331	rejected
news:14.5311	rejected
sl:13.9737	rejected
scripts:13.8424	rejected
stud:13.8365	rejected
lang:13.6573	rejected
 songs:13.5407	rejected
sk:13.517	rejected
list:13.29	rejected
sun:13.2127	rejected
id:13.1532	rejected
school:13.0789	rejected
stream:13.0315	rejected
screen:13.0195	rejected
book:12.9246	rejected
books:12.8997	rejected
play:12.8478	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "new_song"))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_song
Nature of error: Variable new_song is not bound  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: new_song
LSP: Generating Completions for prefix: new_song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:25.5727
S:13.9723	rejected
,:13.1969	rejected
es:12.6903	rejected
):12.2889	rejected
(:11.5053	rejected
os:10.5533	rejected
n:10.274	rejected
 =:9.95372	rejected
=:9.90377	rejected
 :9.65082	rejected
::9.0702	rejected
song:8.98776	rejected
 -:8.98637	rejected
),:8.83785	rejected
_:8.70011	rejected
);:8.61905	rejected
.:8.41564	rejected
;:8.2951	rejected
 Songs:8.2204	rejected
-:8.19818	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <new_songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = (Var "PlayList"); syn = Int})))
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type PlayList but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: new_songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: new_songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.1685
 ,:15.2572
 @:13.2225
 -:12.1681
 +:11.3646

:11.2741
 :10.9306
@:10.8562
):10.6032
 ++:10.3567
,(:10.2959	prefix accepted:,
 current:10.0738	rejected
.:10.059	rejected
 --:10.0502	prefix accepted: -
 |:9.75405	rejected
::9.53635
,,:9.52179	prefix accepted:,
),:9.22481	prefix accepted:)
,\:9.14145	prefix accepted:,
 \:9.11961
 ::8.99418

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: (?, (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: (?, (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "new_songs" | "pi" | "playlist" | "sin" | "song" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 current:17.746
 P:15.6611
 get:14.3531
 No:12.701
 Play:12.5969
 :12.5336
 if:12.0116
current:11.6331
 (:11.487
 play:11.0354

:10.5768
 song:10.3643
 match:10.3372	rejected
 state:10.1541	rejected
 List:10.0274	rejected
 Current:9.97682	rejected
 None:9.75566	rejected
 {:9.6752	rejected
 Get:9.67213	rejected
 Song:9.16614	rejected
 new:9.15875

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: new_songs current songs song action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):19.7969
 -:16.0857
 ):13.6847
 end:13.5514	rejected
);:12.3572	prefix accepted:)
)\:12.3364	prefix accepted:)
),:12.3251	prefix accepted:)
 :12.0904

:11.8732
 \:11.4981
 @:11.3506
 +:11.168
 |:10.8941	rejected
 =:10.8229
-:10.6158
 ||:10.5069	rejected
)):10.4429
 ::10.3304
)::10.0816	prefix accepted:)
 *:9.85239
)]:9.83703	prefix accepted:)

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current)

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current)
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :19.6562

:19.6101
  :17.0237
 end:16.8316
        :15.7858
      :15.7722
   :15.673
    :15.5513
 in:14.091	rejected
         :13.9019
 #:13.897	rejected
                :13.8762
          :13.6703
       :13.5041
     :13.4698
            :13.2038
 (*:13.1084	prefix accepted: (
           :12.7507
	:12.5233	rejected
              :12.4241
             :12.3251

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:22.4063
 end:17.3962
 #:16.1234	rejected
 in:15.2347	rejected
	:15.0264	rejected
 (*:14.8339	prefix accepted: (
 @:13.7467
0:13.201	rejected
 *:13.0325
1:12.5612	rejected
 -:11.9906
 //:11.7901	prefix accepted: /
 \:11.5744
 |:11.5242
 ##:11.3207	rejected
2:11.2188	rejected
 ###:10.9891	rejected
 (**:10.8309	prefix accepted: (
 and:10.6882	rejected
 /:11.7901
 +:10.5881

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :20.4522
    :15.2368

:14.6986
  :14.6606
        :14.067
      :13.6264
end:13.6137
     :13.5245
#:13.314	rejected
 :13.2157
       :12.3678
in:12.1201	rejected
         :11.8584
          :11.5797
            :11.5626
(*:11.5259	prefix accepted:(
	:11.3545	rejected
                :11.3158
           :10.5992
 #:9.90227	rejected
             :9.87672

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
   

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
   
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {new_songs: Int, current: PlayListState, songs: [Id], song: Id, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.371
 #:18.239	rejected
 end:16.7397
 (*:14.7778	prefix accepted: (
 //:12.8167	prefix accepted: /
 in:12.2408	rejected
 _:12.0819	rejected
 /*:12.0631	prefix accepted: /
 else:11.7867	rejected
 P:11.5736	rejected
 case:11.4836	rejected
 ~:11.482	rejected

:11.3543
 --:10.9496	prefix accepted: -
 ##:10.9166	rejected
 {:10.8986	rejected
 -:10.9496
 *:10.8685
 +:10.661
 (:14.7778
 <:10.5637

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    |

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    |
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 P:20.9137
 _:16.0669
P:13.9185
 Play:12.5387
 :12.4138
 Remove:12.2297
 No:11.1199
_:10.7739
 #:10.5679	rejected
Â :10.3405	rejected
 pause:10.2588
>:10.2355	rejected
 Stop:10.1885	rejected
 =>:10.1653	rejected
 otherwise:9.75327
 >:9.62194	rejected
  :9.62064
 other:9.4926
 T:9.46717	rejected
 (:9.27968
 Get:9.26569	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | P

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | P
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "auseCurrentSong" | "ausedOn" | "laySong" | "laying"
root ::= completions

Top 20 Logits:
ause:22.9252
aused:14.0708
au:11.9023
aus:10.704
aste:10.3921	rejected
ulse:9.96225	rejected
urchase:9.37683	rejected
rep:9.36861	rejected
 pause:9.34113	rejected
ose:9.29638	rejected
ush:8.99234	rejected
use:8.78928	rejected
p:8.59803	rejected
ase:8.53129	rejected
ouse:8.46233	rejected
P:8.27	rejected
ace:8.1438	rejected
ull:7.84809	rejected
refix:7.74742	rejected
alse:7.73478	rejected
ipeline:7.3095	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | Pause

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | Pause
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Pause>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Pause"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]  
Error in term:
  Pause
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Pause
LSP: Generating Completions for prefix: Pause
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "CurrentSong" | "dOn"
root ::= completions

Top 20 Logits:
Current:23.5439
S:13.9717	rejected
 =>:12.8075	rejected
On:12.2858	rejected
C:12.1765
 Current:11.596	rejected
(:11.0486	rejected
Cur:10.9941
_:10.5694	rejected
Play:10.3679	rejected
():10.175	rejected
All:9.90715	rejected
Music:9.79964	rejected
current:9.52248	rejected
 ->:9.32702	rejected

:9.27906	rejected
 =:9.1227	rejected
 on:9.05273	rejected
 current:9.02665	rejected
Or:8.93715	rejected
And:8.82129	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrent

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrent
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrent>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PauseCurrent"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]  
Error in term:
  PauseCurrent
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PauseCurrent
LSP: Generating Completions for prefix: PauseCurrent
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:22.9164
Sound:12.663	rejected
 Song:12.1818	rejected
ly:12.1285	rejected
 song:11.3156	rejected
(:10.9428	rejected
SON:10.8362	rejected
Play:10.2621	rejected
 =>:10.2373	rejected
():10.2288	rejected
 =:9.87826	rejected
song:9.78449	rejected
On:9.7451	rejected

:9.66405	rejected
State:9.28951	rejected
_:9.16764	rejected
 ->:9.10644	rejected
::9.02412	rejected
Action:8.91735	rejected
Music:8.7239	rejected
Show:8.69995	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrentS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PauseCurrentS"))))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]  
Error in term:
  PauseCurrentS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PauseCurrentS
LSP: Generating Completions for prefix: PauseCurrentS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:25.8906
ongs:14.6937	rejected
 song:13.3202	rejected
song:12.4018	rejected
on:12.3929
ongo:11.963	rejected
oon:10.7766	rejected
ONG:9.94329	rejected
n:9.81404	rejected
ng:9.80929	rejected
On:9.64865	rejected
oup:9.51137	rejected
 on:9.40992	rejected
og:9.32947	rejected
mo:9.12882	rejected
ond:8.96904	rejected
 Song:8.88023	rejected
ou:8.84354	rejected
now:8.75268	rejected
ame:8.752	rejected
onic:8.72306	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrentSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (PlaySong(Int) + PauseCurrentSong + RemoveSong(Int) + AddSong(Int))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PauseCurrentSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PauseCurrentSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.3824
=>:13.8712
 :13.6767
 when:13.5214	rejected

:12.9813
 ->:12.9596	rejected
 as:12.2343	rejected
 if:11.8688	rejected
  :11.7713
 =:11.361
    :9.92363
 _:9.69127	rejected
 :=:9.56642	rejected
   :9.20762
      :9.1507
 |:8.71119	rejected
	:8.59099	rejected
 :::8.48011	rejected
        :8.43738
::8.40573	rejected
 {:8.40071	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.1379
 :17.0277
  :15.4265
 match:13.8213	rejected
    :13.752
 (:13.5451
 (*:13.5218	prefix accepted: (
 get:13.462
 let:13.3939
 #:13.3197	rejected
 play:13.1383
      :13.0242
        :12.8472
 ?:12.7981	rejected
 case:12.7806
                :12.1473
   :12.0566
 update:12.0093
         :11.8648
            :11.8523
 {:11.7986	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :20.6284
      :17.5814
    :16.7342
       :16.517
   :15.252
        :14.5626
         :14.3179

:14.0871
  :13.9101
	:13.572	rejected
#:13.3095	rejected
           :12.7676
 :12.6937
          :12.4999
            :11.5027
let:11.4668
                :11.0614
             :10.9334
(*:10.7469	prefix accepted:(
               :10.6072
              :10.3604

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:22.0122
 case:21.2586
 match:19.7829	rejected
 get:17.0499
 if:16.9593
 play:16.743
 #:16.6301	rejected
 (:16.3182
 (*:15.2963	prefix accepted: (
 begin:15.0999	rejected
 switch:13.9152	rejected
 Play:13.8584
 update:13.7538
 {:13.6594	rejected
 ():13.3463
 List:12.7984	rejected
 ?:12.704	rejected
 print:12.6608	rejected
 ((:12.652	prefix accepted: (
 f:12.4519
 fun:12.2974

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:18.3614
 _,:14.887	prefix accepted: _
 state:14.2952
 new:13.9286
 song:13.8865
 _:14.887
 current:13.7357
 play:12.7266
 (:11.8175
 old:11.1347
 id:11.122
 next:11.0314
 playing:10.999
 s:10.7449
 curr:10.5329
 is:10.2911
 p:10.1684
 Songs:10.1342	rejected
 no:9.90906
 cur:9.82694
 get:9.76062

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:20.7484
 =:18.2625
 ,:15.207
_,:13.4908	prefix accepted:_
_:13.4908
::12.1834
1:11.785
=:11.6289
 _,:11.5701	rejected
 ::11.4384
 :10.9546
  :10.8998
 _:10.6938	rejected
2:10.678
@:10.6761	rejected
',:10.6427	rejected
 @:10.3806	rejected
0:10.2166
,,:9.80608	prefix accepted:,
    :9.59624
,(:9.52472	prefix accepted:,

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:17.2767
 state:16.8047
 _:16.0624
 playing:14.0983
 song:13.1673
 play:12.9643
 old:12.6059
 curr:11.6777
 p:11.3744
 Play:11.3221
 s:11.2058
 c:10.9429
 status:10.8638
 cur:10.7162
current:10.5905
 x:10.5445
 selected:10.4757
 (:10.2643
 player:10.2224
 paused:10.2183
 P:10.1414

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: ?, songs: ?, action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:23.101
_:16.6272
=:15.6349
State:14.9206
 :14.6844
S:13.1965
state:13.0538
Play:12.4751
 ->:12.2796	rejected
::12.2396
  :12.2296
1:11.7139
,:11.4604
 as:11.341	rejected
Id:11.0704
play:10.863
 ::10.7079
2:10.652
    :10.4386
 state:10.2303	rejected
0:10.2028

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current =

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current =
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:22.1587
 get:13.8034
 :13.7867
play:12.7314

:12.3725
 (:12.3015
 action:11.3944
 List:11.2299	rejected
 pal:10.5	rejected
 current:10.3132	rejected
 update:10.311
 p:10.1934
 f:10.0512
 list:10.0169	rejected
 Play:10.0017
 pl:9.92558
 match:9.65711	rejected
 player:9.63609	rejected
  :9.24964
 state:9.23497	rejected
 song:9.02355	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:25.643
 list:12.9722	rejected
List:12.4811	rejected
l:12.4654
ist:12.313	rejected
lst:12.0219	rejected
lists:11.8665	rejected
_:11.6289	rejected
lis:10.9328
lista:10.725	rejected
state:10.7144	rejected

:10.5325	rejected
ling:10.4967	rejected
let:10.3604	rejected
play:10.253	rejected
label:10.1101	rejected
.:9.89694	rejected
link:9.86557	rejected
last:9.82807	rejected
ls:9.73271	rejected
line:9.43064	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:22.1366

:14.6795
 :14.4497
,:14.0844
;:12.6451	rejected
  :12.5525
 and:11.9372	rejected
.:11.6823	rejected
    :10.9653
   :10.4742
      :10.4414
in:10.4279
                :10.1127
 ,:9.64132
	:9.62843	rejected
        :9.49496
     :9.45349
         :9.23557
 |:9.00084	rejected
 #:8.96182	rejected
 ;:8.95316	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:20.5599
 :17.1183
  :15.9955
      :14.9901
    :14.7341
        :13.4088
   :12.8601
 match:12.7039	rejected
     :12.6287
         :12.4059
          :12.3911
 case:12.3597
                :12.3017
       :12.2117
            :12.1586
 (*:11.9878	prefix accepted: (
	:11.7573	rejected
 (:11.9878
           :11.2881
 #:11.2648	rejected
              :11.2382

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :20.6511
      :16.8888
       :16.2258
    :15.7639

:14.9098
         :14.6505
        :14.4409
   :13.9188
  :13.7098
	:13.5241	rejected
           :12.9086
#:12.7355	rejected
          :12.5755
 :12.4189
                :11.6848
(*:11.2477	prefix accepted:(
            :11.2113
             :11.053
               :10.5631
if:10.2521
let:9.8239

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:21.845
 if:21.5851
 match:21.5289	rejected
 (:18.6003
 let:18.5477
 #:16.6219	rejected
 begin:15.6237	rejected
 get:15.2087
 (*:14.8645	prefix accepted: (
 ((:14.4611	prefix accepted: (
 current:14.3105
 {:14.2259	rejected
 print:13.9886	rejected
 assert:13.7877	rejected
 ([:13.4853	prefix accepted: (
 Play:13.2696
 List:13.2608	rejected
 switch:13.2602	rejected
 play:13.1283
 [:13.0308
 try:12.6995	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 current:16.8104
 (:16.6943
 get:14.3443
 song:13.7447
 not:13.1614	rejected
 List:13.1502	rejected
 ((:12.9373	prefix accepted: (
(:12.5544
 is:12.2392
 songs:12.1777
 :12.0473
 Song:11.3679	rejected
 Songs:11.2972	rejected

:10.8697
 case:10.8634
 !:10.6955
 let:10.6141
 match:10.4702	rejected
 (!:10.3541	prefix accepted: (
  :10.3391
 Play:10.1033

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
current:18.9819
get:15.6224
List:13.4244	rejected
song:13.3099
not:12.7608	rejected
Play:12.1787
match:12.0399	rejected
 current:11.7377
play:11.7067
is:11.6032

:10.6295
case:10.3327
No:10.2033
let:10.1762
 get:9.96781
state:9.77532	rejected
 (:9.50185
Not:9.38372	rejected
Get:9.27394	rejected
type:9.13192
true:9.05517

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  current
Nature of error: Expecting type Bool but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 !=:19.1427
 ==:18.436
 =:15.6565
 is:14.5099	rejected
 <>:13.6689	prefix accepted: <
==:12.9019
 <:13.6689
 instanceof:12.3822	rejected
 \:12.3102
 =~:12.3096	prefix accepted: =
!=:12.2217
):11.9664
 as:11.8191	rejected
 >:11.8046
=:11.5865
.:11.5805	rejected
 :11.5425
 >=:11.5131
 ===:11.1843	prefix accepted: ==
 !:11.1771
 <=:11.0926

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current !=

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current !=
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >!=<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Inequality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Integer Inequality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: !=
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: !=
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 No:18.1346
 Play:14.7221
 P:14.6496
 :12.03
No:11.8692
 (:11.8161
 None:11.5962	rejected
 no:11.158	rejected
 get:10.4141
 Get:10.198	rejected
 null:10.1771	rejected
 NO:10.1741	rejected
 Player:9.61412	rejected
 N:9.41904
Play:9.34022
 playing:9.24631	rejected
 Not:9.12053	rejected
 Nothing:9.08613	rejected
P:8.9369
 nil:8.63663	rejected
 [:8.51523

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != No

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != No
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  No
Nature of error: Constructor is not defined  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:22.1424
 Song:12.5996	rejected
State:11.9633	rejected
P:11.8575	rejected
Play:11.4631	rejected
Sing:11.0391	rejected
 song:11.0302	rejected
Sound:11.0242	rejected
_:10.9822	rejected
SON:10.8918	rejected
Selected:10.8485	rejected
Current:10.7857	rejected
SS:10.4415	rejected
Selection:10.1286	rejected
C:9.98686	rejected
Sh:9.94954	rejected
New:9.76842	rejected
Se:9.72318	rejected
M:9.69301	rejected
song:9.67761	rejected
T:9.29388	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoS

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoS
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoS
Nature of error: Constructor is not defined  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:26.0485
on:17.0762
oon:15.3683	rejected
ongs:15.079	rejected
song:14.4748	rejected
ung:14.1724	rejected
 song:13.2786	rejected
one:12.902	rejected
ond:12.8294	rejected
om:12.4511	rejected
onic:12.3392	rejected
ng:12.2602	rejected
ony:12.0297	rejected
ongo:11.6914	rejected
son:11.5263	rejected
onde:11.2829	rejected
ogn:11.2675	rejected
oud:11.104	rejected
oup:11.1033	rejected
ound:11.0208	rejected
now:10.9023	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSong

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSong
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  NoSong
Nature of error: Constructor is not defined  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:23.2801
Select:14.9849
selected:14.6391	rejected
Selection:13.8031	rejected
S:13.5008
SELECT:13.4214	rejected
):12.9416	rejected
Se:12.7314
Current:12.5825	rejected
 Selected:12.5806	rejected
Selector:12.1593	rejected
Play:12.04	rejected
 selected:11.4065	rejected
Id:11.1223	rejected
ed:10.8124	rejected
P:10.5799	rejected
Available:10.3065	rejected
E:10.2267	rejected
Start:9.94648	rejected
State:9.91199	rejected
Pressed:9.85181	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Integer Inequality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 &&:19.2652
):18.488
 ):15.7257
 \:14.7107
 ||:14.0021	rejected
 :13.0185
 and:12.5014	rejected
 &:11.9419
 then:11.9071	rejected
)\:11.8444	prefix accepted:)

:11.7776
 /\:11.2238	prefix accepted: /
){:11.0767	prefix accepted:)
 /:11.2238
)::9.88936	prefix accepted:)
&&:9.65998
)(:9.55563	prefix accepted:)
\:9.5229
)?:9.51831	prefix accepted:)
  :9.19018
,:9.12036

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected &&

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected &&
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >&&<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Boolean Conjunction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Boolean Conjunction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: &&
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: &&
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 current:16.8656
 get:13.9751
 (:13
 List:12.4425	rejected
 :12.3446
 song:12.1141
 !:11.9904
 not:11.9187	rejected
 is:11.9004

:11.3654
 match:11.227	rejected
 songs:11.0233
 Songs:10.06	rejected
 ((:10.0513	prefix accepted: (
 Song:9.74347	rejected
 state:9.57501	rejected
 Play:9.24404
 s:9.1211
 can:8.79834	rejected
 type:8.78078
 curr:8.76752

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent Expectation {ana = Bool; syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  current
Nature of error: Expecting type Bool but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ==:21.1411
 !=:16.8301
 is:15.7112	rejected
 =:15.2592
.:14.785	rejected
 as:14.3685	rejected
 \:13.0997
==:12.9593
 <>:12.9302	prefix accepted: <
 !:12.8188
 =~:12.7219	prefix accepted: =
 <:12.9302
 ~:12.3234	rejected
):12.2299
 instanceof:12.0999	rejected
 >:12.0533
 ->:11.7827	prefix accepted: -
 :11.6626
!=:11.5368
 -:11.7827
 @:11.3462

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current ==

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current ==
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ==
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
 Play:19.7792
 P:16.2404
 get:13.019
 (:12.6698
 playing:12.576	rejected
Play:11.9378
 :11.8132
 No:10.6439
 current:10.5821
 Player:10.5271	rejected
 Get:9.29512	rejected
 Song:9.29301	rejected
 [:9.17746
 play:9.07916
 song:8.98127
P:8.88238
 Current:8.72961	rejected
 ):8.61934	rejected
 state:8.47478	rejected

:8.40157
 ":8.35936

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  Play
Nature of error: Constructor is not defined  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song" | "ing"
root ::= completions

Top 20 Logits:
ing:24.7804
S:14.8148
P:12.8193	rejected
ling:12.2934	rejected
(:12.26	rejected
ng:11.9569	rejected
List:11.9365	rejected
Play:11.8289	rejected
On:11.3856	rejected
i:11.3107
ed:11.2803	rejected
):11.0162	rejected
ING:11.0005	rejected
in:10.9536
list:10.832	rejected
State:10.8056	rejected
Sing:10.5411	rejected
sing:10.068	rejected
ings:9.97368	rejected
Current:9.90773	rejected
()):9.90134	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Int -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:20.8125
((:15.653	prefix accepted:(
()):15.5269	prefix accepted:(
(_:15.4027	rejected
):13.2132
(?:12.6308	prefix accepted:(
(!:11.919	prefix accepted:(
(*:11.7418	prefix accepted:(
 (:11.4281
([:11.1008	prefix accepted:(
 get:11.0076	rejected
():10.7906	prefix accepted:(
(":10.6669	prefix accepted:(
(-:10.4754	prefix accepted:(
({:10.4297	prefix accepted:(
(@:10.392	prefix accepted:(
(::10.2629	prefix accepted:(
 current:10.1747	rejected
(\:10.0524	prefix accepted:(
(...:9.90486	rejected
 _):9.87581	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
get:17.5034
song:14.9042
current:13.5479
hd:12.4725	rejected
List:11.8316	rejected
play:11.1847
x:11.0935	rejected
Id:10.8891	rejected
f:10.7221
id:10.5212	rejected
0:10.5121
 get:10.3296
Int:10.2976	rejected
Play:9.89429
?):9.71049	rejected
p:9.68633
head:9.57029	rejected
h:9.44572	rejected
s:9.42432
1:9.37752
curr:9.34152

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get
Nature of error: Variable get is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get
LSP: Generating Completions for prefix: get
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_songs" | "_state"
root ::= completions

Top 20 Logits:
_:20.454
 state:12.8917	rejected
(:12.2617	rejected
State:12.1956	rejected
state:11.1705	rejected
 current:10.7526	rejected
Id:10.7055	rejected
Play:10.3288	rejected
Current:10.2552	rejected
S:10.0179	rejected
P:9.7815	rejected
List:9.70039	rejected
 song:9.61194	rejected
Last:9.48138	rejected
.:9.31973	rejected
-:9.23835	rejected
<:9.08788	rejected
current:9.08251	rejected
 songs:8.89761	rejected
 id:8.8848	rejected
__:8.87763	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get_"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  get_
Nature of error: Variable get_ is not bound  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get_
LSP: Generating Completions for prefix: get_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "songs" | "state"
root ::= completions

Top 20 Logits:
state:24.0772
song:18.7194
current:18.2874	rejected
play:17.5871	rejected
id:16.8295	rejected
selected:15.809	rejected
next:15.6306	rejected
first:15.5091	rejected
curr:15.3713	rejected
last:15.3136	rejected
action:14.8943	rejected
cur:14.6001	rejected
active:14.539	rejected
status:14.5168	rejected
p:14.4153	rejected
sing:14.3422	rejected
player:14.0511	rejected
s:13.3992
head:13.384	rejected
music:13.3817	rejected
top:13.2507	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected)) -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id");
           syn = (Arrow ((Var "PlayList"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get_state
Nature of error: Expecting type Id but got inconsistent type (PlayList -> PlayListState)  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: get_state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: get_state
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:19.5113
)):13.6274
((:13.2398	prefix accepted:(
 play:12.5712	rejected
())):12.2889	prefix accepted:(
_:10.9855	rejected
[:10.6413	rejected
 song:10.5119	rejected
 current:10.441	rejected
):10.3984
 (:10.2517
()):10.1254	prefix accepted:(
([:9.89698	prefix accepted:(
.:9.72585	rejected
play:9.70721	rejected
(_:9.52774	rejected
.(:9.51613	rejected
(*:9.51472	prefix accepted:(
(...:9.36245	rejected
(@:9.07923	prefix accepted:(
)(:8.96913	prefix accepted:)

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
play:22.9765
current:14.9686
Play:14.0507
pl:13.9621
p:13.5075
song:13.4715
pal:13.095	rejected
action:12.5606
plays:12.2853	rejected
x:11.9876	rejected
player:11.8627	rejected
new:11.6377	rejected
 play:11.3937

:11.0084
get:10.9831
pay:10.8346	rejected
P:10.8342
self:10.8256	rejected
sing:10.5359	rejected
next:10.5264	rejected
ps:10.4508	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  get_state(play)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:22.6744
List:17.0003	rejected
lis:14.0548
l:12.9654
ist:12.8125	rejected
lists:12.7138	rejected
)):12.6114	rejected
))):12.5704	rejected
ls:12.0531	rejected
lst:11.9831	rejected
_:11.6852	rejected
 list:11.5073	rejected
lit:11.1806	rejected
-:10.948	rejected
ing:10.9263	rejected
lista:10.5461	rejected
li:10.3574
ll:9.95482	rejected
state:9.94674	rejected

:9.92963	rejected
State:9.83646	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
))):21.9768	prefix accepted:))
)):21.9768
):15.6174
)),:12.9301	prefix accepted:))
)))):12.2103	prefix accepted:))
::12.0349
)));:11.7939	prefix accepted:))
),:11.6943	prefix accepted:)
)).:11.0705	prefix accepted:)
 :10.7542
))::10.742	prefix accepted:))
))\:10.5708	prefix accepted:))
])):10.1459	rejected
 as:10.0407	rejected
 ):9.85984
=:9.68967
).:9.66933	rejected
 =:9.60494
));:9.5854	prefix accepted:))
))]:9.57359	prefix accepted:))
)!:9.45713	prefix accepted:)
Rejected the highest logit candidate ))) with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist))

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Boolean Conjunction
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ):17.9865
 then:16.4165	rejected

:14.3861
 ||:14.2472	rejected
 :13.7918
 \:13.345
)\:12.9893	prefix accepted:)
 &&:12.9061
  :11.7215
){:11.3163	prefix accepted:)
then:11.2278	rejected
),:10.1891	prefix accepted:)
)=:10.1126	prefix accepted:)
 {:9.48472	rejected
 #:9.47159	rejected
 ){:9.43646	prefix accepted: )
 ?:9.4229	rejected
||:9.18024	rejected
 /\:9.08617	prefix accepted: /
 ==:8.9928
   :8.82034

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) )

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) )
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:19.6162
then:17.2086

:15.7272
 :14.823
  :12.9495
 ||:11.9626	rejected
 \:10.4917
    :10.4828
 {:10.2943	rejected
   :9.88504
      :9.7616
||:9.71904	rejected
 THEN:9.02791	rejected
        :8.89236
 &&:8.84249
                :8.82359
     :8.69733
	:8.6501	rejected
 #:8.6191	rejected
 Then:8.54597	rejected
         :8.35356

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:21.1338
 :18.2184
  :16.7972
      :15.2695
    :14.9693
 (:14.8796
        :14.6333
   :13.6971
         :13.4921
            :13.4342
     :13.41
                :13.3938
          :13.0291
       :12.9908
	:12.4325	rejected
           :12.4069
 #:12.3724	rejected
 {:11.807	rejected
              :11.5928
 (*:11.4811	prefix accepted: (
             :11.3874

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :22.1492
        :19.6022
         :19.4196
      :19.1912
     :16.594
           :16.2007
          :16.1219
	:15.9826	rejected
             :14.6167
    :14.5934
            :14.5434

:14.2
                :14.0002
               :13.8679
  :13.6288
              :13.3239
   :13.17
#:12.7576	rejected
 :12.4268
(:12.1715
(*:10.8441	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:21.8037
 play:17.372
 let:16.9466
 #:16.3256	rejected
 (*:16.1659	prefix accepted: (
 ([:15.7575	prefix accepted: (
 ((:15.4587	prefix accepted: (
 List:14.687	rejected
 if:13.9721
 get:13.9416
 [:13.8787
 songs:13.5207
 print:13.4006	rejected
 #(:13.3896	rejected
 update:13.2443
 match:13.1383	rejected
 //:13.1362	rejected
 {:12.9749	rejected
 (_:12.6752	rejected
 new:12.4413	rejected
 return:12.3917	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
song:19.9032
 songs:13.2813
List:13.0917	rejected
get:13.0559
play:12.733
current:11.8387
sing:11.5069	rejected

:11.016
let:10.8813
remove:10.6288	rejected
new:10.6158	rejected
Play:10.2238
if:9.95871
update:9.71793
list:9.68495	rejected
set:9.5419	rejected
s:9.42674
Get:9.42391	rejected
S:9.28792	rejected
scripts:9.28201	rejected
 get:9.25704

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (song

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (song
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  song
Nature of error: Variable song is not bound  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:22.441
,:14.8908	rejected
:::14.4126	rejected
 :::11.4169	rejected
 ,:10.6024	rejected
ss:10.3604	rejected
es:10.162	rejected
sl:9.69327	rejected
::9.41788	rejected
st:9.27811	rejected
z:9.1108	rejected
_:9.06565	rejected
@:9.02069	rejected
.:8.93975	rejected
ns:8.84225	rejected
 //:8.83737	rejected
 -:8.77341	rejected
S:8.69089	rejected
List:8.52567	rejected
 @:8.48822	rejected
sd:8.4546	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:20.4378
 ,:15.7408
 @:12.8466
 -:11.8183
,(:11.3616	prefix accepted:,
@:10.8343
 +:10.6945
.:10.584	rejected
::10.4656
 P:10.0659	rejected
 ::9.94384
 :9.88123
,,:9.83875	prefix accepted:,
 ++:9.63237
,[:9.55927	prefix accepted:,
 List:9.48668	rejected

:9.46327
 [:9.31783	rejected
[:8.92495	rejected
  :8.84
,\:8.70954	prefix accepted:,

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs,

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs,
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 P:18.9513
 current:13.8154
 No:13.6918
P:13.4194
 :13.1664
 get:13.1557
 paused:12.7718	rejected
 Play:12.5286
 (:12.2919
 song:11.5715
  :10.8055
 pause:10.4341	rejected

:9.99022
 state:9.92007	rejected
 Songs:9.68337	rejected
 Song:9.65844	rejected
    :9.52501
 new:9.44912	rejected
 p:9.43553
 Current:9.26198	rejected
 List:9.10454	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, P

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, P
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  P
Nature of error: Constructor is not defined  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "auseCurrentSong" | "ausedOn" | "laySong" | "laying"
root ::= completions

Top 20 Logits:
aused:25.6405
ause:15.7229
aus:14.1104
ushed:13.4646	rejected
 paused:12.536	rejected
osed:11.9972	rejected
au:11.9774
ased:11.8418	rejected
used:11.1478	rejected
ending:10.9765	rejected
icked:10.9055	rejected
leased:10.6041	rejected
oused:10.3764	rejected
lapsed:10.345	rejected
ained:10.2398	rejected
ued:10.155	rejected
anned:10.0906	rejected
ended:10.0869	rejected
ared:9.83437	rejected
uzz:9.71086	rejected
usted:9.68552	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, Paused

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, Paused
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  Paused
Nature of error: Constructor is not defined  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:23.8338
(:14.2146	rejected
on:12.5686	rejected
Current:12.099	rejected
 On:11.9431	rejected
S:11.9222	rejected
 on:11.5711	rejected
O:11.4724
Of:11.1993	rejected
):10.837	rejected
In:10.8096	rejected
ON:10.787	rejected
One:10.5803	rejected
At:10.3604	rejected
()):10.2128	rejected
_:10.0964	rejected
By:10.0283	rejected
From:9.82805	rejected
State:9.66903	rejected
((:9.55782	rejected
Off:9.53183	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Int -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:21.3542
((:16.2796	prefix accepted:(
 (:14.2067
 get:14.1719	rejected
()):13.6983	prefix accepted:(
(?:12.5591	prefix accepted:(
(@:12.3116	prefix accepted:(
(_:12.0953	rejected
(-:12.0362	prefix accepted:(
):11.637
[:10.9039	rejected
(!:10.8852	prefix accepted:(
(*:10.7153	prefix accepted:(
 current:10.7137	rejected
({:10.6883	prefix accepted:(
 song:10.6002	rejected
([:10.594	prefix accepted:(
 :10.5681
(":10.4374	prefix accepted:(
():10.2092	prefix accepted:(
(...:10.1511	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
get:18.7815
current:15.4894
 get:14.6667
song:14.342
Play:12.5086
play:11.8609
P:11.657
List:11.3335	rejected
f:11.2609
 current:10.5388
p:10.4624
No:10.3862
Get:10.1724	rejected
hd:10.0103	rejected
id:9.6927	rejected
 song:9.58082
s:9.55227
no:9.24888	rejected
S:9.21796	rejected
0:9.21469
curr:9.09959

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  get
Nature of error: Variable get is not bound  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get
LSP: Generating Completions for prefix: get
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_songs" | "_state"
root ::= completions

Top 20 Logits:
_:20.7684
 state:11.7084	rejected
State:11.1603	rejected
S:10.0965	rejected
state:9.99442	rejected
-:9.98307	rejected
Play:9.93469	rejected
(:9.74949	rejected
 song:9.67776	rejected
.:9.34567	rejected
Current:9.27625	rejected
 current:9.21548	rejected
song:8.83365	rejected
P:8.77638	rejected
current:8.75482	rejected
 _:8.71309	rejected
 songs:8.66374	rejected
__:8.42697	rejected
List:8.14382	rejected
 Song:8.05684	rejected
_(:7.95113	prefix accepted:_

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "get_"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_
Nature of error: Variable get_ is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: get_
LSP: Generating Completions for prefix: get_
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "songs" | "state"
root ::= completions

Top 20 Logits:
state:24.0818
current:17.1855	rejected
song:16.9714
id:14.6146	rejected
status:14.3416	rejected
play:14.1703	rejected
last:14.1321	rejected
s:14.0671
first:14.0108	rejected
sing:13.9182	rejected
stat:13.6429
p:13.601	rejected
selected:13.5633	rejected
states:13.5592	rejected
action:13.5525	rejected
st:13.5386
State:13.4114	rejected
curr:13.105	rejected
next:13.0431	rejected
player:12.9481	rejected
active:12.8922	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <get_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected)) -> (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id");
           syn = (Arrow ((Var "PlayList"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state
Nature of error: Expecting type Id but got inconsistent type (PlayList -> PlayListState)  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: get_state
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: get_state
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
(:21.0507
((:14.3422	prefix accepted:(
 play:12.6757	rejected
 (:11.9115
())):11.4139	prefix accepted:(
)):10.4757
[:10.4576	rejected
([:10.2167	prefix accepted:(
)(:9.75651	prefix accepted:)
_:9.75069	rejected
()):9.62006	prefix accepted:(
 song:9.54552	rejected
 current:9.5309	rejected
(*:9.36046	prefix accepted:(
.(:9.34033	rejected
(_:8.9661	rejected
!(:8.9165	prefix accepted:!
):9.75651
play:8.79512	rejected
(!:8.76998	prefix accepted:(
():8.70982	prefix accepted:(

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Id"); syn = (Var "PlayListState")})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(?)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
play:22.2027
current:14.8398
Play:14.1124
p:13.7543
pl:13.522
pal:13.2636	rejected
 play:13.0778
song:12.9267
player:12.5486	rejected
plays:12.3655	rejected
action:12.2854
new:11.8874	rejected
x:11.8389	rejected
pay:11.4444	rejected
P:11.1954
self:11.1421	rejected
sing:11.0031	rejected
ps:10.9949	rejected
pla:10.8007
state:10.4125	rejected
Current:10.3105	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(play)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:23.6634
List:17.1558	rejected
l:16.2276
ist:14.1968	rejected
lis:13.7889
lst:13.5844	rejected
lists:12.7966	rejected
)):12.462	rejected
let:12.454	rejected
lit:12.4082	rejected
ls:12.3432	rejected
 list:12.0186	rejected
_:11.786	rejected
ll:11.5192	rejected
lish:11.235	rejected
play:11.1243	rejected
link:10.914	rejected
line:10.8629	rejected
ling:10.8419	rejected
):10.8075	rejected
label:10.6399	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
))):21.9379	prefix accepted:))
)):21.9379
):16.6525
)));:14.172	prefix accepted:))
)),:14.1683	prefix accepted:))
)))):12.99	prefix accepted:))
 :12.1029
))]:11.3861	prefix accepted:))
),:11.1739	prefix accepted:)
)).:11.0425	prefix accepted:)
 ):10.5939
));:10.5725	prefix accepted:))
))::10.5199	prefix accepted:))
])):10.1574	rejected
::9.90106
,:9.57754
)(:9.52894	prefix accepted:)
).:9.40256	rejected
)!:9.13223	prefix accepted:)
)+:9.07396	prefix accepted:)
)::8.98546	prefix accepted:)
Rejected the highest logit candidate ))) with logit -inf

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist))

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist))
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Playing(Int) + PausedOn(Int) + NoSongSelected)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 ):18.1713
 :14.0445

:13.1694
),:12.9385	prefix accepted:)
  :12.6071
 end:11.3042	rejected
 );:10.9137	prefix accepted: )
 else:10.4736	rejected
 ::10.4712
 ),:10.3137	prefix accepted: )
    :10.1818
   :10.1141
 :::10.045
:::9.97644
 ,:9.87792
)\:9.83822	prefix accepted:)
 @:9.79625
)::9.48915	prefix accepted:)
	:9.40158	rejected
      :9.38625
)]:9.33161	prefix accepted:)

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:

:20.6626
 :17.9703
  :16.9587
    :15.3711
      :14.9333
 else:14.7094
        :14.6496
 #:14.3876	rejected
   :14.2937
 (*:14.1869	prefix accepted: (
     :13.08
         :12.793
       :12.7255
                :12.6645
          :12.6492
 @:12.5372
#:12.2216	rejected
            :12.152
           :12.1222
	:11.9226	rejected
 *:11.8652

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
     :21.2309
      :16.5121
    :15.1979
       :15.0895
   :14.8506
        :13.9203

:13.6201
         :13.2761
#:13.2047	rejected
          :12.8151
  :12.6695
else:12.6399
	:12.5567	rejected
 :12.5018
           :12.2208
end:12.022	rejected
            :11.6124
 else:11.5685
                :11.4876
(*:10.9241	prefix accepted:(
             :10.3866

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
     

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
     
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:24.3366
 elif:17.7156	rejected
 #:17.5104	rejected
 end:16.4868	rejected
 els:15.1693
 (*:14.3124	prefix accepted: (
 if:13.0545	rejected
 (:14.3124
 in:12.2522	rejected
 {:12.0383	rejected
 el:11.9229
 Else:11.6812	rejected
 //:11.5819	prefix accepted: /
 match:11.5689	rejected
 ##:11.3891	rejected
 play:11.366	rejected
 ~:11.3073	rejected
 otherwise:11.1239	rejected
 ,:11.0323
 #(:10.9393	rejected
 ((:10.8928	prefix accepted: (

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.2841
 :18.771
 play:15.9633
 if:15.7382
  :15.2023
 (:13.8738
    :13.7309
 (*:12.8194	prefix accepted: (
        :12.7285
   :12.5506
      :12.4933
                :12.1976
 ():11.659
 ((:11.3375	prefix accepted: (
          :11.1682
            :11.1058
 #:11.0909	rejected
     :10.9815
 match:10.9789	rejected
         :10.8839
       :10.8276

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :21.7698
      :18.2649
        :18.1127
         :17.0009
     :15.159
	:14.5973	rejected
          :14.3903
   :13.7192
           :13.719
    :13.4466
 :12.7662
            :12.5919
  :12.4373
             :12.3175

:12.1824
#:11.9982	rejected
               :11.8441
                :11.8253
              :11.6886
(*:11.411	prefix accepted:(
play:10.3143

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
       

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
       
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "playlist" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 play:21.4603
 (:18.9773
 #:15.8334	rejected
 (*:15.417	prefix accepted: (
 let:15.1944
 if:15.0806
 ((:14.6108	prefix accepted: (
 ?:14.0564	rejected
 match:13.9498	rejected
 print:13.8893	rejected
 ([:13.8695	prefix accepted: (
 fail:13.347	rejected
 (":13.2635	prefix accepted: (
 {:13.2289	rejected
 raise:12.9537	rejected
 [:12.9189
 Play:12.8274
 case:12.8173
 current:12.778
 update:12.7594
 no:12.7279	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
        play

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
        play
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "play"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  play
Nature of error: Variable play is not bound  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: play
LSP: Generating Completions for prefix: play
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "list"
root ::= completions

Top 20 Logits:
list:22.3642
List:13.7621	rejected
l:13.638
ist:13.2955	rejected
lit:12.4041	rejected
 list:12.3341	rejected
lists:12.222	rejected
lis:12.0607
lst:11.5662	rejected
_:11.4478	rejected
li:11.2457
ls:10.9111	rejected
ll:10.2015	rejected

:10.1622	rejected
let:9.91115	rejected
lista:9.64035	rejected
ling:9.49163	rejected
listen:9.37998	rejected
 :9.33585	rejected
play:9.24239	rejected
link:9.22681	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
        playlist

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
        playlist
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <playlist>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: playlist
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: playlist
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action playlist update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:19.2809
 :18.4271

:18.0165
  :15.7061
 in:15.4274	rejected
      :14.726
    :14.4931
   :14.3955
        :14.1826
                :13.741
;:13.2578	rejected
         :13.0206
          :12.6691
            :12.6134
     :12.5807
 (*:12.3725	prefix accepted: (
 #:12.3419	rejected
       :12.3004
 ():12.116	prefix accepted: (
():11.9475	prefix accepted:(
	:11.7497	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
        playlist end

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
        playlist end
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Int], (Playing(Int) + PausedOn(Int) + NoSongSelected))
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, playlist: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:17.4341
 :17.2116

:16.3819
  :14.4266
   :12.5447
 #:12.2696	rejected
    :12.2091
 end:11.966	rejected
      :11.7201
;:11.4313	rejected
in:11.3893
 with:11.1912	rejected
        :10.9984
                :10.689
     :10.358
 +:10.2528
         :10.0777
	:10.0444	rejected
 and:9.92858	rejected
 (*:9.90826	prefix accepted: (
#:9.85906	rejected

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
        playlist end in

LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
        playlist end in
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.243
 :16.4474
  :14.4534
 #:13.7398	rejected
    :13.4615
   :13.1114
      :13.0546
        :11.9597
;:11.8286	rejected
                :11.6945
#:11.6316	rejected
          :11.0684
     :11.0367
	:10.9516	rejected
            :10.8871
       :10.8092
         :10.7954
 ;:10.4491	rejected
              :10.4368
           :10.3326
             :9.81188

================
# Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
        playlist end in


LSP: Command: Completions(Context)
LS: New token mode: # Update Playlist app model based on an action #

let update: (PlayList, PlayListAction) -> PlayList = 
  fun playlist, action ->
    case action
    | AddSong(song) =>
      let songs, current = playlist in
      if (current == NoSongSelected) then
        (song::songs, PausedOn(song))
      else
        (song::songs, current) 
    | PlaySong(song) =>
      let songs, _ = playlist in
      if song == get_state(playlist) then
        playlist
      else
        (songs, PausedOn(song))
    | RemoveSong(song) =>
      let songs, current = playlist in
      let new_songs = 
        songs
        - [song] 
        - (if song == get_state(playlist) then [get_state(playlist)] else [] )
      in
      if (current != NoSongSelected && current == Playing(song)) then
        (new_songs, NoSongSelected)
      else
        (new_songs, current) 
    | PauseCurrentSong =>
      let songs, current = playlist in
      if (current != NoSongSelected && current == Playing(get_state(playlist)) ) then
        (songs, PausedOn(get_state(playlist)) )
      else
        playlist end in

LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
LSP: Process zipper: Recieved string
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, string_contains: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  
Nature of error: Expecting type Int but got inconsistent type [?]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  song
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  songs
Nature of error: Expecting type Int but got inconsistent type [Id]  
Error in term:
  new_songs
Nature of error: Expecting type [Id] but got inconsistent type Int  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Id but got inconsistent type PlayListState  
Error in term:
  get_state(playlist)
Nature of error: Expecting type Int but got inconsistent type [PlayListState]
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: update get_state get_songs string_contains string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddSong" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_contains" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
#:19.0179	rejected

:18.6902
  :16.4674
    :15.8859
 :15.7499
      :15.0435
let:14.8919
   :14.7566
        :14.1583
}:13.6108	rejected
 #:13.5574	rejected
(*:13.553	prefix accepted:(
                :13.0405
type:12.9464
```:12.9341	rejected
     :12.7508
update:12.6191
*):12.5142	rejected
            :12.4998
       :12.27
          :12.2226
Rejected the highest logit candidate # with logit -inf
