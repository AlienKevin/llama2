
================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.5277
 :19.2337
 fun:16.9156
  :14.8604
    :13.9601
                :12.7868
   :12.2511
     :12.251
        :11.8473
 ?:11.6973
 let:11.5733
 {:11.5683
      :11.4528
            :11.4032
 #:11.3462
	:11.1554
       :11.1045
fun:11.0668
         :10.9277
 //:10.8042
          :10.7736

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =


Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :21.309
   :18.2473
fun:17.8903
 fun:15.7235
  :15.3759
	:14.4387
       :14.3731
     :14.1478
let:13.8139
    :13.2222
func:13.2221

:12.5411
 let:12.4945
           :11.5648
         :11.1811
      :11.0434
function:10.99
fn:10.6363
 func:10.4868
#:10.1886
                :10.1549

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
 

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:22.3315
 let:16.2957
 #:12.8641
 func:12.4969
 {:12.26
 //:11.8923
 rec:11.861
 (:11.738
 lambda:11.5937
 (*:11.3733
 match:11.2121
 find:10.9467
 fol:10.6795
 ##:10.5106
 ?:10.5087
 fn:10.4457
 fix:10.3476
 /*:10.3383
 f:10.2875
 if:10.1444
 loop:10.1357

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun ? ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun ? ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun ? ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun ? ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 p:17.471
 pred:16.4129
 f:16.3758
 fn:13.7631
 predicate:13.5707
 is:12.8815
 cond:12.6282
 test:12.4988
 xs:11.5446
 func:11.1319
 x:11.1002
 check:10.9908
 g:10.8092
 pr:10.8059
 condition:10.6954
 e:10.2723
 ok:10.2422
 eq:9.98434
 q:9.78257
 el:9.77296
 c:9.68748

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: ((Int -> Bool), [Int]), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun p ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun p ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun p ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun p ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:18.1323
 xs:13.7636
 ,:13.7502
 x:12.3299
?,:11.6763
f:11.3073
::10.5244
xs:10.3195
x:9.93194
 l:9.77264
_:9.74625
 ->:9.69304
fx:9.35694
 in:9.16898
 f:9.09921
fun:9.00346
 as:8.84791
 ::8.6619
?:8.37897
 =:8.32827
 _,:8.24656

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p,

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, ?) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:18.9071
 l:17.0419
 x:13.1571
 list:12.9956
 ls:12.4513
 lst:12.4141
xs:11.5794
 s:11.361
 y:11.0733
 a:10.7619
 h:10.6619
 arr:10.6408
 i:10.4813
 e:10.3351
 t:10.222
 :10.0757
 items:10.0603
 n:9.97614
 v:9.97032
 xx:9.90194
 ele:9.80842

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.9422
,:15.5848
->:14.7724
 :13.3675

:11.9802
0:11.682
 =>:11.4152
 |:11.1109
 =:10.8699
 in:10.8215
::10.7536
 ,:10.6195
 ~:10.3169
  :10.1023
 -:10.0467
 -->:9.7813
 ::9.65008
 as:9.57773
 //:9.45951
;:9.26246
 {:9.25593

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.8537
 :16.8238
  :14.2514
 let:13.7807
    :13.4575
 fol:13.1203
   :12.8262
 find:12.8103
 go:12.4866
                :12.2185
     :12.1001
 -:12.0765
 match:11.8785
 #:11.8758
        :11.6714
 length:11.3599
      :11.2024
 ?:11.1936
 case:10.9174
 rev:10.9169
 fail:10.9081

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->


Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :21.1083
     :16.3828
 :16.3755
  :15.4011
    :14.9468
       :14.86
let:13.1779
case:13.1528
	:13.0764

:12.6377
         :12.6287
      :12.4596
           :11.838
match:11.8219
#:11.3537
if:11.3502
        :11.2345
 let:10.8453
          :10.3178
               :10.2938
                :10.2409

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
   

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:18.2411
 case:17.527
 fol:14.7924
 go:13.4464
 match:13.2166
 #:12.205
 if:11.9795
 length:11.8452
 rev:11.8187
 find:11.4484
 var:10.961
 (:10.6237
 rec:10.4483
 for:10.3251
 len:10.1681
 map:10.0964
 f:10.0785
 (-:9.98973
 //:9.95142
 @:9.82535
 s:9.78259

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 go:14.3937
 rec:12.8699
 f:12.2062
 idx:11.6081
 find:11.5047
 index:10.634
 aux:10.1926
 length:9.98227
 i:9.7722
 helper:9.74444
 n:9.6819
 pred:9.677
 search:9.56603
 is:9.5601
 len:9.46325
 g:9.27638
 r:9.10316
 res:9.01453
 step:8.98683
 id:8.96317
 l:8.9452

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
::17.1218
 =:13.5537
 ::13.3611
 i:11.6316
 x:11.3578
_:11.0585
 (:10.928
 f:10.7336
 n:10.3988
 xs:10.097
:(:10.0654
,:9.96333
 acc:9.93038
 idx:9.92219
(:9.6324
 l:9.58085
 p:9.3855
 find:9.13031
i:9.11564
1:9.08692
 func:8.97814

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go:

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go:
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >:<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ? = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: :
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: :
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ":"
new-tokens ::= whitespace | "(" | "()" | "+" | "Bool" | "Float" | "Int" | "String" | "StyleAttr" | "[" | constructor
root ::= completions | new-tokens

Top 20 Logits:
 (:18.8502
 ([:17.6803
 Int:15.7283
 ((:15.5058
 (?:14.0033
 [:13.8929
 (_:12.9075
 ?:12.4396
 :12.3603
([:11.8565
 [(:11.7412

:11.5236
 ():10.7702
 (!:10.6579
 int:10.6553
 (*:10.6173
 [[:10.4466
 (@:10.4461
 ({:10.4424
 {:10.3265
 _:10.2858

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (?) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty type hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "+" | "Bool" | "Float" | "Int" | "String" | "StyleAttr" | "[" | constructor
root ::= completions | new-tokens

Top 20 Logits:
Int:18.4346
Bool:14.5788
([:13.996
List:12.6754
int:12.345
?,:11.8067
_,:11.6536
[[:11.4184
[:10.9406
((:10.8874
n:10.8177
N:10.7273
x:10.3013
 Int:10.048
[]:9.89744
Boolean:9.87066
p:9.85227
Id:9.82147
 [:9.65874
i:9.53988
&:9.51588

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Base type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (Int) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (Int) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (Int) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : (Int) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Base type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave or complete: Int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:19.4153
,[:15.8717
 ->:14.981
):13.5891
 ,:12.8195
?,:12.3672
->:12.2076
 [:11.3815
 *:10.9231
[:10.5625
 [],:10.3357
*,:10.1512
 Int:10.089
[,:9.65719
 {:9.5634
,(:9.44782
*:9.37295
 x:9.32768
([:9.11033
)->:9.02593
 |:8.78925

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int,

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ?)) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Bool" | "Float" | "Int" | "String" | "StyleAttr" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 [:18.3876
 Int:16.292
 ?:15.2758
 ([:13.3869
 [(:13.1504
 (:13.0991
 List:13.0247
 Bool:12.3672
 [],:12.1935
 [[:11.4083
 xs:10.827
 :10.7641
 {:10.6371
 _:10.4781
 _,:10.2112
 (?:10.1558
 Maybe:10.0944
 *:9.98139
 []:9.91512
 ((:9.59618
 ??:9.58367

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [?])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty type hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Bool" | "Float" | "Int" | "String" | "StyleAttr" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
Int:20.4142
?:15.6588
a:14.2432
Bool:12.884
int:12.7709
]):12.235
t:12.0611
?,:12.0167
x:11.6063
In:11.2128
Maybe:11.1681
 ?:11.0007
T:10.9563
??:10.8617
_,:10.6358
m:10.5792
I:10.5695
&:10.5535
p:10.5007
A:10.4511
b:10.4229

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Base type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Base type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-concave or complete: Int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Int
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | "+" | "," | "->" | "]"
root ::= completions | new-tokens

Top 20 Logits:
],:23.3951
]):23.3637
]:18.9175
]->:15.5482
]);:14.6664
,:14.2799
],[:14.2083
])):14.0437
),:13.9756
]),:13.8639
]).:13.5763
];:13.4593
](:12.7639
):12.5845
?:12.2852
|:12.0774
}):12.0407
 ],:12.0134
]::12.0098
)]:11.892
]]:11.8079

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int]

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int]
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, [Int])) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= new-tokens

Top 20 Logits:
 ->:15.2328
 ):14.7001
 ,:13.2726
 Int:12.1372
 |:11.5149
 ?:11.2751
?):10.7904

:10.1017
?,:10.0147
 &:9.98687
 Bool:9.84577
 {:9.84027
 :9.8106
)::9.78479
 =:9.69775
 ~:9.66805
 [:9.52064
<:9.48435
 int:9.47893
 @:9.40102
|:9.3668

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] ->

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >-><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> ?))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: ->
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ->
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Bool" | "Float" | "Int" | "String" | "StyleAttr" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 Int:15.4555
 ?:15.3801
 Bool:12.5718
 [:12.3667
 Maybe:12.1097
 (:11.4371
 (?:10.3876
 Option:10.1916
 ):10.0798
):10.0268
 _):9.84551
 !:9.62852
 |:9.61749
 Either:9.61296
 ??:9.38537
 Opt:9.37911
 :9.19909
 int:9.01241
 ([:8.99273
?:8.94592
 None:8.91973

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Base type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave or complete: Int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: StyleAttr () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
):18.3383
 =:15.0583
,:12.8527
 |:12.3866
 ):12.3613
 ->:11.7472
)=:11.6948
?):11.3984

:11.249
)->:11.1918
 ?:10.7788
=:10.4923
?:10.3268
)?:10.2264
 :9.98514
|:9.88923
),:9.75496
 ||:9.34313
)):9.32958
 ==:9.28539
->:9.18599

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int)

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "+" | "," | "->" | "="
root ::= new-tokens

Top 20 Logits:
 =:17.1919
 ->:15.7433

:12.9012
 :12.0799
 <-:11.202
 =>:10.9321
 ==:9.88218
 ::9.65982
 |:9.6416
 in:9.63531
 fun:9.30955
 {:9.02205
 ~:8.87785
 Int:8.58775
  :8.54697
 (:8.48776
 -:7.98339
 :::7.9425
 []:7.93011
 x:7.92661
 f:7.87422

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.0065
 :16.9684
 fun:15.9536
  :13.8086
    :12.997
                :11.8038
 \:11.6403
 {:11.6267
 #:11.5769
 (:11.5391
     :11.3623
   :11.258
 //:11.2225
        :11.1969
      :11.1642
 ?:10.8587
            :10.8581
 match:10.8335
 fix:10.8036
       :10.5559
	:10.4328

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =


Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
     :20.3126
   :17.9339
       :17.8584
    :14.3619
      :13.9768
         :13.489
           :13.0344
	:12.9913
 :12.7909
        :11.99
  :11.7696
               :11.523
                :11.1746
             :11.0666

:10.9157
          :10.4628
            :9.96615
              :9.53234
(:8.50245
fun:8.43081
//:8.36938

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
     

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
     
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:20.2935
 case:14.0123
 match:13.637
 let:13.618
 if:13.2598
 |:13.173
 #:13.0574
 (:12.7537
 func:12.3178
 {:12.1997
 //:11.8791
 (*:11.7615
 p:11.4993
 f:11.4975
 find:11.4038
 go:11.3327
 fol:11.2282
 lambda:11.2168
 @:11.1461
 rec:11.062
 fn:11.0013

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun ? ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun ? ->
 ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type (? -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun ? ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun ? ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun ? ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 idx:18.7006
 i:16.4816
 n:16.0344
 acc:14.6494
 x:13.3947
 index:13.125
 id:12.1784
 pos:12.0299
 k:11.8822
 c:11.7298
 count:11.725
 _,:11.5441
 ind:11.3672
 start:11.2965
 curr:11.1763
 counter:11.0553
 xs:10.9904
 _:10.9593
 len:10.8798
 p:10.8745
 offset:10.8599

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun idx ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun idx ->
 ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type (? -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun idx ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun idx ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun idx ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:18.1729
 ->:14.1523
 xs:13.1811
 ,:12.6672
 l:12.0874
 acc:11.4976
 x:11.1178
::11.0808
 in:10.6983
 :10.4732

:10.4211
_:10.4207
0:9.81746
 p:9.80167
 y:9.60362
->:9.46935
 m:9.31074
 _:9.16336
 s:9.10612
 i:9.0601
xs:9.02675

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx,

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, ?) ->
 ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, ?) ->
 ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, ?) ->
 ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, ?) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:15.752
 l:15.2587
 y:14.7227
 x:12.7473
 rest:11.9705
 _:11.7356
 z:11.3207
 acc:11.2857
 ls:11.1401
 t:11.1386
 lst:11.0643
 p:10.9951
 []:10.9834
 rem:10.8609
 list:10.7703
 h:10.7151
 [:10.4269
 remaining:10.0667
 n:9.90424
 el:9.86684
 s:9.83934

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:17.8386
->:13.8999
 :13.5705
':13.3288

:13.0233
,:12.852
_:12.3207
 =>:12.2582
0:11.6734
2:11.3173
::11.0284
1:10.8034
 ::10.6337
 |:10.5546
 -:9.88284
 in:9.80089
 =:9.70841
  :9.55444
 -->:9.36493
 →:9.34462
 ~:9.16487

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.6426
 :17.1371
 case:15.6796
  :14.7652
 match:14.6914
    :13.7823
        :12.4371
      :12.1597
 if:12.1502
   :11.9853
                :11.7634
       :11.5779
     :11.3382
         :11.2467
            :11.1699
 #:10.9342
 p:10.9025
	:10.855
 idx:10.6393
          :10.6007
 fol:10.575

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->


Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :21.1309
         :16.3363
     :15.9622
   :14.9475
      :14.6503
           :14.5326
        :14.4411
	:14.0517
             :12.3245
    :12.2605
          :12.0482
               :11.8866

:11.7997
                :11.7471
            :11.263
 :11.0212
  :10.8009
              :9.9893
case:9.89589
#:9.47544
if:9.2246

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
       

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 ?
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 ? in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:22.0244
 match:18.301
 if:16.8268
 let:14.2325
 print:13.0781
 p:12.9528
 fol:12.3904
 #:12.3394
 switch:12.2673
 (:11.8863
 fun:11.765
 assert:11.6669
 |:11.4952
 is:11.3099
 cases:11.2485
 in:11.2264
 ?:11.218
 idx:11.1444
 go:11.0181
 while:10.9373
 //:10.932

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case ?
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case ?
 
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case ?
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case ?
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case ?
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:19.3283
 h:14.4579
 p:13.4516
 t:13.3255
 idx:13.116
 x:12.118
 n:12.0489
 l:12.0115
 (:11.9398
 :11.6915
 list:11.3809

:11.3768
 is:11.244
 match:11.18
 go:11.1275
 in:10.6654
 length:10.6013
 *:10.5549
(:10.2177
xs:10.1097
 !:10.0315

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: xs
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.5456
 :18.0082
 of:15.4875
,:15.4608
 |:14.5921
  :14.5776
 in:13.2682
    :13.0047
 with:12.4457
 match:11.951
 =>:11.8664
 {:11.6988
        :11.6927
                :11.5565
      :11.5387
::11.4917
   :11.4212
 ->:11.2851
 as:11.276
 end:11.2312
 =:11.1472

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs


Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :21.6717
         :19.2517
        :16.9525
	:16.1659
           :16.0362
     :15.454
      :15.4474
          :15.3305
   :14.7695
             :14.3216
            :14.1112
    :13.8481

:13.4405
  :13.4037
#:13.2713
               :13.0901
                :13.0066
              :12.4183
|:12.4152
 :12.3545
 |:11.2865

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
       

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:23.4108
 #:14.611
 ||:13.6115
 match:12.9835
 p:12.6382
 //:11.7455
 when:11.6745
 (*:11.5707
 if:11.5097
 case:10.9046
 *:10.8198
 ##:10.5781
 /*:10.5722
 end:10.4985
 ,:9.98718
 ?:9.81187
 #[:9.8059
 {:9.73257
 |\:9.69384
 (:9.53244
 []:9.47782

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        |

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | ? => ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 []:21.3996
 x:17.8137
 h:17.5329
 y:14.1977
 _:14.1429
[]:14.0967
 [],:13.9582
 [:13.3397
 (:12.9166
 :12.298
 l:11.7531
 z:11.6422
 e:11.4794
 p:11.4752
 a:11.4038
 v:11.332
 t:10.9843
  :10.9517
 nil:10.9151
 [_:10.8725
 ((:10.8469

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | []

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | []
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: []
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | ":" | "::" | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:21.423
 ->:14.1575
    :13.6745
=>:13.63
      :13.1958
 :13.0641
  :13.0581
         :12.9841
        :12.6169
          :12.505
           :12.3936
                :12.3676
            :12.1354
   :12.1161
 :=:12.0471
     :12.0074
             :11.8805
       :11.7293
 :::11.6787
 ||:11.4282
              :11.3824

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] =>

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 -:16.7918
 (-:13.8873
 idx:13.0307
 ~:12.7258
 None:12.3211
 fail:12.1169
 :11.8796
 raise:11.7837
 index:10.402

:10.3355
 not:10.2564
 Int:10.1262
 error:10.0777
 -(:10.0705
 false:9.80622
 {-:9.69487
 i:9.6899
 neg:9.6573
 [-:9.63124
 return:9.61652
 (:9.50292

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <-<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Negation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Integer Negation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: -
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: -
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
1:21.2261
 :17.1849
2:14.0116
idx:13.4353
l:12.5601
0:12.0859
i:11.4192
!:11.3941
  :11.2475
9:11.193
 idx:11.0505

:10.9584
3:10.9534
4:10.519
one:10.4344
 (:10.3206
 l:10.1599
5:10.1368
~:9.712
6:9.64471
 i:9.22567

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: 1
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= completions | new-tokens

Top 20 Logits:

:19.1247
 :15.5655
  :13.8934
    :12.9581
 #:12.7687
;:12.7139
        :12.6487
                :12.5517
 //:12.2793
 (*:12.1973
:::12.1882
      :12.1721
 |:12.1168
 end:11.9982
 :::11.846
            :11.7155
   :11.6927
 +:11.505
         :11.4526
          :11.2782
       :10.9309

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1


Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
       :22.2653
	:15.8607
        :15.7333
         :14.9345
      :14.8928
   :14.1681

:14.1132
    :14.0374
#:13.9564
           :13.8895
          :13.7126
     :13.7014
            :13.078
  :13.0359
|:12.5829
                :12.2713
             :12.1716
 :12.0985
               :11.8768
  :11.0692
              :10.8531

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
       

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.6696
 #:14.023
 end:13.1162
 //:12.7002
 p:12.6823
 case:12.6174
 when:12.5212
 if:12.3442
 match:12.1229
 (*:11.6693
 ||:11.1766
 (:10.8626
 in:10.7876
 /*:10.7123
 else:10.3501
 ...:10.1794
 x:10.0949
 ##:10.0715
 elif:9.95842
 *:9.67007
 index:9.58158

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        |

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| ? => ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 h:20.5834
 x:19.0844
 y:16.2011
 a:14.4118
 _:14.1795
 [:13.5732
 e:13.4098
 head:13.2643
 z:13.2005
hd:12.8254
 l:12.706
 p:12.6052
 t:12.4816
 (:12.4803
 f:12.4189
 v:12.4034
 el:12.213
 elem:11.9135
 i:11.7508
 c:11.7441
 xs:11.688

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | h

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | h
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <h>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {h: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| h => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| h => ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| h => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| h => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| h => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: h
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: h
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "=>"
root ::= completions | new-tokens

Top 20 Logits:
d:22.1096
:::17.7276
dx:14.1605
 :::13.6078
x:12.4183
dr:12.2098
s:10.8204
ds:10.7361
t:10.5427
,:10.5295
@:10.312
di:10.2094
ed:10.1831
dl:10.0896
::10.0668
p:9.98402
l:9.91991
h:9.82255
_:9.82122
dd:9.79265
1:9.62933

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <hd>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd => ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: hd
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: hd
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "=>"
root ::= completions | new-tokens

Top 20 Logits:
:::22.6246
 :::17.0862
,:12.8857
::12.7731
@:12.3244
 +:11.7679
|:11.2126
_:11.1691
 &:10.6859
 ::10.6286
1:10.4102
 as:10.2092
 =>:10.1572
 @:10.0946

:9.95206
 ->:9.93346
':9.82398
 |:9.79996
#:9.6149
[:9.32809
+:9.24946

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: ? => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ::
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
tl:19.6664
_:16.1752
xs:14.8896
[]:13.3977
tail:13.0826
 t:12.9183
ts:11.3504
rest:11.3322
 _:11.2533
t:10.2818
xl:10.1315
td:9.92362
tt:9.88502
(_:9.88397
hd:9.86293
ys:9.74027
[_:9.73585
tn:9.43976
tp:9.43594
hs:9.43499
x:9.42725

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: tl
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: tl
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "=>"
root ::= completions | new-tokens

Top 20 Logits:
 =>:18.4772
 when:17.2607
 ->:17.1987
 if:14.7423
 :13.0044

:12.9712
 as:12.1468
,:12.0278
=>:11.9553
->:11.7295
 :::11.3321
 =:11.2152
 <-:10.7557
 where:10.1933
 :=:10.0165
 |:9.99206
  :9.84271
 ==:9.51429
 -->:9.41198
 →:9.39836
 ==>:9.39756

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl =>

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:19.3771

:16.8681
 :16.0375
 p:14.7949
 match:13.474
 (:13.4204
 case:13.0109
  :12.5736
 go:12.1854
 idx:12.1542
 let:12.1147
 h:11.6093
if:11.2066
    :10.9114
 is:10.6942
 If:10.5347
 begin:10.0241
 ?:9.99055
 {:9.825
 ((:9.82461
 when:9.77134

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if ? then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if ? then ? else ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if ? then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if ? then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if ? then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 p:18.7262
 (:14.5899
(:14.035
 h:13.5151
 idx:13.4749
 not:13.0915
 !:12.8014
 true:11.9043
 :11.8488
 @:11.6552
 is:11.5894
p:11.278
_:11.0314
 go:10.7993
 f:10.787
 x:10.7753
 eq:10.4253
 equal:10.424
 ?:10.421
  :10.323

:10.2783

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (Int -> Bool)
  LSP: Info: Error Status: (Exp
   (Common (Inconsistent Expectation {ana = Bool; syn = (Arrow (Int, Bool))})))
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p then ? else ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  p
Nature of error: Expecting type Bool but got inconsistent type (Int -> Bool)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "i"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= completions | new-tokens

Top 20 Logits:
(:21.8333
 h:16.1047
 (:14.2996
 ==:12.6177
 x:12.1967
.:12.1067
.(:11.8829
?(:11.638
[:11.4131
((:11.333
,:11.1171
!(:11.0519
():10.9549
 =:10.9432
(@:10.55
([:10.5014
 t:10.4581
=:10.4338
@:10.4247
 @:10.1465
(*:10.0386

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(?) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
hd:23.0876
idx:17.5059
x:15.1139
h:13.4764
head:13.4599
xs:13.2266
hs:12.5132
index:12.3312
i:12.1567
 h:12.1464
0:11.5835
p:11.4458
hl:11.2108
f:11.0177
acc:10.9396
elem:10.8792
fd:10.8223
a:10.7101
ht:10.5326
t:10.4032
hed:10.2677

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <hd>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Int
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: hd
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: hd
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):21.4653
),:15.7969
);:14.5666
)=:13.5997
,:13.4871
){:13.4214
)::12.924
)?:12.8829
 ):12.8035
 =:12.242
).:11.7998
 ==:11.6982
 as:11.383
=:11.3271
.:11.0881
)(:10.8963
)->:10.8665
 +:10.8159
 then:10.8128

:10.6633
)):10.566

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd)

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:18.5876
 :15.1146

:15.0293
 ==:14.7448
 {:13.4641
 &&:13.3334
 idx:13.0367
 =:12.9099
 ||:12.7177
 ?:11.7175
 !=:11.6612
 p:11.2288
 is:11.126
 index:10.9762
 true:10.574
 >:10.5206
 ret:10.4413
 eq:10.3153
  :10.3136
 h:10.2707
 >=:10.1539

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then ? else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 idx:18.7786
 h:12.768
 :12.7166
 index:12.4803

:12.2581
 go:11.8588
 id:11.8416
 (:11.8038
 i:11.7487
 return:11.1124
 acc:10.7417
 x:10.6608
 Some:10.472
idx:10.3045
 t:10.1877
 {:10.1695
 int:9.89124
 find:9.58648
 p:9.56391
 f:9.52731
 ~:9.49545

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <idx>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: idx
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: idx
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:19.3718

:14.4611
 :13.2775
 elif:11.7801
 end:11.2779
 +:11.1227
;:10.2481
  :10.1015
 els:9.78816
 otherwise:9.22567
    :8.89871
 |:8.80614
 *:8.79813
 el:8.78938
,:8.74667
+:8.55871
else:8.43942
 \:8.38591
   :8.27116
 -:8.10915
 #:8.06914

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else ?
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else ?
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else ?
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 go:18.3843
 find:14.3135
 (:12.8415
 :12.6728

:12.3182
 idx:11.6109
 t:11.5235
 h:10.7083
 next:10.4729
 index:10.2874
 f:10.0073
 -:10.0049
 @:9.79735
 n:9.67371
 g:9.66932
 if:9.60727
 let:9.55073
 rec:9.44203
 id:9.34351
 end:9.17614
 x:9.12104

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <find>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: find
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: find
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
(:16.8529
_:14.8367
((:11.9412
():11.087
 (:10.7855
 p:10.5561
p:10.5514
2:10.1144
(@:10.0769
go:10.0215
.:10.0083
 t:9.94614
Index:9.85538
 go:9.82499
i:9.53852
.(:9.26181
[:9.23807
(&:9.2373
1:9.13782
_(:9.09802
(?:9.07191

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
p:18.2812
idx:15.5929
xs:15.2714
hd:13.7414
tl:13.111
go:12.8761
x:12.2113
f:11.9601
td:11.806
t:11.4798
hs:11.3497
hl:11.0335
h:10.5449
pred:10.4324
fun:10.2507
0:10.1354
tail:9.81595
index:9.74589
1:9.66215
fn:9.58154
id:9.52553

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <p>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: (Int -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [(Arrow (Int, Bool)); (List Int)]);
           syn = (Arrow (Int, Bool))})))
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  p
Nature of error: Expecting type ((Int -> Bool), [Int]) but got inconsistent type (Int -> Bool)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: p
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: p
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "i"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:19.1328
)(:14.7078
 ,:13.3379
 t:12.416
):12.0773
(:12.0129
,(:11.4253
),:11.3586
::11.2523
.:10.653
(),:10.1614
 x:10.0837
:::9.88847
 =:9.80416
 @:9.72748
=:9.72572
@:9.58811
[:9.52894
.(:9.52709
 +:9.46793
)::9.43081

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p,

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Seft type: ((Int -> Bool), [Int])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, ?)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "hd" | "idx" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "tl" | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 t:19.3237
 idx:14.9633
 xs:14.94
 h:13.6809
 x:13.0701
xs:12.1707
 tail:12.1427
 acc:11.3603
 go:11.3388
 id:11.2924
idx:11.1857
tl:10.9573
 f:10.9423
t:10.9316
 :10.7823
 index:10.7738
 [:10.6714
 (:10.5573
 rest:10.5409
 l:10.3322
 ts:10.0549

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, t

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, t
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "t"))
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, t)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  t
Nature of error: Variable t is not bound  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, t)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, t)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, t)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, t)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: t
LSP: Generating Completions for prefix: t
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "an" | "est " | "l" | "rue" | "ype "
root ::= completions

Top 20 Logits:
l:21.7726
1:13.1537
ls:11.5914
):11.1112
L:11.0021
ld:10.2981
t:10.1552
b:10.0231
la:9.80295
,:9.7045
I:9.5358
 l:9.27718
n:9.17951
2:9.15767
 +:9.14861
)(:9.12979
tl:8.97424
[:8.90862
:::8.78287
g:8.75966
(:8.74697

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Int]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((Int -> Bool), [Int])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: tl
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: tl
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: tl hd xs idx xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):18.2612
,:16.3382
),:14.1693
 end:14.0493
);:14.0057
 +:12.954
)(:12.4729
)):12.3263
 -:12.0716
).:11.7133
 ):11.4792
)]:11.2076
)[:11.1243
)::11.0487
 @:11.0323
)|:10.8248
)?:10.266
 ,:10.2438
 |:10.0878
 &:9.95592
)+:9.89699

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl)

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {tl: [?], hd: ?, xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:17.3396
 +:13.0912

:13.0574
 in:11.9909
 -:10.9587
 :10.6589
 else:10.167
 |:9.55502
 idx:9.55447
 ::9.51915
 @:9.33493
 (+:9.30805
 (-:9.26341
 and:8.94012
 =:8.86212
 >:8.81715
 ->:8.81039
 ++:8.67146
 &&:8.60797
 ==:8.57912
 ?:8.51054

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {xs: ?, idx: ?, xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (Int, ([Int] -> Int))
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:18.0737

:15.2363
 :12.8982
 end:12.4253
;:10.9692
 fun:10.5534
in:10.2451
  :10.2394
 if:10.1508
 and:10.0241
 +:9.9791
 x:9.76015
,:9.55159
):9.26364
 &&:9.24298
():9.09526
 return:8.76207
 ->:8.74328
    :8.66988
 idx:8.63921
.:8.56658

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.413
 :15.6189
  :14.4392
    :14.0452
 go:13.6817
        :13.074
      :12.3503
   :11.7872
            :11.628
                :11.4517
          :11.3618
     :11.2655
         :11.0771
       :10.5016
	:10.301
 #:10.0326
 //:9.98804
           :9.71845
 \:9.4974
 (:9.38646
              :9.32631

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in


Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :17.7307
 :15.7349
     :14.9991
       :14.9705
go:14.5948
    :13.9147
  :13.5524

:13.4402
         :12.9027
        :12.6363
      :12.3097
           :11.8155
in:10.9195
	:10.8064
          :10.4418
 go:10.4185
                :10.2836
let:10.2426
end:10.0007
               :9.957
             :9.92154

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
   

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 ? in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 go:19.0923
 case:14.5332
 fol:14.1917
 if:13.4947
 match:13.3719
 let:13.1747
 in:12.4895
 #:12.332
 find:12.2169
 (:11.7802
 rev:11.5231
 h:11.438
 xs:11.04
 index:10.8958
 end:10.7403
 idx:10.7391
 n:10.2483
 f:10.1878
 |:10.0927
 map:10.0769
 fun:10.058

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: (Int, ([Int] -> Int))
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Int;
           syn = (Prod [Int; (Arrow ((List Int), Int))])})))
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: Expecting type Int but got inconsistent type (Int, ([Int] -> Int))  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
(:20.0904
 :15.6538
 (:15.1258
(-:14.8489
((:12.9954
 in:12.3573
([:12.0693

:11.8375
_:11.7057
():11.5689
[:11.4214
 (-:11.2342
(_:11.1701
 end:11.1005
(?:10.7831
.(:10.5331
 xs:10.2889
(":10.2395
 index:10.2195
,:10.1485
.:10.0973

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: type (Int, ([Int] -> Int)) is not consistent with arrow type  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: type (Int, ([Int] -> Int)) is not consistent with arrow type  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: type (Int, ([Int] -> Int)) is not consistent with arrow type  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
0:20.9729
idx:16.3498
xs:16.256
1:14.286
length:13.1433
hd:12.5896
 :12.3755
len:12.3135
index:12.2385
x:11.6371
find:11.5804
p:11.4601
2:11.394
_,:11.2647
f:10.8069
i:10.5687
hs:10.5271
3:10.3111
o:10.2645
,:10.0945
acc:10.0113

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: type (Int, ([Int] -> Int)) is not consistent with arrow type  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Integer literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: 0
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-floatlit | extend-intlit
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:19.6352
 ,:13.5659
):12.7114
 xs:11.7692
)(:11.4692
::11.1795
:::11.058
 x:11.0452
.:11.0227
,[:10.973
 :::10.9667
),:10.7304
.,:10.2855
x:10.2782
_:9.88118
L:9.689
);:9.45601
xs:9.38301
 +:9.23169
,(:9.20465
,,:9.20363

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0,

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: type (Int, ([Int] -> Int)) is not consistent with arrow type  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (Int, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: type (Int, ([Int] -> Int)) is not consistent with arrow type  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: type (Int, ([Int] -> Int)) is not consistent with arrow type  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, ?) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "p" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | "xs" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 xs:18.8949
xs:14.3739
 l:13.4485
 x:13.3911
 :12.3588
 rev:12.3301
 list:11.6629
 h:11.3625
 acc:11.2797
 [:10.9909
 ls:10.7205
 p:10.5048
 f:10.4089
 t:10.3727
 fol:10.3029
 y:10.1917
 head:10.0683
 s:9.99962
 reverse:9.91407
 a:9.67582
 cons:9.61434

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0, xs

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0, xs
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <xs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [Int]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: type (Int, ([Int] -> Int)) is not consistent with arrow type  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: xs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: xs
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: go xs p find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
):20.0261
);:15.1342
,:12.888
 ):12.6169
),:12.458
)):12.3724

:12.3625
[:12.0488
 in:11.7463
).:11.6531
.:11.3817
 -:11.1963
)[:11.1137
)::10.742
)`:10.4764
 end:10.3974
)(:10.3156
)->:10.1495
 :9.99015
));:9.96536
::9.92725

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0, xs)

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0, xs)
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: (Int, ([Int] -> Int)), xs: [Int], p: (Int -> Bool), find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: type (Int, ([Int] -> Int)) is not consistent with arrow type  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((Int -> Bool), [Int]) -> Int)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:15.8591

:13.8612
 end:13.8439
 :13.0425
in:10.3828
end:10.0105
  :9.92112
 -:9.45961
    :8.84503
 and:8.75651
 #:8.31994
   :8.25603
                :8.08402
 +:8.06779
        :7.38377
 |:7.22691
      :7.21069
     :6.74994
 *:6.67855
 //:6.62746
	:6.59645

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0, xs) in

Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0, xs) in
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: type (Int, ([Int] -> Int)) is not consistent with arrow type  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Broken expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.9046
 :14.9861
  :13.3146
    :13.0119
      :11.1849
   :10.9147
        :10.9087
                :10.7373
;:10.4031
            :10.1293
 #:10.0248
     :9.94586
          :9.73513
         :9.39097
	:9.37135
       :9.23689
`:9.03916
           :8.76496
              :8.68711
             :8.43134
 //:8.40454

================
# Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0, xs) in


Debug: true, Constrain: Context
LSP: New token mode: # Find the index of the element satisfying a given predicate function.
Return -1 if not found #
let find: (Int -> Bool, [Int]) -> Int =
  fun p, xs ->
    let go: (Int, [Int] -> Int) =
      fun idx, xs ->
        case xs
        | [] => -1
        | hd::tl => if p(hd) then idx else find(p, tl) end in
    go(0, xs) in

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {find: (((Int -> Bool), [Int]) -> Int), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else
  LSP: Info: ALL errors:
Error in term:
  not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  found
Nature of error: Variable found is not bound  
Error in term:
  fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end
Nature of error: Expecting type (Int, ([Int] -> Int)) but got inconsistent type ((?, ?) -> Int)  
Error in term:
  # Find the index of the element satisfying a given predicate function. Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  go
Nature of error: type (Int, ([Int] -> Int)) is not consistent with arrow type  
Error in term:
  Return - 1 if not found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ? then ? else ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  Return
Nature of error: Constructor is not defined  
Error in term:
  found let find : ((((Int -> Bool), [Int])) -> Int) = fun (p, xs) ->
 let go : ((Int, ([Int] -> Int))) = fun (idx, xs) ->
 case xs
 | [] => -1
| hd :: tl => if p(hd) then idx else find(p, tl)
end in
 go(0, xs) in
 ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)  
Error in term:
  # Find the index of the element satisfying a given predicate function.
Nature of error: "# Find the index of the element satisfying a given predicate function." isn't a valid token  
Error in term:
  not
Nature of error: Variable not is not bound
  LSP: Info: BidiCtx: Cls: Broken expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: find string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "S" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "find" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.7836
    :16.33
  :15.2628
 :14.6473
        :14.125
#:14.0728
let:13.4585
in:13.0973
      :13.0804
```:13.073
   :12.8532
                :12.2327
            :12.0374
rev:11.5639
          :11.4651
	:11.4112
     :11.247
       :11.2211
print:10.8904
         :10.6596
//:10.5121
