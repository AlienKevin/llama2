
================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
LSP: Get Zipper: No serialized zipper, processing string
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.8923
 :16.8743
 fun:16.2063
  :12.6348
    :12.2755
 (:11.6181
 function:11.4151
                :11.2449
     :10.7623
   :10.4707
 model:10.4662
 #:10.2338
 {:10.1432
        :10.1233
      :9.92043
            :9.70583
 match:9.68469
	:9.53003
       :9.51699
 \:9.47726
fun:9.33837

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =


Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 :20.9595
   :17.7167
fun:17.4873
 fun:15.2869
  :14.7524
	:13.8541
let:13.7945
     :13.6269
       :13.378
func:13.3495

:13.2844
    :12.8592
match:12.2853
 let:12.061
function:11.5891
#:11.4395
fn:11.2279
lambda:10.9843
(:10.8187
{:10.7896
      :10.6143

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
 

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
 
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Model, Action) -> Model)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 fun:20.8602
 let:15.5422
 (:12.6022
 #:12.5926
 match:12.4167
 function:12.3093
 {:11.4906
 model:11.4471
 fn:11.2344
 func:11.205
 |:11.1555
 lambda:11.1468
 switch:11.1056
 (*:10.9991
 if:10.6491
 f:10.4151
 //:10.4105
 self:10.2281
 mut:10.1118
 @:10.1028
 action:10.0149

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 model:18.2914
 (:17.1016
 m:17.047
 ((:15.4228
 state:14.723
 ({:14.5041
 old:13.5074
 {:13.4372
 s:13.1296
 prev:13.0661
 x:12.6639
 xs:12.6296
 current:12.5798
 st:12.5384
 md:12.0887
 t:11.9675
 ms:11.886
 todo:11.5963
 p:11.4295
 mod:11.2987
 self:11.2826

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: (Model, Action), update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: model
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:18.2743
 action:14.6089
 ->:12.7861
@:12.6757
 ,:12.4523
_:12.3021
::11.3335
_,:11.0988
 state:10.997
0:10.7654
 =:10.5259
',:10.5245
1:10.3645
 as:10.2779
 ::10.0663
,(:10.0454
 (:9.94864
->:9.86296
 x:9.81007
 @:9.75854

:9.75829

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model,

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (Model, Action)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Model, Action)
  LSP: Info: Seft type: (Model, Action)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 action:19.9768
 act:16.1743
 msg:15.1436
 a:14.2192
 message:13.1355
 x:12.0111
 todo:11.7661
 actions:11.6941
 ac:11.5107
 cmd:11.3833
 event:11.3341
action:11.2446
 (:11.1796
 {:11.1427
 _:11.0591
 t:10.7208
 e:10.4759
 new:10.4579
 input:10.3127
 m:10.1115
 Action:9.99028

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Model, Action)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.8634
->:14.2698
 =>:13.5725
 :13.0187

:11.6561
::11.5889
_:10.7568
$:10.6654
':10.6257
 =:10.451
 ::10.4021
,:10.2974
 -:10.1061
 -->:10.0227
 →:9.90369
0:9.81866
?:9.80844
 {:9.70059
 |:9.39859
 +:9.29967
 ?:9.17168

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.9228
 :16.1357
 case:14.4051
  :13.9315
 match:13.843
    :13.2554
 {:12.697
                :12.2012
 model:12.0409
 switch:11.7966
        :11.6857
 if:11.3714
   :11.3311
     :11.2321
            :10.9735
 let:10.9653
      :10.964
 (:10.9049
 action:10.7798
 #:10.6944
         :10.6839

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->


Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
   :19.6673
 :18.2672
     :17.0268
  :16.0446
       :16.0351
    :15.4862
match:15.3656
case:15.2903

:14.7108
         :13.8966
switch:13.8507
      :13.4547
	:13.2996
let:13.1651
           :13.0133
if:12.7725
        :12.633
 match:12.4579
model:12.1125
 case:11.5452
                :11.4214

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
   

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 case:18.9028
 match:15.9065
 let:15.8725
 switch:13.9621
 model:12.4103
 print:12.259
 if:11.8454
 var:11.5376
 #:11.4825
 (:11.4128
 Model:10.6179
 action:10.5659
 {:10.4739
 fun:10.1792
 printf:9.86682
 todo:9.76055
 Tod:9.75637
 un:9.7137
 open:9.64101
 update:9.56973
 //:9.34405

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:18.285
 model:16.9956
 (:13.4037

:11.4874
 :11.432
 List:10.9703
 {:10.6897
 actions:10.5123
 to:10.1814
 Action:10.1803
 todo:10.1771
(:10.0866
 [:9.93497
 Model:9.71927
 update:9.71917
 &:9.63579
 Tod:9.63404
 let:9.60751
::9.60308
 ::9.39682
 *:9.36239

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Action
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Generating Completions for prefix: action
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.4445
 :16.7939
 of:14.4861
,:14.0129
  :14.0024
 with:13.9122
 |:13.0093
    :12.963
 in:12.7559
::12.7412
 {:12.5282
      :11.8398
 ::11.6161
                :11.4806
     :11.4519
;:11.1634
 match:11.1546
   :11.1277
 as:10.9971
        :10.8742
 end:10.8351

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action


Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Action
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
   :18.9262
     :16.5208
    :15.8384

:15.0057
       :14.5589
  :13.6668
      :13.1945
        :13.1644
 :13.1453
|:12.2699
#:12.0372
	:11.8863
         :11.781
 |:10.7945
           :10.5345
          :10.5206
            :10.3811
                :10.3108
             :9.87535
(*:9.1614
               :8.83021

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
   

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Action
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.1124
 #:17.0497
 +:14.3703
 ~:13.6224
 (*:12.857
 ##:12.7422
 //:11.9503
 {:11.9293
 /*:11.8837
 #{:11.6226
 %:11.4658
 ||:11.4413
 when:11.2973
 #[:11.1951
 @:11.1533
 --:11.086
 match:11.0856
 !:11.0006
 /:10.7056
 *:10.6827
 ###:10.6268

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    |

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    |
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 Add:19.4422
 Update:15.0357
 Remove:14.802
 T:14.108
 _:13.2822
 +:13.0026
 (:12.3772
 @:12.3383
 Action:11.9519
 Tod:11.9097
 #:11.5613
 _,:10.7305
 :10.651
Add:10.6287
 Clear:10.5421
 ~:10.4581
 {:10.2802
 ::10.1578
 !:9.92648
  :9.89337
 add:9.76093

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | Add

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | Add
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Add>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Add"))))
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Add
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Add
LSP: Generating Completions for prefix: Add
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Todo"
root ::= completions

Top 20 Logits:
T:22.4124
t:11.8268
 =>:11.6254
To:11.5565
New:11.3407
 ->:11.2051
():11.0524
(:10.6854
Action:10.6607
_:10.6595
 Tod:10.2977
Item:10.0541
Text:9.99096
 todo:9.87829
(_:9.81357
TO:9.38317
Token:9.14474
 if:9.05553
($:8.58546
String:8.54949
 new:8.44628

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddT

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddT
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddT>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "AddT"))))
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  AddT
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: AddT
LSP: Generating Completions for prefix: AddT
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "odo"
root ::= completions

Top 20 Logits:
odo:26.5825
odos:15.6929
od:15.5987
oto:15.4276
udo:13.9659
odd:13.2725
ogo:13.1299
do:12.5691
ono:11.6563
d:11.6182
odio:11.33
oco:11.1355
oko:10.8383
oda:10.716
ok:10.6904
ao:10.5835
oo:10.5201
omo:10.4732
dd:10.4584
os:10.3475
rio:10.3249

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddTodo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Action
  LSP: Info: Seft type: Action
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Action
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: AddTodo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: AddTodo
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.5418
 ->:14.216
 when:13.9121
 if:12.9078
():11.9606

:11.809
     :11.4172
       :11.3556
      :11.2598
         :11.2069
    :11.1633
 :11.1148
 {:10.9902
=>:10.9052
 as:10.8928
        :10.8895
  :10.7117
                :10.6293
          :10.5667
 _:10.5159
   :10.3049

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:17.1376
 :15.4488
 if:15.0444
 (:14.5494
 let:14.4365
 model:13.9421
 {:13.5812
 (":13.4194
 List:12.8451
  :12.8202
 match:12.8105
 Model:12.3653
 case:12.0699
    :11.9961
                :11.8474
 ({:11.8159
 update:11.2963
 (*:10.9857
 ((:10.9836
     :10.878
        :10.8706

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>


Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :20.2483
     :19.7745
      :15.6583
         :15.3629
   :14.815
        :14.6007
           :14.5206
    :13.5933
	:13.2761
          :12.0501

:11.893
               :11.8842
             :11.7984
                :11.3709
            :11.2047
#:10.7443
 :10.5855
  :10.4901
              :10.4032
if:10.0719
let:9.92609

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
       

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 let:19.6767
 if:18.8403
 (:16.6513
 case:16.4821
 match:16.1089
 (":15.7585
 model:15.3787
 {:15.1776
 #:15.0762
 List:14.9968
 Model:14.0852
 fun:13.8687
 (*:13.8188
 ((:13.7189
 ({:13.5189
 Tod:13.5083
 !:13.4169
 todo:13.2038
 String:12.9686
 ":12.9596
 assert:12.8293

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 buffer:13.1993
 new:13.0668
 (:12.4195
 description:12.1798
 desc:11.9744
 b:11.4867
 todo:11.3336
 {:11.2096
 buf:11.0326
 xs:10.9635
 add:10.6965
 t:10.6328
 trim:10.586
 d:10.4494
 todos:10.4275
 len:10.341
 text:10.2765
 model:10.2177
 s:10.1542
 next:10.1501
 x:9.95789

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: ?, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:16.6351
 =:16.2415
_:15.3112
::13.8075
$:12.8911
 ::12.6306
_,:12.4295
':12.4011
 $:12.3195
',:12.0491
ed:11.589
:::11.5786
 :=:11.373
@:11.2361
 :::11.1795
 ,:11.0916
 @:10.6734
=:10.5136
     :10.5107
  :10.3979
$,:10.2941

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer,

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: ?, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: ?, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {buffer: ?, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 todos:16.2822
 todo:14.1835
 _:13.7124
 ts:12.6007
 list:12.3805
 xs:12.3473
 t:11.7936
 items:11.6485
 old:11.4224
 rest:11.1469
 to:10.7799
 tod:10.7651
 tasks:10.6641
 state:10.4145
 l:10.13
 other:10.0868
 lst:10.0001
 ls:9.93212
 current:9.84552
 _,:9.80974
 new:9.67598

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: ?, buffer: ?, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:18.7782
_:14.0918
':13.4351
 :13.0158
=:13.0088
$:12.9453
 ::12.6323
,:12.4826
::12.2258
 :=:12.1101
 $:11.4113
 ->:11.2192
0:11.1996
1:10.8979
  :10.7805
 =>:10.7393
 :::10.7008
 as:10.5853
 in:10.5358
@:10.4809

:10.4254

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos =

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos =
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 model:17.6188

:12.7903
 Model:12.3822
 match:12.377
 un:11.8862
 :11.5646
 (:11.4151
 !:11.3967
 List:11.2633
 Tu:11.227
 f:10.5237
 get:10.5016
 destruct:9.94047
 split:9.85071
 let:9.7972
 s:9.38265
 if:9.35255
 @:9.2645
 $:9.14548
 case:9.13267
 String:9.10344

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: model
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 in:16.7949

:14.3702
 :12.4059
.:11.4927
 $:11.1276
,:10.7929
;:10.4036
.(:9.92845
 with:9.88846
                :9.67837
 and:9.58955
():9.55742
 @:9.45092
 #:9.30145
 end:9.2934
  :9.24826
[:9.09504
!:9.02633
$:9.01374
 !:8.90713
($:8.7357

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:18.6102
 :15.4601
  :13.5407
    :13.1712
 {:12.8679
                :12.2057
      :11.9545
     :11.9067
        :11.8952
            :11.7128
   :11.6624
 (*:11.531
 #:11.347
         :11.1332
 (:10.9458
          :10.8211
 if:10.5192
             :10.4953
           :10.3947
 let:10.2915
       :10.2894

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in


Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
       :17.9208
           :15.2027
        :14.6136

:14.4664
         :13.7483
     :12.7547
      :12.0355
            :11.6728
	:11.4941
    :11.4046
          :11.1789
   :10.7576
                :10.7354
               :10.7001
             :10.1805
 :9.47654
  :9.29819
#:9.20899
              :9.07548
(:8.96174
(*:8.84595

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
       

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
       
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 if:19.1147
 let:17.4669
 (:17.2371
 (":16.6232
 case:15.6755
 (!:15.2231
 match:14.9924
 ((:14.7034
 buffer:14.6545
 List:14.6467
 !:14.2791
 {:14.0269
 (*:13.9239
 ({:13.8051
 #:13.7402
 ([:13.5171
 Model:13.3607
 Tod:12.9585
 model:12.9315
 todo:12.8504
 ":12.8006

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 String:14.7545
 buffer:14.6812
 !:14.4319
 List:14.0881
 not:12.7382
 $:12.1226
 "":12.1019
 (:11.7503
 Str:10.7753
 length:10.5289
 is:10.2275
 todo:10.1865
 Buffer:10.1564
 Model:10.1323
 ":10.0956
 Text:10.081
 model:9.9808
 Tod:9.96279
 (!:9.96094
 trim:9.8383
 str:9.7564

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = String})))
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Bool but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 $:16.5847
 ==:16.2983
 !=:14.7341
 !:13.6933
 <>:13.5861
 ===:13.4147
.:12.6511
 =:12.4916
 !==:11.9892
 is:11.8278
 /:11.6737
 "":11.6415
 |:11.329
 ?:11.3134
$:11.2888
 ~:11.1571
 >:11.0071
 =~:10.9842
 ^:10.9331

:10.709
 <:10.5523

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >$<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  buffer ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)
  LSP: Info: BidiCtx: Cls: Broken expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Broken expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType MultiError)))
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  buffer ?
Nature of error: Incomplete syntax (possible cause: remember that function application is c-style and requires parentheses around the argument)
  LSP: Info: BidiCtx: Cls: Broken expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: $
LSP: Generating Completions for prefix: $
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "=="
root ::= completions

Top 20 Logits:
==:18.1692
!=:15.7765
=:14.8183
!:13.6248
<>:12.6871
<:11.7235
~:11.6318
>:11.5815
/:11.56
==":11.4782
===:11.4682
<=:10.8952
=>:10.675
!!:10.2348
||:10.088
^:9.86799
="":9.75495
->:9.62357
~~:9.5616
"":9.51107
:::9.47585

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $==

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $==
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >$==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: String Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: String Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: String Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: String Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: String Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: $==
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: $==
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 "":19.8913
 ":12.5723
 '':12.52
 "\:11.9389
 String:11.7025
 []:11.5403
 nil:11.2257
 (":11.1809
!:11.1445
"":10.8606
 :10.8203
 "",:10.5341
="":10.4629
 ""):10.428
 empty:10.3274
 [":10.2941
 then:10.1849
 """:10.0599
 !:10.0302

:9.95556
 null:9.94085

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== ""

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== ""
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <"">
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: String literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: String
  LSP: Info: Seft type: String
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: String Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: ""
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: ""
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:19.5356

:17.9088
 :17.0661
 ||:16.0504
 &&:13.3479
  :13.1876
 {:13.0649
 //:12.2444
 #:12.047
    :11.9476
 |:11.7293
                :11.6148
 (*:11.6038
        :11.3333
 ?:11.2916
 =:11.2377
     :11.1903
      :11.1504
 ():11.1192
 <>:11.0364
            :10.9405

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 model:16.8945

:15.5341
 :13.806
 (:13.436
 {:12.9572
 []:12.381
 ():11.7259
 List:11.0676
 {}:10.8145
 [:10.5007
 return:10.4119
  :10.2846
 ([:10.2447
 (":10.1783
 Model:10.0885
 ({:9.85934
 [],:9.75229
 fail:9.71444
 None:9.6805
 ~:9.66956
 todo:9.65382

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <model>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: model
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: model
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "else"
root ::= new-tokens

Top 20 Logits:
 else:18.4602

:16.7721
 :14.3749
  :12.0572
    :11.7363
        :11.442
                :11.2191
 #:10.6972
            :10.6806
      :10.5851
 @:10.5492
     :10.5461
 els:10.4827
 //:10.4628
   :10.3766
 end:10.2399
 |:10.1974
 elif:10.182
         :9.81592
;:9.66927
.:9.65385

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 (:15.1663

:15.1246
 (":14.2407
 buffer:12.5427
 :12.165
 List:11.9629
 ((:11.8829
 ({:11.508
 ":11.2801
 {:11.2738
 model:11.1688
 ([:11.0757
(:10.4478
 "(:10.4409
 todo:10.4327
 (!:10.4115
 todos:10.2461
 let:9.91386
 Tod:9.90292
(":9.88847
 Model:9.68248

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:16.4599
 "",:14.659

:14.4946
model:13.7018
(":13.2843
String:12.1932
t:11.8611
List:11.634
_,:11.5412
[":11.5083
buf:11.0732
(),:10.6454
<:10.6066
b:10.5143
0:10.1341
f:10.0603
Model:9.84877
action:9.81956
T:9.8189
?,:9.61412
 ":9.60269

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = (Var "Model"); syn = String})))
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Model but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:17.1374
 @:13.9707
 $:12.8018
 +:12.4327
.:12.3718
 ^:12.2445
:::11.6215
 ,:10.8454
 ++:10.7438
 "",:10.6269
 :::10.5788
[:10.3856
 &:10.2774
,[:10.2318
 <>:10.0646
 ::10.0324
 =:10.0139
,$:9.97489
,":9.93134
 |:9.89267
 ==:9.88165

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer,

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: (String, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:14.9729
 todos:14.2602
 (:14.0238
 Tod:13.3511
 ((:12.4991
 [:12.3199
 (":12.3083
 buffer:12.2304
 [(:12.0818
 {:11.9675
 model:11.8011
 todo:11.7906
 [":11.5871
 ([:11.1854
 ({:10.9393
 ":10.9188

:10.3552
 [{:10.307
 cons:10.2886
 {":9.78349
 Cons:9.70352

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 @:20.1032
@:14.587
 ++:13.997
 +:13.7871
 :::13.0308
 ::12.7901
:::12.4083
 &:12.3928
.:12.2574
 <:11.8433
 <>:11.499
 ^:11.4291
 $:11.2755
 |:11.1587
::10.8807

:10.7716
 {:10.7109
 \:10.3977
:@:10.2936
 %:10.2261
@{:10.1772

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [(:18.6897
 [:15.193
 [[:12.6577
 List:12.5041
[(:12.5014
 [{:12.3732
 ((:11.2818
 (:11.2336
 {:11.0312
 ([:10.6816
 [":10.2482
 Tod:10.2257

:9.87985
[:9.71937
 [`:9.66443
 <:9.33688
 :9.13395
@:9.12391
 Tu:9.05804
 @:8.87193
 !:8.66492

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
buffer:15.7459
(":15.4683
T:14.0342
((:13.5028
 (:13.4325
<:13.1039
(!:12.8483

:12.4471
($:11.9024
|:11.8962
(:11.7754
("#:11.7727
@:11.7478
!:11.6159
!(:11.6134
Tu:11.5868
([:11.5341
buf:11.4419
String:11.3721
(@:11.3488
List:11.231

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <buffer>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: String
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = (Var "Todo"); syn = String})))
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: buffer
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: buffer
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
,:16.6894
]):15.0938
 $:12.3275
,$:12.1647
:::11.9686
;:11.6847
.:11.613
],:11.3042
 ->:11.0985
->:10.6532
 |:10.5877
 ::10.5181
 ,:10.4319
 +:10.3389
 =>:10.2885
 :::10.2632
 %:10.1547
 !:10.0406
 ^:9.97078
]:9.82625
|:9.72248

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer,

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer,
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: List Concatenation
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: List Concatenation
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: List Concatenation
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "AddTodo" | "AlignItems" | "BackgroundColor" | "Bool.eq" | "Border" | "BorderRadius" | "BoxShadow" | "Color" | "Cursor" | "Display" | "FlexDirection" | "FontFamily" | "FontSize" | "FontStyle" | "Gap" | "Height" | "JustifyContent" | "Margin" | "Model.eq" | "Model.init" | "Opacity" | "Outline" | "Overflow" | "Padding" | "Position" | "RemoveTodo" | "S" | "Todo.eq" | "ToggleTodo" | "UpdateBuffer" | "Width" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "buffer" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "model" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "test " | "todo_list_eq" | "todos" | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 false:18.7109
 true:16.9091
 False:13.9427
false:13.5049
true:11.967
 True:11.9314
 !:11.2352
 :11.0644
 _:10.9224
 (:10.7213
 ~:9.4651
 Bool:9.38237
 *:9.32916
]):9.2723
 FALSE:9.13483
 %:8.99179
 f:8.93582

:8.7472
 @:8.74155
 #:8.6416
 $:8.61037

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <false>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Boolean literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = (Var "Todo"); syn = Bool})))
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: List literal
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: List Concatenation
  LSP: Syntax: Can insert left-concave or complete: false
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: false
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos buffer action model update Model.init Model.eq todo_list_eq Todo.eq Bool.eq string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer AlignItems BackgroundColor Border BorderRadius BoxShadow Color Cursor Display FlexDirection FontFamily FontSize FontStyle Gap Height JustifyContent Margin Opacity Outline Overflow Padding Position Width S () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "]"
root ::= new-tokens

Top 20 Logits:
]):21.1849
]:15.1072
]),:12.8862
]);:12.8059
]).:12.2867
 :12.0812
],:11.9778
])):10.2149
)]:9.5393
]]:9.48359
)):9.37474
]::9.35508
 ]:9.19231
():9.13596
];:9.10235
][:9.06384
 |:8.89699
"]):8.89403
(:8.85509
,:8.81978
 ::8.72137

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false]

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false]
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= new-tokens

Top 20 Logits:
 end:15.5691
 ):15.0971
)::13.0128

:12.9625
)$:12.8392
 :11.5296
 ||:11.4937
 as:11.2638
 ::11.2021
 @:11.1215
 in:11.0348
 |:10.686
:::9.90146
 &&:9.70123
)\:9.61369
 $:9.58206
 *:9.55111
  :9.52003
end:9.23561
 ,:9.18362
))):9.1197

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] )

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] )
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], buffer: String, action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: Model
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: ( |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:18.1533

:14.8576
end:13.0022
 :12.1418
  :10.7142
 in:10.4436
 ::9.94333
 fi:9.88232
 |:9.41102
    :9.36432
endif:9.35395
   :9.28473
 $:9.22653
 else:8.7576
 @:8.57893
     :8.50407
in:8.32208
      :8.25309
        :8.21054
 ,:8.20966
 #:8.16385

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:

:18.8119
 :15.2969
  :14.5607
    :13.8919
 in:13.5785
;:13.3778
        :13.2304
 end:12.6058
      :12.5903
   :12.4908
 #:12.3408
     :12.277
                :12.2094
            :12.0315
,:11.4903
          :11.2586
         :11.2473
	:10.9066
       :10.8149
 ||:10.7986
           :10.5099

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end


Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
   :18.6036
    :16.931

:16.7603
        :15.8077
  :14.8315
     :13.8051
            :13.6647
      :13.586
                :13.2943
 :12.8754
       :12.8645
          :12.1925
	:12.059
         :11.9352
#:11.9208
           :11.337
|:11.2715
              :11.2058
             :10.7331
               :10.6147
in:10.1624

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 |:21.4497
 #:15.4303
 //:13.7746

:13.2102
 (*:13.2098
 ~:12.8157
 <:12.7918
 ||:12.7473
 end:12.2968
 !:11.9286
 /:11.8324
 ##:11.7744
 in:11.7107
 +:11.6363
 (:11.5203
 /*:11.4669
 ,:11.3126
 --:11.0223
 -:10.9937
 case:10.9143
 let:10.8928

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   


Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
   :19.1008
  :16.508
    :15.8219
#:13.9242

:13.6903
|:13.3846
 :13.2741
     :13.1368
	:12.748
      :12.496
        :12.3271
       :12.1527
            :10.8866
                :10.7222
 |:10.7183
 #:10.1908
         :10.0754
          :10.0559
           :9.81032
               :9.55064
              :9.43841

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 |:20.3661
 #:18.0086
 //:13.3325

:13.1641
 (*:12.9928
 /*:12.3303
 ##:12.0725
 ||:12.07
 /:11.8258
 let:11.6934
 (:11.5768
 <:11.3741
 +:11.2239
 --:11.2055
 (**:11.1177
 ~:11.0463
 ...:11.0453
 !:10.8817
 -:10.8506
 ###:10.7664
	:10.7317

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   


Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
   :17.4972
  :15.6566
    :15.597
#:14.1222

:13.8735
|:13.8307
     :12.8237
      :12.7551
        :12.5249
 :12.4342
       :11.843
let:11.6998
	:11.6512
                :11.6386
            :11.6172
 |:10.6801
          :10.6473
           :10.5522
 #:10.5167
end:10.4547
         :10.3176

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   
   

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 |:18.1083
 #:16.5344

:14.2288
 (*:12.5229
 //:12.1491
 let:11.7865
 ||:11.2168
 <:11.0359
 /*:11.0275
 ##:10.7186
 ###:10.7131
 end:10.4222
 --:10.3949
 /:10.3002
 (:10.2989
 elif:10.2811
 +:10.2464
 -:10.1146
 !:10.0709
 ...:10.0412
 case:10.0136

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   
   


Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   
   

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
   :16.56
    :15.6688
  :14.7376
#:13.8895
|:13.4352

:13.3436
      :12.5022
     :12.3616
        :12.3196
in:12.2811
 :11.9744
let:11.9021
       :11.6064
                :11.4611
end:11.0413
            :10.9732
	:10.7322
 #:10.7276
(*:10.4175
          :10.2845
           :10.1396

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   
   
   

Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   
   
   
LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
 |:18.0079
 #:16.663

:16.5081
 (*:13.3743
 end:12.4001
 <:12.362
 ||:12.0073
 //:11.9067
 ##:11.4481
 *:11.4055
 let:11.1406
 -:11.1364
 ###:11.1098
 --:11.0765
 /*:11.0634
 _:11.0382
 ...:11.0067
 ---:10.8268
 in:10.7684
 /:10.7605
 ;;:10.7516

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   
   
   


Debug: true, Constrain: Context
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

# Update todo list #
let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | AddTodo =>
        let buffer, todos = model in
        if buffer $== "" then model else (buffer, todos @ [buffer, false] ) end
   
   
   
   

LSP: Get Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Model
  LSP: Info: Seft type: Model
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: Action, model: Model, update: ((Model, Action) -> Model), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), AlignItems: (String -> StyleAttr), BackgroundColor: (String -> StyleAttr), Border: (String -> StyleAttr), BorderRadius: (String -> StyleAttr), BoxShadow: (String -> StyleAttr), Color: (String -> StyleAttr), Cursor: (String -> StyleAttr), Display: (String -> StyleAttr), FlexDirection: (String -> StyleAttr), FontFamily: (String -> StyleAttr), FontSize: (String -> StyleAttr), FontStyle: (String -> StyleAttr), Gap: (String -> StyleAttr), Height: (String -> StyleAttr), JustifyContent: (String -> StyleAttr), Margin: (String -> StyleAttr), Opacity: (String -> StyleAttr), Outline: (String -> StyleAttr), Overflow: (String -> StyleAttr), Padding: (String -> StyleAttr), Position: (String -> StyleAttr), Width: (String -> StyleAttr), S: ((String, String) -> StyleAttr), StyleAttr:: (AlignItems(String) + BackgroundColor(String) + Border(String) + BorderRadius(String) + BoxShadow(String) + Color(String) + Cursor(String) + Display(String) + FlexDirection(String) + FontFamily(String) + FontSize(String) + FontStyle(String) + Gap(String) + Height(String) + JustifyContent(String) + Margin(String) + Opacity(String) + Outline(String) + Overflow(String) + Padding(String) + Position(String) + Width(String) + S((String, String))), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  buffer
Nature of error: Expecting type Todo but got inconsistent type String  
Error in term:
  false
Nature of error: Expecting type Todo but got inconsistent type Bool
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Model, Action) -> Model)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/" | "in"
root ::= new-tokens

Top 20 Logits:
   :16.4885
    :15.918
  :14.718
#:13.6998
|:13.0541

:13.0178
in:12.9675
      :12.3838
     :12.2649
        :12.2323
 :11.9311
       :11.5998
let:11.5142
                :11.3501
end:11.3311
            :10.7697
 #:10.5652
(*:10.4307
	:10.4147
 in:10.2725
```:10.2671
