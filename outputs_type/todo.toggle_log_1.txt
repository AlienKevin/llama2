

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]=

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]=
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:18.6211
 :16.0284
 fun:15.0364
  :13.2829
    :12.3493
   :12.2484
fun:11.9104
 (:11.4952
 function:11.4608	prefix accepted: fun
                :11.2644
     :10.4085
 let:10.2307
 {:9.86644	prefix accepted: 
 ?:9.86288	prefix accepted: 
	:9.83741	rejected
        :9.83735
 #:9.83019	prefix accepted: 
       :9.58332
      :9.55311
 (*:9.42072	prefix accepted: (
 List:9.39458

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]=
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:21.6056
 fun:15.5599
 #:13.3264	prefix accepted: 
	:12.9257	rejected
 (*:12.6856	prefix accepted: (
 function:12.424	prefix accepted: fun
 (:12.6856
0:12.3187	rejected
1:11.6631	rejected
 func:11.6516	prefix accepted: fun
 {:11.3809	prefix accepted: 
 fn:10.9195	prefix accepted: f
λ:10.8253	rejected
 let:10.6593
 toggle:10.3683	prefix accepted: t
 #(:10.3336	prefix accepted: 
 \:10.3241	prefix accepted: 
 lambda:10.3207	prefix accepted: l
 in:10.2178	prefix accepted: i
 %:10.1481	prefix accepted: 
 //:10.0973	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
   :20.5874
 :19.2322
fun:18.461
	:15.9939	rejected
  :15.3514
       :14.7986
     :14.2741
let:14.2524
 fun:14.1271
(:13.6308
    :13.2816
func:12.7918	prefix accepted:fun
 let:12.0831
           :11.8227

:11.7722
(*:11.3945	prefix accepted:(
{:11.368	rejected
      :11.2328
         :11.2231
function:11.2006	prefix accepted:fun
fn:11.1427	prefix accepted:f

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
   

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
   
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:18.7913
 let:16.7328
 #:13.4137	prefix accepted: 
 (:12.8801
 List:12.1106
 (*:11.7856	prefix accepted: (
 ~:11.3329	prefix accepted: 
 if:11.2219
 func:11.1683	prefix accepted: fun
 @:11.0272	prefix accepted: 
 toggle:10.9993	prefix accepted: t
 f:10.9023
 match:10.7608	prefix accepted: 
 fn:10.5213	prefix accepted: f
 function:10.5169	prefix accepted: fun
 {:10.4398	prefix accepted: 
 lambda:10.4069	prefix accepted: l
 case:10.3792
 list:10.2027	prefix accepted: l
 todo:10.1088	prefix accepted: t
 update:9.89635	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddTodo" | "App" | "RemoveTodo" | "Reverse" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 go:14.5161
 toggle:12.7111
 rec:11.8788
 update:11.7214
 aux:11.6535
 todo:11.3329
 f:11.3026
 helper:10.2099
 do:10.0437
 list:9.93729
 inner:9.7906
 togg:9.70466
 List:9.38687	prefix accepted: 
 index:9.37419
 _:9.27636
 get:9.27601
 Tod:9.27155	prefix accepted: To
 not:9.24803
 set:9.13435
 open:9.01838
 at:8.71168

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
::16.7934
 ::13.8196
 =:12.611
 i:12.42	prefix accepted: 
 acc:12.0191	prefix accepted: 
:(:11.9781	prefix accepted::
 (:11.9774
_:11.776
 x:11.2247	prefix accepted: 
 idx:11.1297	prefix accepted: 
 xs:11.1271	prefix accepted: 
(:10.705
 index:10.6336	prefix accepted: 
 n:10.4652	prefix accepted: 
 f:10.3175	prefix accepted: 
 _:10.0718	prefix accepted: 
1:9.94023
 ((:9.34485	prefix accepted: (
2:9.30817
 prev:9.26974	prefix accepted: 
 t:9.24186	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go:

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go:
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >:<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Annotation
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ?, Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: :
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: :
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ":"
new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StringTransform" | "Term" | "Todo" | "[" | constructor
root ::= completions | new-tokens

Top 20 Logits:
 (:18.7602
 ([:16.7898	prefix accepted: (
 Int:16.004
 ((:15.5071	prefix accepted: (
 (?:15.1894	prefix accepted: (
 ?:13.1532	prefix accepted: 
 :13.1532
 Tod:12.7186
 [:12.7037
([:12.4617	prefix accepted:(
 (_:11.6218	prefix accepted: (
 List:11.3406
 ():11.1966
 [(:11.0345	prefix accepted: [
 int:10.9636	prefix accepted: 

:10.8141
 Bool:10.812
 (!:10.7323	prefix accepted: (
 [[:10.5959	prefix accepted: [
((:10.426	prefix accepted:(
 ({:9.95592	prefix accepted: (

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go:
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Empty type hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StringTransform" | "Term" | "Todo" | "[" | constructor
root ::= completions | new-tokens

Top 20 Logits:
Int:18.4869
Bool:16.7998
T:15.2973
?,:15.2034	rejected
_,:13.2092	rejected
List:12.9562
([:12.9346	prefix accepted:(
String:12.3542
int:11.9867	rejected
 Int:11.7053
((:11.5685	prefix accepted:(
[[:11.5182	prefix accepted:[
N:11.3526
(),:11.1421	prefix accepted:()
Boolean:10.8641
 ?:10.7254	prefix accepted: 
bool:10.6264	rejected
??:10.3871	rejected
t:10.3639	rejected
(?:10.322	prefix accepted:(
?):10.2603	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Int>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Base type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Base type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave or complete: Int
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:19.0728
,[:15.6413	prefix accepted:,
 ->:13.2367
):13.1525
 ,:13.0545
?,:11.4184	rejected
,(:11.2821	prefix accepted:,
 [:10.93	prefix accepted: 
 *:10.8294	prefix accepted: 
->:10.131
 option:10.0782	prefix accepted: 
 list:10.0306	prefix accepted: 
[:10.0197	rejected
 [],:9.91701	prefix accepted: 
 List:9.76244	prefix accepted: 
([:9.73854	prefix accepted:(
 Int:9.62158	prefix accepted: 
 x:9.60563	prefix accepted: 
 ([:9.36676	prefix accepted: (
 [[:9.34397	prefix accepted: 
 Bool:9.17198	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StringTransform" | "Term" | "Todo" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 Int:15.9065
 [:15.8607
 Tod:15.762
 Bool:14.845
 ?:14.0102	prefix accepted: 
 [(:12.8777	prefix accepted: [
 ([:12.6916	prefix accepted: (
 List:12.1272
 (:12.6916
 [[:11.3244	prefix accepted: [
 (?:10.9563	prefix accepted: (
 String:10.9305
 [],:10.7199	prefix accepted: [
 ((:10.4968	prefix accepted: (
 Boolean:10.4414
 _,:9.77547	prefix accepted: 
 bool:9.48019	prefix accepted: 
 :14.0102
 Maybe:9.1113
Bool:9.09341
 TODO:8.93493

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Tod

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Tod
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Tod>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "Tod"))
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: ALL errors:
Error in term:
  Tod
Nature of error: Type variable Tod is not bound
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Tod
LSP: Generating Completions for prefix: Tod
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "o" | extend-constructor
root ::= completions

Top 20 Logits:
o:27.6108
os:15.9424
oo:11.1508
od:10.3681
odo:10.2457
ol:10.2049
d:10.174
oy:10.1607
oe:10.1152
a:9.94179
oa:9.8229
op:9.7915
ot:9.77442
or:9.71105
ois:9.66249
oi:9.49441
 o:9.41312	rejected
ow:9.30951
of:9.16169
oto:9.02675
,:9.00831	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Tod
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave or complete: Todo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Todo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:17.1001
):16.4457
 ->:14.7286
,[:12.7227	prefix accepted:,
 list:12.0139	prefix accepted: 
 ,:11.2144
->:11.1956
List:10.8025
 [],:10.6953	prefix accepted: 
)->:10.4972	prefix accepted:)
[:9.90673	rejected
[]):9.80186	rejected
 [:9.60911	prefix accepted: 
([:9.58904	prefix accepted:(
 *:9.5712	prefix accepted: 
?,:9.45198	rejected
 List:9.06871	prefix accepted: 
*,:8.95107	rejected
 [[:8.87605	prefix accepted: 
[]:8.80344	rejected
.:8.54733	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Product type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StringTransform" | "Term" | "Todo" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 [:18.2227
 Int:15.2902
 Tod:14.4973
 ?:14.4201	prefix accepted: 
 [(:14.2808	prefix accepted: [
 ([:13.606	prefix accepted: (
 Bool:13.4277
 [[:13.1809	prefix accepted: [
 List:12.387
 (:13.606
 :14.4201
 Acc:10.8339
 [],:10.652	prefix accepted: [
 Boolean:10.5234
 (?:10.2963	prefix accepted: (
 String:10.1103
 int:9.77085	prefix accepted: 
 ((:9.71301	prefix accepted: (
 [_:9.71183	prefix accepted: [
 _):9.68923	prefix accepted: 
 bool:9.675	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: BidiCtx: Cls: Empty type hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StringTransform" | "Term" | "Todo" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
T:20.4476
?:17.6324	rejected
Int:13.0573
]):12.8247	rejected
Bool:12.4973
Maybe:12.0907
 ?:11.7608	prefix accepted: 
TO:11.5111
List:11.233
 Tod:11.1662
?,:10.9006	rejected
t:10.8516	rejected
Tu:10.6429
$:10.5752	rejected
?(:10.2773	rejected
x:10.2505	rejected
():10.2203
??:10.2119	rejected
a:10.2097	rejected
Boolean:9.99771
???:9.91598	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [T

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [T
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <T>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "T"))
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: ALL errors:
Error in term:
  T
Nature of error: Type variable T is not bound
  LSP: Info: BidiCtx: Cls: Type variable
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: T
LSP: Generating Completions for prefix: T
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "erm" | "odo" | extend-constructor
root ::= completions

Top 20 Logits:
odo:27.7833
od:16.8158
og:15.5597
odos:15.2001
ogo:15.0839
odd:13.5697
oto:13.1122
ado:12.7581
 todo:11.274	rejected
do:11.2284
d:11.1155
udo:10.9373
ogle:10.8543
oda:10.5872
ago:10.304
odot:10.1703
oggle:9.79818
oge:9.79451
odor:9.78342
olo:9.72316
odore:9.69194

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [T
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) = in in
  LSP: Info: BidiCtx: Cls: Type variable
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-concave or complete: Todo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Todo
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | "+" | "," | "->" | "]"
root ::= completions | new-tokens

Top 20 Logits:
]):21.4694	prefix accepted:]
],:20.4538	prefix accepted:]
]:21.4694
]->:14.4067	prefix accepted:]
],[:12.431	prefix accepted:]
]),:12.3263	prefix accepted:]
]);:12.175	prefix accepted:]
 ->:11.8629
]).:11.1154	prefix accepted:]
),:10.8132	rejected
])):10.7917	prefix accepted:]
,:10.782
2:10.7078
?:10.558	rejected
->:10.4755
](:10.4697	prefix accepted:]
]*:10.3627	prefix accepted:]
}):10.305	rejected
):10.2714	rejected
']):10.265	rejected
>):10.2151	rejected
Rejected the highest logit candidate ]) with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo]

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo]
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) = in in
  LSP: Info: BidiCtx: Cls: Product type
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized type
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "+" | "," | "->"
root ::= new-tokens

Top 20 Logits:
 ):15.8881
 ->:15.7688
 ,:12.2368
 @:12.0086	prefix accepted: 
?):11.0408	rejected
 |:11.0008	prefix accepted: 
 *:10.8217	prefix accepted: 
 ?:10.4493	prefix accepted: 
 :12.0086
)\:10.1134	prefix accepted:)
 -:10.0138

:9.94064
*):9.85783	rejected
 =:9.82707	prefix accepted: 
 list:9.61548	prefix accepted: 
 +:9.59094
)$:9.4708	prefix accepted:)
 ~:9.45865	prefix accepted: 
@:9.45366	rejected
 &:9.29734	prefix accepted: 
'):9.1513	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] )

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] )
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Var "Todo"); (List (Var "Todo"))])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "+" | "," | "->" | "="
root ::= new-tokens

Top 20 Logits:
 ->:18.0545
->:17.1343
 :12.2622
 =>:11.9528	prefix accepted: =
 =:11.9528
=:10.3512
 -:10.2471
 -->:9.65119	prefix accepted: -

:9.62955
=>:9.4813	prefix accepted:=
  :9.1388
-:9.11165
 >:8.67167	prefix accepted: 
>:8.64816	rejected
 ~:8.63162	prefix accepted: 
 →:8.38748	prefix accepted: 
->_:8.33409	prefix accepted:->
-->:8.32024	prefix accepted:-
 |:8.20457	prefix accepted: 
 <-:8.10034	prefix accepted: 
->{:7.80766	prefix accepted:->

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) ->

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) ->
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >-><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Function type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ->
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: ->
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StringTransform" | "Term" | "Todo" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
 [:18.9814
[:16.2175
 ([:15.3808	prefix accepted: (
 :14.4121
 Tod:14.3562
 (:15.3808
 [(:13.0318	prefix accepted: [
 ?:12.3914	prefix accepted: 
 List:12.1888
([:11.382	prefix accepted:(
 [[:10.9041	prefix accepted: [
 []:10.776	prefix accepted: [
  :10.6671
 Bool:10.6408
 Int:10.3351
 TODO:10.1241
 Maybe:10.0874

:9.96182
 ((:9.92387	prefix accepted: (
 (?:9.74076	prefix accepted: (
 _:9.66186	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [?])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [?])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty type hole
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] = in in
  LSP: Info: BidiCtx: Cls: Empty type hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Generating Completions for prefix: [
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "+" | "Action" | "Bool" | "Float" | "Int" | "Model" | "String" | "StringTransform" | "Term" | "Todo" | "[" | constructor
root ::= new-tokens

Top 20 Logits:
T:20.6436
?:15.1085	rejected
 Tod:13.7866
 ?:11.4636	prefix accepted: 
t:11.2049	rejected
TO:11.141
Int:9.90037
 ]:9.1751	prefix accepted: 
??:9.15706	rejected
Toggle:9.13675
???:9.08908	rejected
?,:9.00133	rejected
Maybe:8.80155
?>:8.69309	rejected
 todo:8.63283	prefix accepted: 
?(:8.62557	rejected
List:8.61672
 T:8.55816

:8.39779
To:8.35122
Bool:8.32776

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [T

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [T
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <T>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Typ (FreeTypeVariable "T"))
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] = in in
  LSP: Info: ALL errors:
Error in term:
  T
Nature of error: Type variable T is not bound
  LSP: Info: BidiCtx: Cls: Type variable
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: T
LSP: Generating Completions for prefix: T
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "erm" | "odo" | extend-constructor
root ::= completions

Top 20 Logits:
odo:30.6135
odos:20.8737
od:17.0372
ogo:15.9409
oto:15.7693
udo:14.9767
odon:14.7158
ondo:14.2825
oso:14.2231
odd:14.2173
ado:13.527
odio:13.3105
odu:13.3096
odox:13.1491
odot:13.1361
odore:13.0839
ordo:12.6843
ogle:12.5015
oo:12.4221
ode:12.4078
oco:12.3729

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [T
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Type variable
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] = in in
  LSP: Info: BidiCtx: Cls: Type variable
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List type
  LSP: Syntax: Can insert left-concave or complete: Todo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Todo
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Action Model Todo Term StringTransform () Bool Float Int String ~CONSTRUCTOR~ + ( [
  LSP: Convex: Lookahead: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-constructor
new-tokens ::= whitespace | "(" | "+" | "," | "->" | "]"
root ::= completions | new-tokens

Top 20 Logits:
]:18.4515
]=:16.305	prefix accepted:]
 ]:13.7713
=:11.2855	rejected
 =:10.6998	prefix accepted: 
]->:10.2667	prefix accepted:]
]]:10.1209	prefix accepted:]
]*:10.0828	prefix accepted:]
];:9.90425	prefix accepted:]
)=:9.90231	rejected
]=":9.72897	prefix accepted:]
]):9.4587	prefix accepted:]
],:9.33325	prefix accepted:]
]::9.3299	prefix accepted:]
]`:9.09036	prefix accepted:]
](:9.0589	prefix accepted:]
]+:8.93689	prefix accepted:]
}=:8.89467	rejected
*:8.82204	rejected
):8.72203	rejected
]/:8.5168	prefix accepted:]

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo]

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo]
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List type
  LSP: Info: Sort: Typ
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in in
  LSP: Info: BidiCtx: Cls: Annotation
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: + , ->
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "+" | "," | "->" | "="
root ::= new-tokens

Top 20 Logits:
 =:20.6908
 :15.183

:14.6507
  :12.518
 in:11.363	prefix accepted: 
 |:10.7574	prefix accepted: 
   :10.4853
    :10.4594
 =>:9.90828	prefix accepted: =
                :9.80634
?:9.73704	rejected
 ==:9.69556	prefix accepted: =
     :9.613
 end:9.58361	prefix accepted: 
=(:9.38434	prefix accepted:=
=:9.38434
 ->:9.20921
 =\:9.208	prefix accepted: =
	:9.06662	rejected
=[:8.98796	prefix accepted:=
 &:8.89946	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, Todo, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:18.9186
 :18.2236
 fun:16.2604
  :15.5361
    :14.8939
                :13.6423
   :13.1466
     :13.1307
        :12.7723
fun:12.5771
 (*:12.4834	prefix accepted: (
      :12.4537
 \:12.3129	prefix accepted: 
       :12.2802
            :12.2063
 (:12.4834
         :12.0773
 match:11.7063	prefix accepted: 
 #:11.5929	prefix accepted: 
          :11.5189
	:11.4953	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, Todo, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
       :18.5378
   :16.0759
     :15.5256
           :13.9187
    :13.0722
	:12.8947	rejected
      :12.7216
 :12.0108
               :11.9425
        :11.9078
fun:11.7146
         :11.481
                :11.1342
  :10.7629
             :10.1328
            :9.89289
          :9.66428

:9.32105
func:9.25448	prefix accepted:fun
              :9.02809
 fun:8.34617

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
       

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
       
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, Todo, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:21.9114
 let:15.8219
 match:14.5634	prefix accepted: 
 if:13.9682
 (:13.9447
 (*:13.8911	prefix accepted: (
 #:13.7527	prefix accepted: 
 func:13.0784	prefix accepted: fun
 f:12.2875
 case:12.2092
 function:11.9298	prefix accepted: fun
 fn:11.7487	prefix accepted: f
 fix:11.6557	prefix accepted: f
 lambda:11.5852	prefix accepted: l
 ~:11.5783	prefix accepted: 
 {:11.4981	prefix accepted: 
 @:11.362	prefix accepted: 
 |:11.3561	prefix accepted: 
 ?:11.0704	prefix accepted: 
 ((:10.7503	prefix accepted: (
 *:10.7061	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
 idx:16.4119
 i:15.0631
 index:14.4878
 n:14.1153
 :12.5518
 count:12.4109
 pos:12.4073
 (:12.2728
 x:12.2259
 id:12.0566
 counter:11.9763
 ind:11.7183
 current:11.4426
 acc:11.3041
 _:11.286
 k:11.0065
 num:10.8851
 todo:10.7255
 curr:10.686
 c:10.5624
 remaining:10.4821

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <i>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {i: (Int, Todo, [Todo]), go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: i
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: i
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:15.2829
x:14.0291
 t:13.2195	prefix accepted: 
 x:12.1891	prefix accepted: 
 todo:12.1882	prefix accepted: 
 acc:11.5528	prefix accepted: 
 ,:11.0459
 td:10.7079	prefix accepted: 
 current:10.6616	prefix accepted: 
 ->:10.6046
 s:10.5166	prefix accepted: 
 (:10.2148
 d:10.1911	prefix accepted: 
 elem:9.99757	prefix accepted: 
 e:9.9903	prefix accepted: 
 cur:9.88652	prefix accepted: 
 item:9.82507	prefix accepted: 
1:9.77211
 el:9.77159	prefix accepted: 
 idx:9.68686	prefix accepted: 
 _,:9.57367	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Var "Todo"); (List (Var "Todo"))]);
           syn = (Prod [(Unknown Internal); (Unknown Internal)])})))
  LSP: Info: Typing Context: {i: ?, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in
  LSP: Info: ALL errors:
Error in term:
  (i, ?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Var "Todo"); (List (Var "Todo"))]);
           syn = (Prod [(Unknown Internal); (Unknown Internal)])})))
  LSP: Info: Typing Context: {i: ?, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in
  LSP: Info: ALL errors:
Error in term:
  (i, ?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {i: ?, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in
  LSP: Info: ALL errors:
Error in term:
  (i, ?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [(Unknown Internal); (Unknown Internal)])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddTodo" | "App" | "RemoveTodo" | "Reverse" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 todo:14.5053
 t:14.4696
 x:14.1596
 (:13.208
 h:13.167
 td:12.5569
 _,:11.7841	prefix accepted: _
 current:11.7197
 item:11.5595
 d:11.4637
 acc:11.344
t:11.0655
 cur:10.7963
 e:10.7559
 curr:10.7144
 next:10.5788
 new:10.5347
 head:10.4965
 to:10.3472
 el:10.3353
 old:10.2929

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: ?, i: ?, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in
  LSP: Info: ALL errors:
Error in term:
  (i, todo)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (?, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: todo
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [(Unknown Internal); (Unknown Internal)])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todo
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [(Unknown Internal); (Unknown Internal)])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:18.2124
_:14.4677
 ,:14.2616
1:13.7387
_,:12.5103	prefix accepted:_
 ->:12.0288
@:11.5332	rejected
,(:11.3949	prefix accepted:,
::11.0434
 acc:10.8882	prefix accepted: 
2:10.8568
0:10.7786
Item:10.7406
 (:10.3986
,[:10.3878	prefix accepted:,
 x:10.2559	prefix accepted: 
(:10.1343
 item:9.99708	prefix accepted: 
List:9.97944
',:9.93584	rejected
->:9.81491

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: (Int, Todo, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: (Int, Todo, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Var "Todo"); (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:15.3499
 todos:15.0304
 xs:14.3132
 todo:14.1109
 ts:13.4415
 rest:13.287
 result:12.5198
 t:11.8562
 l:11.8358
 list:11.6679
 remaining:11.3233
 rev:11.2241
 res:11.091
 new:10.8415
 lst:10.814
 x:10.6844
 accum:10.6713
 ls:10.6686
 to:10.3036
 remainder:10.3004
 togg:10.1458

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Var "Todo"); (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Var "Todo"); (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:17.6372
->:14.7643
 :13.349
':13.0405	rejected
_:12.5801
 =>:12.2319	prefix accepted: 
 when:11.7641	prefix accepted: 
 -:11.5997

:11.3045
1:11.2066
,:10.8031	rejected
 =:10.6644	prefix accepted: 
 so:10.5977	prefix accepted: 
0:10.2532
2:10.2339
 |:10.1322	prefix accepted: 
::10.0019
  :9.71845
 acc:9.545	prefix accepted: 
 if:9.45976	prefix accepted: 
 in:9.41694	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:19.3253
 :17.8262
 if:16.9187
 case:15.7703
  :15.605
    :14.794
 match:14.7783	prefix accepted: 
        :14.0242
                :13.2357
            :13.2061
     :13.1246
         :12.9859
   :12.8744
      :12.8166
             :12.2454
 (:12.1385
 todo:12.1222
          :11.913
 {:11.8449	prefix accepted: 
 #:11.7536	prefix accepted: 
 cons:11.4948	prefix accepted: c

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
           :20.7591
       :18.2256
               :16.1147
         :16.0208
          :15.4967
            :15.0451
        :14.8582
   :14.6955
                :13.8344
             :13.5367
	:13.406	rejected
     :13.3327
      :13.1867
              :12.9312

:12.3661
    :12.3537
if:12.0362
  :10.8796
 :10.6211
case:9.81331
#:9.22091	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
           

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
           
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 if:20.9299
 case:20.8091
 match:17.3456	prefix accepted: 
 let:15.4169
 #:14.6841	prefix accepted: 
 todo:13.6397
 print:13.3507	prefix accepted: 
 assert:13.2913	prefix accepted: 
 (:13.2788
 i:13.0119
 List:12.7197
 cons:12.6603	prefix accepted: c
 (*:12.1902	prefix accepted: (
 {:11.8591	prefix accepted: 
 cond:11.8072	prefix accepted: c
 cases:11.2843	prefix accepted: case
 [:11.2501
 go:11.1687
 Cons:10.9692	prefix accepted: 
 var:10.9055	prefix accepted: 
 console:10.8854	prefix accepted: c

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.contains List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "Bool.eq" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "Model.eq" | "Model.get_buffer" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "todo_list_eq" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 i:17.364
 Int:13.8551	prefix accepted: 
 (:13.1552
 :13.8551
  :12.6122
 List:11.8532
(:11.8122
 !:11.6557
 string:11.371
 todo:11.1994
     :11.1913
 is:11.0743
 String:10.9704
 not:10.9237	prefix accepted: n
 eq:10.8621	prefix accepted: e
    :10.759
 int:10.6425
 todos:10.5835	prefix accepted: todo
 case:10.0726
 I:9.91853	prefix accepted: 
 equals:9.84183	prefix accepted: e

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <i>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = Int})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: ALL errors:
Error in term:
  i
Nature of error: Expecting type Bool but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: i
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: == != <= >= < >
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: i
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.contains List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "f " | "nfinity" | "nt_of_float" | "nt_of_string" | "s_finite" | "s_infinite" | "s_nan"
new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 ==:18.1822
 <=:17.3089
 =:17.2334
 >:17.1918
 <:16.7918
 $:16.5122	prefix accepted: 
 ===:15.0285	prefix accepted: ==
=:14.6462
 >=:14.1879
 <>:14.0984	prefix accepted: <
==:13.3674
 !=:13.2365
$:12.8027	rejected
=$:12.3167	prefix accepted:=
 :16.5122
 then:12.1065
 -:11.9081
 +:11.4657
>:11.4164
<=:11.3607
 =>:11.0075	prefix accepted: =

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i >

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i >
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Greater Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Greater Than
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: >
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: i min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: >
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - Bool.eq List.contains List.eq List.fold_left List.fold_right List.is_empty List.length Model.eq Model.get_buffer String.reverse String.starts_with String.transform Todo.eq abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string todo_list_eq true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "." | "=" | "=."
new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "i" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= completions | new-tokens

Top 20 Logits:
 :18.683
 -:14.4298
 List:13.7604
!:13.0446	rejected
 length:12.9712	prefix accepted: le
  :12.7612
0:12.4451
 string:12.4316
 Int:12.3629	prefix accepted: 
 (:11.6613
 !:11.2113	prefix accepted: 
?:11.2027	rejected
 len:11.1994	prefix accepted: le
 String:11.0773	prefix accepted: 
 $:10.7474	prefix accepted: 
 (-:10.6857	prefix accepted: (
 list:10.4169	prefix accepted: l
<:10.0501	rejected
 size:9.98591	prefix accepted: s
-:9.70458
 todo:9.45119	prefix accepted: t

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i >
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: i min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "i" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
0:26.1626
1:22.3981
2:18.1082
3:17.2464
4:15.7783
5:15.6755
9:15.5061
7:14.076
6:13.5141
8:13.4972

:12.3756
 -:12.3032
 s:12.2359
nd:12.0365	rejected
 !:11.7459	prefix accepted: 
 done:11.2999	prefix accepted: 
 (:11.029
 status:10.7257	prefix accepted: st
	:9.86025	rejected
 false:9.85713	prefix accepted: 
 $:9.57294	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <0>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else in in
  LSP: Info: BidiCtx: Cls: Integer Greater Than
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: 0
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 0
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: i min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= completions | new-tokens

Top 20 Logits:
 then:20.6689
 :17.073

:16.5893
 &&:15.1837	prefix accepted: 
 ||:13.0973	prefix accepted: 
  :12.994
    :12.2156
 #:11.807	prefix accepted: 
                :11.0535
 and:10.8997	prefix accepted: 
   :10.7574
then:10.736
     :10.6927
.:10.6532	rejected
 -:10.6066
            :10.5086
 //:10.4648	prefix accepted: /
      :10.4574
 ?:10.4325	prefix accepted: 
 =>:10.4242	prefix accepted: =
        :10.3867

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:15.9896
 todo:14.8955
 :14.4082
 List:13.0576
 (:12.2541
 go:12.0933
 [:11.4885
 #:11.3017	prefix accepted: 
 todos:11.2228
  :11.1831
 cons:11.1215	prefix accepted: c
 Cons:11.1133	prefix accepted: 
 toggle:10.9185	prefix accepted: to
 {:10.6498	prefix accepted: 
    :10.5408
 Tod:10.3417	prefix accepted: 
 f:9.75023	prefix accepted: 
 head:9.58003	prefix accepted: 
                :9.5637
 (*:9.42977	prefix accepted: (
            :9.41856

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
               :23.7043
                :19.2004
             :19.1011
              :18.9068
           :17.4246
            :16.4827
	:15.7173	rejected
#:13.9967	rejected
          :13.8163
         :13.569

:13.5523
        :12.9397
    :12.8837
       :12.773
   :12.3532
     :11.9336
  :11.8922
      :11.4589
 :11.3467
 #:10.5004	prefix accepted: 
(:10.0784

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
               

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
               
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 todo:15.2306
 List:14.5184
 let:14.4703
 #:13.1248	prefix accepted: 
 (:12.5783
 go:12.4757
 todos:12.2476
 match:12.1865	prefix accepted: 
 head:11.9231	prefix accepted: 
 case:11.8655
 [:11.8159
 toggle:11.7429	prefix accepted: to
 Cons:11.6102	prefix accepted: 
 h:11.5503	prefix accepted: 
 first:11.3046	prefix accepted: 
 cons:11.1947	prefix accepted: c
 tod:10.7265
 Tod:10.5529	prefix accepted: 
 {:10.3664	prefix accepted: 
 list:10.323	prefix accepted: l
 f:10.1021	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
               
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: Todo
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo")); syn = (Var "Todo")})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: ALL errors:
Error in term:
  todo
Nature of error: Expecting type [Todo] but got inconsistent type Todo
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: todo
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Todo
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: todo
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
new-tokens ::= whitespace | "::" | "else"
root ::= completions | new-tokens

Top 20 Logits:
:::18.0496
 :::17.4463
_:14.7681	rejected
 @:14.0109	prefix accepted: 
.:13.3424	rejected
@:11.4144	rejected
 cons:11.2137	prefix accepted: 
 ++:11.1472	prefix accepted: 
 ::11.0886
 +:10.6111	prefix accepted: 
(:10.2632	rejected

:10.2421
 :14.0109
[:9.77387	rejected
::9.65548
 ^:9.38426	prefix accepted: 
:(:9.23038	prefix accepted::
 //:9.13511	prefix accepted: 
 *:8.93965	prefix accepted: 
 #:8.85217	prefix accepted: 
 Cons:8.84724	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >::<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Cons
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ::
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Generating Completions for prefix: ::
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
go:17.2586
(:15.5877
List:13.5366
toggle:12.704	prefix accepted:to
tod:12.4797
 go:11.7839
[:10.1227
 (:10.0315
((:9.68691	prefix accepted:(
 List:9.59554
 todos:9.42099
t:9.41041
tail:9.30859	prefix accepted:t
rest:9.12776	rejected
@:8.92241	rejected
Toggle:8.73046	rejected

:8.65258
g:8.59241
list:8.4255	prefix accepted:l
T:8.3864	rejected
Go:8.29566	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo"));
           syn =
           (Arrow ((Prod [Int; (Var "Todo"); (List (Var "Todo"))]),
              (List (Var "Todo"))))})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: ALL errors:
Error in term:
  go
Nature of error: Expecting type [Todo] but got inconsistent type ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "else"
root ::= new-tokens

Top 20 Logits:
(:23.0761
((:18.9186	prefix accepted:(
(-:17.4641	prefix accepted:(
 (:16.674
(@:14.6523	prefix accepted:(
 ((:14.2554	prefix accepted: (
(!:13.5222	prefix accepted:(
 (-:13.1041	prefix accepted: (
(?:12.9975	prefix accepted:(
($:12.4235	prefix accepted:(
():12.3069	prefix accepted:(
([:12.2888	prefix accepted:(
_:12.1544	rejected
(_:12.1518	prefix accepted:(
!(:12.1441	rejected
_(:11.5895	rejected
2:11.4691	rejected
(__:11.4421	prefix accepted:(

:11.4327
({:11.3951	prefix accepted:(
[:11.2893	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
  LSP: Convex: Target types: Int, (Int, Todo, [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: ++ :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++ :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "i" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
i:20.4425
 i:14.8697
pred:13.2066	rejected
1:12.4929

:11.9711
 (:11.7085
0:11.3619
--:11.0126	prefix accepted:-
dec:10.8249	rejected
minus:10.6572	prefix accepted:min
 -:10.5703
Int:10.325	rejected
if:10.1846
List:9.91859
 :9.59765
sub:9.36566	prefix accepted:s
t:9.32622
su:9.23244	prefix accepted:s
#:9.21635	rejected
2:9.11002
~:9.0805	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <i>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Var "Todo"); (List (Var "Todo"))]);
           syn = Int})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: i
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: i
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
  LSP: Convex: Target types: Int, (Int, Todo, [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "f " | "nt_of_float" | "nt_of_string"
new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "," | "-" | "/"
root ::= completions | new-tokens

Top 20 Logits:
 -:21.0083
-:19.2751
 +:14.4057
,:13.4943
+:12.4359
--:12.2809	prefix accepted:-
 :11.2795
 $:11.1471	prefix accepted: 
 --:10.6521	prefix accepted: -
-$:10.5881	prefix accepted:-
$:10.5045	rejected
 -=:10.403	prefix accepted: -
 =:10.3658	prefix accepted: 
 –:10.2691	prefix accepted: 
 /:10.1942
 −:10.1335	prefix accepted: 
 $-:10.0617	prefix accepted: 
-(:10.0495	prefix accepted:-
=:9.9184	rejected
 ,:9.8386
 -(:9.01527	prefix accepted: -

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >-<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Subtraction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Var "Todo"); (List (Var "Todo"))]);
           syn = Int})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Integer Subtraction
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Var "Todo"); (List (Var "Todo"))]);
           syn = Int})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: -
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: i min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: -
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
  LSP: Convex: Target types: Int, (Int, Todo, [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "i" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
1:23.196
 :15.848
2:12.965
=:12.5879	rejected
i:12.4633
0:12.227
  :11.4185
!:11.3743	rejected
3:10.2315
l:9.99604
[:9.87614	rejected
t:9.85697
length:9.72579	prefix accepted:le
x:9.49265	rejected
n:9.40223	rejected

:9.3971
@:9.26454	rejected
^:9.24583	rejected
~:9.14807	rejected
4:9.14604
5:9.09962

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <1>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Integer literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type Int
  LSP: Info: BidiCtx: Cls: Integer Subtraction
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: 1
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: 1
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: i min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-intlit
new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "," | "-" | "/"
root ::= completions | new-tokens

Top 20 Logits:
,:18.8689
 ,:14.535
,[:13.7611	prefix accepted:,
,(:12.6129	prefix accepted:,
):12.2608
::9.79262	rejected
<:9.66589	rejected
)(:9.63511	prefix accepted:)
;:9.46595	rejected
 :::9.44383	prefix accepted: 
,":9.37955	prefix accepted:,
,,:9.31264	prefix accepted:,
 :9.44383
 t:9.19469	prefix accepted: 
 <:9.18132	prefix accepted: 
 ::9.17956	prefix accepted: 
.:9.11963	rejected
:::9.0172	rejected
,$:8.89174	prefix accepted:,
),:8.82527	prefix accepted:)
 (*:8.74233	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: (Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Var "Todo"); (List (Var "Todo"))]);
           syn = (Prod [Int; (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: (Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Var "Todo"); (List (Var "Todo"))]);
           syn = (Prod [Int; (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
  LSP: Convex: Target types: Int, (Int, Todo, [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo" | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:16.1834
 h:12.5334	prefix accepted: 
 t:12.0676
 todos:11.7109
 head:11.6877	prefix accepted: 
 (:11.2543
 todo:11.0104
 list:10.6874	prefix accepted: l
hd:10.6743	rejected
List:10.4874
 #:10.3906	prefix accepted: 
 f:10.3098
 Array:9.18161	prefix accepted: A
 :12.5334
 match:9.07865	prefix accepted: ma
 {:9.01393	prefix accepted: 
 first:8.87148	prefix accepted: f
 case:8.84783
tod:8.76422
 !:8.70707
 String:8.64988

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined  
Error in term:
  i - 1, List
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".contains" | ".eq" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".is_empty" | ".length" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:22.573
_:13.9876	rejected
.(:13.2564	prefix accepted:.
.@:12.5927	prefix accepted:.
.<:11.246	prefix accepted:.
Util:11.2167	rejected
[:11.2089	rejected
@:11.1948	rejected
(:10.855	rejected
#:10.6431	rejected
._:10.6404	prefix accepted:.
Utils:10.608	rejected
<:9.98493	rejected
.__:9.9195	prefix accepted:.
Ex:9.91186	rejected
.[:9.65393	prefix accepted:.
Hel:9.50349	rejected
..:9.47837	prefix accepted:.
/:9.37115	rejected
2:9.31313	rejected
X:9.04355	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token  
Error in term:
  i - 1, List.
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "contains" | "eq" | "filter" | "fold_left" | "fold_right" | "init" | "is_empty" | "length" | "rev" | "tl"
root ::= completions

Top 20 Logits:
hd:19.2213	rejected
tl:18.9175
nth:18.4286	rejected
head:18.0955	rejected
get:15.2922	rejected
rev:15.1843
at:15.0164	rejected
first:13.3323	prefix accepted:fi
tail:12.9679	prefix accepted:t
list:12.364	prefix accepted:l
filter:12.3426
take:12.3233	prefix accepted:t
fold:12.2084
safe:12.1629	rejected
index:12.1555	prefix accepted:in
find:12.1515	prefix accepted:fi
cons:12.0845
n:11.9661	rejected
t:12.9679
h:11.8646	rejected
last:11.7949	prefix accepted:l
Rejected the highest logit candidate hd with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ([?] -> [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ([?] -> [?]))
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: List.tl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ([?] -> [?])
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Arrow ((List (Unknown TypeHole)), (List (Unknown TypeHole))))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: List.tl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Arrow ((List (Unknown TypeHole)), (List (Unknown TypeHole))))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "::"
root ::= new-tokens

Top 20 Logits:
(:17.5119
 todos:13.1746	prefix accepted: 
(!:11.9282	prefix accepted:(
[:11.7062	rejected
((:11.3279	prefix accepted:(
,:10.8028	rejected
_:10.7112	rejected
(@:10.6399	prefix accepted:(
 (:10.4036
([:10.0321	prefix accepted:(
.:9.89573	rejected
!(:9.87864	rejected
<:9.76977	rejected
 todo:9.61891	prefix accepted: 
@:9.46508	rejected
tod:9.32936	rejected
{:9.18361	rejected
(),:8.79625	prefix accepted:(
 !:8.70917	prefix accepted: 
():8.65869	prefix accepted:(
.(:8.47996	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo" | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
tod:19.3235
List:16.0058
t:15.0039
 todos:12.6513
td:11.54	prefix accepted:t
list:10.6712	prefix accepted:l
 List:9.88246
0:9.80143
x:9.77975	rejected
xs:9.5386	rejected
to:9.44873
tail:9.43737	prefix accepted:ta
hd:9.43221	rejected
toggle:9.02242	prefix accepted:to
Array:8.82909	prefix accepted:A
odos:8.74062	rejected
go:8.70736
ToList:8.63264	prefix accepted:To
i:8.63131
tot:8.37866	prefix accepted:to
rest:8.37111	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(tod

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(tod
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <tod>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "tod"))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(tod)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])  
Error in term:
  tod
Nature of error: Variable tod is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: tod
LSP: Generating Completions for prefix: tod
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, [?]
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "o" | "o_list_eq" | "os"
root ::= completions

Top 20 Logits:
os:27.1377
ol:12.4783	prefix accepted:o
ios:11.501	rejected
 os:11.4816	rejected
ose:11.3605	prefix accepted:os
oss:10.9167	prefix accepted:os
s:10.6724	rejected
oc:10.4755	prefix accepted:o
oses:10.3853	prefix accepted:os
op:10.136	prefix accepted:o
ors:10.0545	prefix accepted:o
oid:9.99392	prefix accepted:o
on:9.98549	prefix accepted:o
ost:9.96895	prefix accepted:os
osp:9.71198	prefix accepted:os
oso:9.66193	prefix accepted:os
om:9.61342	prefix accepted:o
otos:9.50315	prefix accepted:o
of:9.40112	prefix accepted:o
osi:9.25263	prefix accepted:os
ore:9.23857	prefix accepted:o

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(tod
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, [?]
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: todos
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, [?]
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
),:21.548	prefix accepted:)
)):17.9703	prefix accepted:)
)[:17.8432	prefix accepted:)
):21.548
).:14.1649	prefix accepted:)
,:13.7033	rejected
),(:12.5942	prefix accepted:)
[:12.4821	rejected
 ),:11.499	prefix accepted: )
)(:11.202	prefix accepted:)
)?:11.1743	prefix accepted:)
)->:11.1551	prefix accepted:)
 @:11.0596
));:11.0333	prefix accepted:)
)!:10.7184	prefix accepted:)
@:10.6449
)),:10.4283	prefix accepted:)
[@:10.2835	rejected
)^:10.0084	prefix accepted:)
)){:9.99866	prefix accepted:)
 :9.8391
Rejected the highest logit candidate ), with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:14.1875	prefix accepted: 
 @:13.838
 |:13.4562	prefix accepted: 
 ):12.7954
@:12.5736
 ::11.448
 !!:11.3196	prefix accepted: 
 as:11.3025	prefix accepted: 
:::11.2924
 $:11.2763	prefix accepted: 
 !:10.7522	prefix accepted: 
 :14.1875
!!:10.3379	rejected
 .:10.182	prefix accepted: 
 #:10.0155	prefix accepted: 
 :::9.98237
 -:9.93645	prefix accepted: 
#:9.86013	rejected
 t:9.69733	prefix accepted: 
 in:9.676	prefix accepted: 
!,:9.67187	rejected
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo" | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
[:17.8919
[(:14.2271	prefix accepted:[
List:13.6669
[[:13.6325	prefix accepted:[
([:12.7962	prefix accepted:(
[]):12.1283	prefix accepted:[]
t:11.7032
(:12.7962
[{:11.2494	prefix accepted:[
 [:11.0083
[@:10.2407	prefix accepted:[
[]:12.1283
((:10.0081	prefix accepted:(
hd:9.92715	rejected
 [(:9.90722	prefix accepted: [
{[:9.89216	rejected
[-:9.51438	prefix accepted:[
tod:9.3713
[":9.3642	prefix accepted:[
<:9.34033	rejected
[::9.25107	prefix accepted:[

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown Internal))])
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo" | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
List:15.7001
hd:14.7277	rejected
#:13.5175	rejected
t:12.6269
f:12.3342
],:11.6978	prefix accepted:]
T:11.437
head:11.3588	rejected
([:10.6496	prefix accepted:(
Ab:10.5742
((:10.5391	prefix accepted:(
h:10.2303	rejected
toggle:10.2226	prefix accepted:to
 #:10.1311	prefix accepted: 
Toggle:10.1114
(":9.99889	prefix accepted:(
 (:9.9838
 List:9.97272
App:9.88358
abs:9.86589
Var:9.84784

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined  
Error in term:
  i - 1, List.tl(todos) @ List
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".contains" | ".eq" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".is_empty" | ".length" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:20.5935
.(:13.3085	prefix accepted:.
_:13.041	rejected
Util:11.4964	rejected
.@:11.2235	prefix accepted:.
(:10.9185	rejected
::10.7762	rejected
.<:10.7715	prefix accepted:.
(":10.0517	rejected
.[:10.0321	prefix accepted:.
#:9.93976	rejected
.__:9.77296	prefix accepted:.
@:9.47281	rejected
/:9.45841	rejected
Element:9.34419	rejected
Hel:9.24977	rejected
[:9.1859	rejected
Utils:9.17559	rejected
._:9.12379	prefix accepted:.
..:9.05821	prefix accepted:.
hd:8.74326	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token  
Error in term:
  i - 1, List.tl(todos) @ List.
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "contains" | "eq" | "filter" | "fold_left" | "fold_right" | "init" | "is_empty" | "length" | "rev" | "tl"
root ::= completions

Top 20 Logits:
hd:22.4229	rejected
head:18.243	rejected
tl:17.9177
nth:17.5539	rejected
rev:16.2298
cons:15.7162
hl:15.5549	rejected
get:15.0307	rejected
html:13.8159	rejected
ht:13.7502	rejected
fold:13.7317
h:13.7312	rejected
first:13.6014	prefix accepted:fi
at:13.3486	rejected
length:13.0483
t:12.9428
nl:12.7882	rejected
reverse:12.6782	prefix accepted:rev
hp:12.6211	rejected
last:12.4656	prefix accepted:l
hs:12.4058	rejected
Rejected the highest logit candidate hd with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.cons>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ((?, [?]) -> [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: List.cons
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((?, [?]) -> [?])
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: List.cons
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "," | "::" | "]"
root ::= new-tokens

Top 20 Logits:
(:16.2756
((:14.7693	prefix accepted:(
([:13.8735	prefix accepted:(
(!:12.1418	prefix accepted:(
(":11.535	prefix accepted:(
],:11.1233	prefix accepted:]
():10.9867	prefix accepted:(
]):10.913	prefix accepted:]
 (:10.8688
#:10.6065	rejected
_:10.3842	rejected
("#:10.2864	prefix accepted:(
<:10.1134	rejected
({:10.1051	prefix accepted:(
(?:9.99136	prefix accepted:(
(@:9.89543	prefix accepted:(
[:9.86591	rejected
($:9.75988	prefix accepted:(
$:9.56174	rejected
(-:9.54417	prefix accepted:(
 #:9.21631	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, [?])
? <= (?, [?])
? <= (?, [?])
  LSP: Convex: Target types: ?, (?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo" | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
List:14.1031
t:13.9506
hd:13.1229	rejected
f:11.915
#:11.3902	rejected
false:11.2216
tod:10.8424
true:10.593
head:10.0643	rejected
 List:10.0472
T:10.0262
s:9.60919
String:9.4009
 #:9.11554	prefix accepted: 
 (:9.07777
h:8.55174	rejected
0:8.54456
i:8.3494
Head:8.34588	rejected
(),:8.34401	prefix accepted:()

:8.32266

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(t

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(t
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "t"))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  t
Nature of error: Variable t is not bound  
Error in term:
  i - 1, List.tl(todos) @ List.cons(t)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: t
LSP: Generating Completions for prefix: t
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 (?, [?])
? <= (?, [?])
? <= (?, [?])
  LSP: Convex: Target types: ?, (?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "an" | "erm_to_string" | "est " | "odo" | "odo_list_eq" | "odos" | "rue" | "ype "
root ::= completions

Top 20 Logits:
odo:18.9439
og:15.3116	prefix accepted:o
ogo:13.4364	prefix accepted:o
oto:12.1003	prefix accepted:o
odos:11.1078
udo:10.2159	rejected
,:10.1767	rejected
ogle:9.66693	prefix accepted:o
ails:9.62278	prefix accepted:a
ado:9.2473	prefix accepted:a
_:9.14752	rejected
oge:9.13738	prefix accepted:o
os:9.03586	prefix accepted:o
1:8.92762	rejected
oda:8.82706	prefix accepted:od
olo:8.74486	prefix accepted:o
ido:8.65584	rejected
odox:8.61405	prefix accepted:odo
ogs:8.54916	prefix accepted:o
uto:8.47097	rejected
ou:8.40723	prefix accepted:o

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(t
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, [?])
  LSP: Info: Seft type: Todo
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana = (Prod [(Unknown TypeHole); (List (Unknown TypeHole))]);
           syn = (Var "Todo")})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  todo
Nature of error: Expecting type (?, [?]) but got inconsistent type Todo  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todo
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Todo
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Var "Todo")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: todo
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Var "Todo")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, [?])
? <= (?, [?])
? <= (?, [?])
  LSP: Convex: Target types: ?, (?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_list_eq" | "s"
new-tokens ::= whitespace | ")" | "," | "::"
root ::= completions | new-tokens

Top 20 Logits:
,:16.4044
_:13.6699
):13.4739
)(:12.779	prefix accepted:)
)]:12.76	prefix accepted:)
@:12.3688	rejected
.:12.3559	rejected
:::12.3216
 @:12.2985	prefix accepted: 
,[:12.1431	prefix accepted:,
,(:11.7569	prefix accepted:,
),:11.5743	prefix accepted:)
)[:11.2145	prefix accepted:)
.[:10.7493	rejected
))]:10.7224	prefix accepted:)
[:10.663	rejected
 ,:10.585
.(:10.4435	rejected
 =:10.3736	prefix accepted: 
)](:10.3104	prefix accepted:)
=:10.289	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, [?])
  LSP: Info: Seft type: (Todo, [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, ?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, [?])
  LSP: Info: Seft type: (Todo, [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, ?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, ?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Var "Todo"); (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, [?])
? <= (?, [?])
? <= (?, [?])
  LSP: Convex: Target types: ?, (?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo" | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:14.5762
 [:13.0403
List:11.8467
 todos:11.829
 (:11.0342
 todo:10.7737
 {:10.5657	prefix accepted: 
 Tod:9.62313
tod:9.58794
 t:9.38322
 xs:9.28432	prefix accepted: 
 :10.5657
 []:8.98963
 nil:8.84274	prefix accepted: n
 ""):8.79115	prefix accepted: ""
 ts:8.75932	prefix accepted: t
 Nil:8.4817	prefix accepted: 
 false:8.35346
 tail:8.33623	prefix accepted: ta
 list:8.27623	prefix accepted: l
 tod:8.24339

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Var "Todo"); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".contains" | ".eq" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".is_empty" | ".length" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:19.6656
.@:11.9821	prefix accepted:.
s:11.4135	rejected
.(:11.0396	prefix accepted:.
.[:10.9306	prefix accepted:.
@:10.7941	rejected
_:10.7565	rejected
(:10.4185	rejected
.<:10.3469	prefix accepted:.
):10.093	rejected
List:9.88723	rejected
 .:9.58146	rejected
<:9.55505	rejected
:::9.51149	rejected
[:9.39612	rejected
()):9.36659	rejected
::9.30115	rejected
():9.11966	rejected
([:9.08433	rejected
[@:8.96866	rejected
)]:8.94137	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Var "Todo"); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "contains" | "eq" | "filter" | "fold_left" | "fold_right" | "init" | "is_empty" | "length" | "rev" | "tl"
root ::= completions

Top 20 Logits:
tl:19.6711
rev:18.5196
hd:17.7057	rejected
filter:16.6671
head:15.8962	rejected
init:15.4454
tail:15.4227	prefix accepted:t
reverse:15.3545	prefix accepted:rev
eq:14.8799
length:14.3784
hl:14.2462	rejected
nil:13.9787	rejected
is:13.9011
cons:13.7752
td:13.2167	prefix accepted:t
empty:13.0514	prefix accepted:e
rest:12.8597	prefix accepted:re
fold:12.837
get:12.8369	rejected
drop:12.6985	rejected
nth:12.6733	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ([?] -> [?])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown TypeHole));
           syn =
           (Arrow ((List (Unknown TypeHole)), (List (Unknown TypeHole))))})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  List.tl
Nature of error: Expecting type [?] but got inconsistent type ([?] -> [?])  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: List.tl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ([?] -> [?])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Var "Todo"); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: List.tl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Var "Todo"); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "::"
root ::= new-tokens

Top 20 Logits:
(:19.2023
((:13.7445	prefix accepted:(
([:12.197	prefix accepted:(
(@:11.7773	prefix accepted:(
 (:11.4288
()):11.3302	prefix accepted:(
[:11.0642	rejected
(!:10.8539	prefix accepted:(
):10.7942
 todos:10.5786	prefix accepted: 
({:10.553	prefix accepted:(
 List:10.193	prefix accepted: 
_:10.1271	rejected
)(:10.1126	prefix accepted:)
(*:9.98857	prefix accepted:(
(&:9.90612	prefix accepted:(
{:9.79829	rejected
)]:9.33361	prefix accepted:)
[]):9.26319	rejected
@:9.12594	rejected
List:9.01693	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(?))
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(?))
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(?))
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Var "Todo"); (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo" | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
tod:17.1543
List:16.6261
t:13.0779
td:11.9794	prefix accepted:t
tail:11.6654	prefix accepted:ta
 todos:11.3365
 List:11.2143
list:10.7485	prefix accepted:l
xs:10.4835	rejected
ts:9.85673	prefix accepted:t
rest:9.34448	rejected
to:9.27012
hd:9.24325	rejected
ToList:9.05001	prefix accepted:To
tot:8.96612	prefix accepted:to
tok:8.92517	prefix accepted:to
tl:8.8966	prefix accepted:t
tol:8.84351	prefix accepted:to
go:8.69178
lists:8.65341	prefix accepted:l
x:8.42612	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(tod

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(tod
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <tod>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "tod"))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  tod
Nature of error: Variable tod is not bound  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(tod))
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: tod
LSP: Generating Completions for prefix: tod
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, [?]
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "o" | "o_list_eq" | "os"
root ::= completions

Top 20 Logits:
os:23.5341
otos:14.4432	prefix accepted:o
ios:14.1551	rejected
odos:13.2093	prefix accepted:o
ores:12.142	prefix accepted:o
ols:12.0369	prefix accepted:o
ros:11.9884	rejected
ors:11.9333	prefix accepted:o
oso:11.6587	prefix accepted:os
 os:11.6478	rejected
ots:11.4081	prefix accepted:o
o:14.4432
osa:11.06	prefix accepted:os
ocs:11.0353	prefix accepted:o
osos:10.9826	prefix accepted:os
ods:10.6309	prefix accepted:o
els:10.5616	rejected
d:10.3284	rejected
ows:10.2132	prefix accepted:o
ones:10.1377	prefix accepted:o
ools:10.1293	prefix accepted:o

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(tod
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos))
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, [?]
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: todos
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, [?]
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
)):18.956	prefix accepted:)
))]:15.507	prefix accepted:)
):18.956
)),:12.987	prefix accepted:)
)]:12.9439	prefix accepted:)
),:12.7077	prefix accepted:)
)[:12.4391	prefix accepted:)
)).:11.37	prefix accepted:)
));:11.1569	prefix accepted:)
)-:10.7853	prefix accepted:)
[@:10.7532	rejected
 @:10.7378
@:10.5354
)+:10.4673	prefix accepted:)
)*:10.0586	prefix accepted:)
)->:10.0364	prefix accepted:)
]):9.94095	rejected
)))):9.93804	prefix accepted:)
[:9.83578	rejected
).:9.63684	prefix accepted:)
)^:9.47895	prefix accepted:)
Rejected the highest logit candidate )) with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos))
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Var "Todo"); (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
@:15.6147
 @:15.1728
 ):14.558
]):13.5712	rejected
 ]:11.3012	prefix accepted: 
 $:11.2346	prefix accepted: 
@@:11.0197	prefix accepted:@
 in:10.9831	prefix accepted: 
 :11.3012

:10.6509
 -:10.6079	prefix accepted: 
][:10.6035	rejected
 |:10.5472	prefix accepted: 
],:10.0511	rejected
 as:9.996	prefix accepted: 
:::9.84247
 *:9.79859	prefix accepted: 
 +:9.69694	prefix accepted: 
!):9.54153	rejected
*):9.4945	rejected
@{:9.15269	prefix accepted:@

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ ?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ ?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ ?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Var "Todo"); (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo" | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
[]):19.1889	prefix accepted:[]
[:15.7519
[]:19.1889
[(:12.7488	prefix accepted:[
List:12.6013
[[:11.9654	prefix accepted:[
 [:11.637
(:11.0521
([:10.9761	prefix accepted:(
ts:10.8799	prefix accepted:t
[@:10.4144	prefix accepted:[
[^:10.1484	prefix accepted:[
[::10.129	prefix accepted:[
nil:9.98107	prefix accepted:n
xs:9.86967	rejected
[-:9.79966	prefix accepted:[
t:10.8799
[":9.77225	prefix accepted:[
_):9.73682	rejected
):9.66747	rejected
()):9.55698	prefix accepted:()
Rejected the highest logit candidate []) with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[]

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[]
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: []
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: :: @
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Var "Todo"); (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: []
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, (?, [?])
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Var "Todo"); (List (Unknown Internal))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
),:12.2124	prefix accepted:)
 ):12.1602
).:11.2163	prefix accepted:)
]):10.9971	rejected
)):10.8241	prefix accepted:)
)::10.6046	prefix accepted:)
);:10.5878	prefix accepted:)
 @:10.4968
))):9.52773	prefix accepted:)
 :9.18171
@:9.17265
)$:8.90948	prefix accepted:)
 ]:8.73601	prefix accepted: 
 |:8.65557	prefix accepted: 
))]:8.6333	prefix accepted:)

:8.6009
 as:8.14732	prefix accepted: 
[@:8.11854	rejected
),(:8.08664	prefix accepted:)
[]):8.0392	rejected
:::7.92747
Rejected the highest logit candidate ), with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "@" | "]"
root ::= new-tokens

Top 20 Logits:
]):15.827	prefix accepted:]
],:14.9899	prefix accepted:]
 ],:12.5258	prefix accepted: ]
 ]:12.5258
 :12.2396
 @:11.7842
]:15.827
@:11.3241
 $:11.2588	prefix accepted: 
 in:10.6409	prefix accepted: 
[:10.4578	rejected
 |:10.105	prefix accepted: 

:9.94368
][:9.89731	prefix accepted:]
  :9.71862
[@:9.5679	rejected
in:9.24029	rejected
]);:8.58079	prefix accepted:]
 end:8.35432	prefix accepted: 
 ?:8.35088	prefix accepted: 
),:8.29013	rejected
Rejected the highest logit candidate ]) with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )]

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )]
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [[?]]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [[?]]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ):15.2193
 ,:14.5188
@:13.2638
 @:12.962
 :12.7374

:12.0749
  :11.8604
   :10.9168
 |:10.115	prefix accepted: 
    :9.58279
 );:9.31328	prefix accepted: )
     :9.30872
 in:9.22855	prefix accepted: 
 ||:8.98019	prefix accepted: 
 end:8.92869	prefix accepted: 
@@:8.89181	prefix accepted:@
                :8.70556
 (:8.66149	prefix accepted: 
()):8.64201	rejected
      :8.60602
#:8.56012	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:

:18.2412
 :15.8727
  :15.0497
 else:14.9087
 #:14.6305	prefix accepted: 
   :14.5932
#:14.1708	rejected
    :14.0965
 @:14.055
                :13.9794
 end:13.9156	prefix accepted: e
 in:13.7366	prefix accepted: 
@:13.1173
        :12.9303
            :12.7487
     :12.7077
 (*:12.5319	prefix accepted: 
      :12.4321
             :12.2226
         :11.7214
              :11.6943

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:
           :19.6415
            :15.5148
               :15.2662
                :14.9367
          :14.4192
       :14.0646
             :14.0275
else:13.7608

:13.614
   :13.5041
	:13.1425	rejected
              :13.0394
         :12.6551
        :12.6517
#:11.9289	rejected
    :11.7318
     :11.563
      :11.1207
 else:11.0534
end:10.9863	prefix accepted:e
  :10.848

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
           

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
           
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Cons
  LSP: Info: BidiCtx: Expected type: [Todo]
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: String, [Todo], (String, Bool)
  LSP: Concave: Infix: Lookahead: @
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "else"
root ::= new-tokens

Top 20 Logits:
 else:23.4498
 end:17.669	prefix accepted: e
 elif:16.9985	prefix accepted: el
 els:16.8407
 #:15.7874	prefix accepted: 
 if:13.8292	prefix accepted: 
 todo:13.548	prefix accepted: 
 case:12.6294	prefix accepted: 
 !:12.3345	prefix accepted: 
 []:11.9309	prefix accepted: 
 (*:11.8853	prefix accepted: 
 Tod:11.8167	prefix accepted: 
 (:11.7725	prefix accepted: 
 Else:11.7194	prefix accepted: 
 {:11.6591	prefix accepted: 
 //:11.5584	prefix accepted: 
 let:11.4863	prefix accepted: 
 el:16.9985
 List:11.338	prefix accepted: 
 in:11.2816	prefix accepted: 
 match:11.2578	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:

:17.7735
 :15.8163
 [:14.5265
 todo:14.1453
 []:13.832
 if:13.7106
    :13.4727
  :13.3543
 List:13.1341
   :13.1236
 #:12.9354	prefix accepted: 
 (:12.8212
            :12.1677
 toggle:11.9511	prefix accepted: to
                :11.8912
 !:11.8075	prefix accepted: 
 todos:11.6099
        :11.5158
 Tod:11.4732	prefix accepted: 
 go:11.0979
 {:10.9484	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
               :21.2496
              :18.8533
                :18.5388
             :18.0025
           :16.4904
            :16.2216
	:15.0854	rejected
          :14.1646
#:13.9785	rejected
   :13.6756

:13.352
         :13.24
       :13.0882
        :12.6278
    :12.0262
      :11.8584
 #:11.7709	prefix accepted: 
     :11.6914
  :11.5683
 :11.7709
[]:10.6952

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
               

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
               
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 [:15.4751
 todo:15.2134
 #:14.1264	prefix accepted: 
 List:14.0923
 (:13.9751
 []:13.7156
 let:12.9369
 toggle:12.4898	prefix accepted: to
 !:12.4714	prefix accepted: 
 [(:12.2482	prefix accepted: [
 Tod:12.1814	prefix accepted: 
 todos:12.1054
 go:11.7267
 if:11.4848
 true:11.2039	prefix accepted: t
 false:11.1007	prefix accepted: 
 ((:10.9094	prefix accepted: (
 ([:10.8818	prefix accepted: (
 case:10.7336
 f:10.6803	prefix accepted: 
 {:10.664	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
               
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 [:15.6007
 todo:15.1203

:14.7052
 List:14.6831
 #:14.5758	prefix accepted: 
 (:14.1483
 []:13.7453
 let:12.9552
 toggle:12.7882	prefix accepted: to
 [(:12.491	prefix accepted: [
 Tod:12.2945	prefix accepted: 
 if:12.0202
 go:11.9467
 todos:11.8908
 case:11.8198
 #[:11.5399	prefix accepted: 
 f:11.2112	prefix accepted: 
 true:11.2032	prefix accepted: t
 !:11.1531	prefix accepted: 
 ([:11.0299	prefix accepted: (
 {:10.9182	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo type  ~STRINGLIT~
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "Model.get_buffer" | "String.reverse" | "String.transform" | "case " | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todo" | "type " | stringlit
root ::= completions | new-tokens

Top 20 Logits:
t:13.5371
List:13.2045
T:12.3963	rejected
f:12.0066	rejected
#:11.919	rejected
toggle:10.9756	prefix accepted:to
 todo:10.9706
 List:10.967
 (:10.5731
hd:10.5091	rejected
true:9.97751	prefix accepted:t
not:9.94373	rejected
s:9.94103
!:9.66858	rejected
 Tod:9.54227	prefix accepted: 
if:9.52974
false:9.45439	rejected
([:9.43943	prefix accepted:(
((:9.1513	prefix accepted:(

:9.14408
Ab:9.13819	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: ++
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".fold_left" | ".fold_right"
root ::= completions

Top 20 Logits:
.:19.8815
(:11.9668	rejected
_:11.7791	rejected
.(:11.2651	prefix accepted:.
(":10.832	rejected
{:10.191	rejected
:::10.1107	rejected
.[:10.0048	prefix accepted:.
::9.8691	rejected
([:9.73141	rejected
((:9.69502	rejected
[:9.66692	rejected
#:9.61743	rejected
 (:9.34683	rejected
@:9.26055	rejected
 {:8.93816	rejected
..:8.7354	prefix accepted:.
Cons:8.6964	rejected
T:8.65015	rejected
 .:8.57472	rejected
]:8.56036	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: ++
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "fold_left" | "fold_right"
root ::= completions

Top 20 Logits:
hd:18.5984	rejected
cons:18.5551	rejected
tl:17.2161	rejected
head:16.4679	rejected
rev:16.2486	rejected
reverse:15.4095	rejected
fold:15.315
transform:13.8024	rejected
update:13.7754	rejected
hl:13.4112	rejected
nth:13.3826	rejected
tail:12.743	rejected
concat:12.6252	rejected
init:12.5883	rejected
filter:12.491	prefix accepted:f
map:12.3551	rejected
get:12.0902	rejected
ht:12.0709	rejected
toggle:11.9978	rejected
Cons:11.8541	rejected
con:11.8199	rejected
Rejected the highest logit candidate hd with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold"))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  List.fold
Nature of error: Variable List.fold is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold
LSP: Generating Completions for prefix: List.fold
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: ++
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_left" | "_right"
root ::= completions

Top 20 Logits:
_:22.8921
r:16.0238	rejected
l:15.7561	rejected
(:15.0071	rejected
((:14.3936	rejected
([:14.1477	rejected
 (:12.5274	rejected
left:11.2315	rejected
Left:10.7745	rejected
right:10.7034	rejected
]:10.6848	rejected
():10.6667	rejected
_(:10.5995	prefix accepted:_
[:10.5136	rejected
(*:10.4559	rejected
2:10.2072	rejected
 left:10.198	rejected
Right:10.1072	rejected
](:9.92422	rejected
(!:9.87247	rejected
(@:9.79114	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "List.fold_"))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  List.fold_
Nature of error: Variable List.fold_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List.fold_
LSP: Generating Completions for prefix: List.fold_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: ++
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "left" | "right"
root ::= completions

Top 20 Logits:
left:25.8896
right:25.256
reverse:15.2264	prefix accepted:r
with:15.131	rejected
head:15.0782	rejected
back:14.9676	rejected
bottom:14.7453	rejected
rig:14.596
last:14.5667	prefix accepted:l
top:14.4812	rejected
r:15.2264
down:14.3351	rejected
list:14.3146	prefix accepted:l
first:14.2634	rejected
front:14.1165	rejected
l:14.5667
at:14.061	rejected
tail:14.0366	rejected
map:14.0295	rejected
init:14.0225	rejected
lef:13.7487

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.fold_left>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "Todo");
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                     (Unknown TypeHole)));
                   (Unknown TypeHole); (List (Unknown TypeHole))]),
              (Unknown TypeHole)))})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  List.fold_left
Nature of error: Expecting type Todo but got inconsistent type ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: List.fold_left
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((((?, ?) -> ?), ?, [?]) -> ?)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: String Bool
LSP: commas: self syn is (Arrow (
   (Prod
      [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
          (Unknown TypeHole)));
        (Unknown TypeHole); (List (Unknown TypeHole))]),
   (Unknown TypeHole)))
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: List.fold_left
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String Bool
LSP: commas: self syn is (Arrow (
   (Prod
      [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
          (Unknown TypeHole)));
        (Unknown TypeHole); (List (Unknown TypeHole))]),
   (Unknown TypeHole)))
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "]"
root ::= new-tokens

Top 20 Logits:
((:17.1553	prefix accepted:(
(:17.1553
([:13.0886	prefix accepted:(
 (:12.669
(?:11.7438	prefix accepted:(
 ((:11.5787	prefix accepted: (
(():10.7511	prefix accepted:(
(|:10.1943	prefix accepted:(

:10.1512
():10.0173	prefix accepted:(
(@:10.0038	prefix accepted:(
<:9.93732	rejected
(&:9.85874	prefix accepted:(
(\:9.80092	prefix accepted:(
[:9.72856	rejected
(":9.48992	prefix accepted:(
(*:9.43925	prefix accepted:(
({:9.30921	prefix accepted:(
(::9.18204	prefix accepted:(
($:8.95359	prefix accepted:(
]:8.92565
Rejected the highest logit candidate (( with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] in in
  LSP: Info: ALL errors:
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Bool.eq List.cons List.contains List.filter List.fold_left List.fold_right List.init Model.eq String.starts_with String.transform Todo.eq case  fun  if  let  mod string_compare string_concat todo_list_eq type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String Bool
LSP: commas: self syn is (Unknown TypeHole)
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Todo
String <= Todo
String <= Todo
  LSP: Convex: Target types: String, Todo
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todo ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right Model.get_buffer String.reverse String.transform case  if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todo type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "Abs" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "Model.eq" | "String.starts_with" | "String.transform" | "Todo.eq" | "case " | "fun " | "if " | "let " | "mod" | "string_compare" | "string_concat" | "todo_list_eq" | "type "
root ::= new-tokens

Top 20 Logits:
fun:13.7238
 (:12.6504
T:11.8261

:11.4915
 fun:11.3799
fn:10.6741	prefix accepted:f
lambda:10.665	prefix accepted:l
f:10.6741
List:10.3134
Bool:9.82905
 :9.61532
String:9.61089
 f:9.20938
Model:9.04584
 T:9.04487
t:8.86917
func:8.6273	prefix accepted:fun
op:8.60944	rejected
 List:8.59097
toggle:8.55262	prefix accepted:to
 lambda:8.53163	prefix accepted: l

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ? ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddTodo" | "App" | "RemoveTodo" | "Reverse" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 (:14.3589
 acc:14.1115
 x:13.8517
 a:13.3503
 t:12.1208
 todo:12.0441
 xs:11.6066
 s:11.5344
 _,:11.3995	prefix accepted: _
 b:11.2729
 l:10.9217
(:10.682
 y:10.3955
 state:10.2927
 f:10.2555
 z:10.0799
 _:11.3995
 p:9.9163
 ac:9.89998
 prev:9.88294
 new:9.83717

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun (?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun (?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun (?) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddTodo" | "App" | "RemoveTodo" | "Reverse" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= completions | new-tokens

Top 20 Logits:
_,:14.2665	prefix accepted:_
x:13.911
acc:13.6476
a:13.562
s:12.8847
b:12.7324
t:12.2861
d:11.8805
desc:11.5461
hd:11.3248
description:11.3195
old:11.0433
prev:10.6319
T:10.6284
xs:10.4671
bool:10.3782
ac:10.2935
f:10.2503
p:10.1442
done:10.1421
status:10.1107
Rejected the highest logit candidate _, with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (t

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (t
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <t>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {t: ?, todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun (t) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: t
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: t
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "rue" | extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
odo:15.1623
1:13.9976
,:13.7164
::13.6935
og:12.1005
2:11.2149
',:11.1771	rejected
_:10.7125
0:10.4329
 ::10.3218
ogo:10.303
:::9.9647
old:9.94852
g:9.74664
_,:9.68372	prefix accepted:_
):9.63552
oto:9.54893
up:9.26422
 ,:9.23679
,(:8.84425	prefix accepted:,
acc:8.83597

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (t
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: ?, todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun (todo) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (? -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: todo
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todo
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
1:15.3303
2:15.2963
,:15.1122
',:14.7167	rejected
_:14.3456
::14.1266
_,:13.2306	prefix accepted:_
0:12.0349
 ::11.4296
):10.8308
),:10.7305	prefix accepted:)
'::10.5908	rejected
)::10.5081	prefix accepted:)
Acc:10.4072
acc:10.2437
 ,:10.2362
,(:10.2012	prefix accepted:,
'):10.1256	rejected
':9.88684	rejected
A:9.75627
3:9.58713

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: ?, todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, ?)) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: ?, todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, ?)) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: ?, todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, ?)) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddTodo" | "App" | "RemoveTodo" | "Reverse" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 acc:13.1276
 todos:12.2989
 todo:11.9073
 new:11.4257
 _):11.15	prefix accepted: _
 x:11.0712
 t:11.0505
 togg:10.8349
 (:10.8247
 s:10.4371
 state:10.3882
 status:10.3812
 toggle:10.3734
acc:10.297
 bool:10.2943
 rest:10.2634
 next:10.1406
 result:10.1052
 _,:9.99753	prefix accepted: _
 flag:9.78621
 done:9.77826

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Wildcard
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: ?, todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) -> ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Parenthesized pattern
  LSP: Syntax: Can insert left-concave or complete: _
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: _
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddTodo App RemoveTodo Reverse ToggleTodo Trim UpdateBuffer Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "," | ":" | "::"
root ::= new-tokens

Top 20 Logits:
),:14.7326	prefix accepted:)
acc:13.6571	rejected
t:13.0011	rejected
)->:12.8998	prefix accepted:)
 ):12.5425
::11.9266
:::11.8054
)::11.625	prefix accepted:)
)=:11.5515	prefix accepted:)
s:11.0375	rejected
x:10.7874	rejected
new:10.6509	rejected
state:10.6061	rejected
old:10.5008	rejected
 ),:10.4349	prefix accepted: )
rest:10.1783	rejected
is:10.1492	rejected
status:9.98088	rejected
next:9.95617	rejected
 ::9.86777
index:9.77292	rejected
Rejected the highest logit candidate ), with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized pattern
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: ?, todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Parenthesized pattern
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "->" | ":" | "::"
root ::= new-tokens

Top 20 Logits:
 ->:16.1102
 acc:13.8898	prefix accepted: 
 x:12.5262	prefix accepted: 
 (:12.5074	prefix accepted: 
 new:11.3877	prefix accepted: 
 _:11.1134	prefix accepted: 
 todo:11.0408	prefix accepted: 
 h:10.9714	prefix accepted: 
 t:10.8558	prefix accepted: 
 (_:10.8025	prefix accepted: 
 a:10.7896	prefix accepted: 
 s:10.7541	prefix accepted: 
 :13.8898
 =>:10.5294	prefix accepted: 
 xs:10.5238	prefix accepted: 
 result:10.2131	prefix accepted: 
 e:10.1956	prefix accepted: 
 rest:10.1955	prefix accepted: 
 =:10.0803	prefix accepted: 
 f:10.0178	prefix accepted: 
 _,:10.007	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) ->

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) ->
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: ?, todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todo todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo" | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 todo:14.3116
 Tod:11.6225
 if:11.5434
 List:11.3194
 (:11.2307

:11.0152
 !:10.8915
 :10.7743
 [:10.6589
 toggle:10.5782	prefix accepted: to
 f:10.5438
 t:10.4715
 fun:10.401
 not:10.3602	prefix accepted: n
 true:9.90457
 _,:9.62764	prefix accepted: 
 {:9.47004	prefix accepted: 
 #:9.42205	prefix accepted: 
 (!:9.17513	prefix accepted: (
 ((:9.1436	prefix accepted: (
t:9.06619

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todo>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todo: ?, todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type ((?, ?) -> ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todo
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todo
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow ((Prod [(Unknown Internal); (Unknown Internal)]), (Unknown Internal)))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todo todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_list_eq" | "s"
new-tokens ::= whitespace | "!=" | "!=." | "$==" | "&&" | "(" | ")" | "*" | "**" | "**." | "*." | "+" | "++" | "+." | "," | "-" | "-." | "/" | "/." | "::" | "<" | "<." | "<=" | "<=." | "==" | "==." | ">" | ">." | ">=" | ">=." | "@" | "\\/"
root ::= completions | new-tokens

Top 20 Logits:
,:15.5022
 ,:13.4898
),:12.7198	prefix accepted:)
 end:12.6453	prefix accepted: 
:::11.7729
):12.7198
 :12.6453
,[:11.1329	prefix accepted:,
.:11.0014	rejected
 ):10.8022
)(:10.6764	prefix accepted:)
 $:10.4616
 =:10.2251
 ),:10.092	prefix accepted: )
,(:10.0292	prefix accepted:,
(:9.95858

:9.77681
 :::9.7036
)]:9.49301	prefix accepted:)
 in:9.36775	prefix accepted: 
  :9.17498

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> ?), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (Unknown Internal)));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Seft type: (((?, ?) -> ?), ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]),
                  (Unknown TypeHole)));
                (Unknown TypeHole); (List (Unknown TypeHole))]);
           syn =
           (Prod
              [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
                  (Unknown Internal)));
                (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, ?
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), ?)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (Unknown Internal)));
     (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
((?, ?) -> ?) <= (((?, ?) -> ?), ?, [?])
  LSP: Convex: Target types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( Abs App Bool.eq List.cons List.contains List.filter List.fold_left List.fold_right List.init Model.eq String.starts_with String.transform Todo.eq case  fun  if  let  mod string_compare string_concat todo_list_eq type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo" | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 true:11.517
 in:11.5114
 false:11.0967

:11.0115
 Bool:10.7455
 Tod:10.4582
 [:10.2534
 (:9.97128
 todo:9.92886
 :9.76915
 not:9.73372	prefix accepted: n
 fun:9.73066
 List:9.51046
 !:9.51012
 f:9.39455
 [],:9.2337	prefix accepted: []
 ([:9.1902	prefix accepted: (
 s:8.90428
 _):8.82933	prefix accepted: 
 toggle:8.79251	prefix accepted: to
 Model:8.73081

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <true>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Boolean literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (((?, ?) -> ?), ?, [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: true
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/ ::
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (Unknown Internal)));
     Bool])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && :: \/
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: true
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ((?, ?) -> ?), (((?, ?) -> ?), ?, [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Prod [(Unknown TypeHole); (Unknown TypeHole)]), (Unknown TypeHole))) (Unknown TypeHole) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod
   [(Arrow ((Prod [(Unknown Internal); (Unknown Internal)]),
       (Unknown Internal)));
     Bool])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos todo i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | ")" | "::" | "\\/"
root ::= new-tokens

Top 20 Logits:
,:14.8131	rejected
 end:13.8762	prefix accepted: 
)]:13.8133	prefix accepted:)
),:13.584	prefix accepted:)
 ,:13.3596	prefix accepted: 
):13.8133
 ):11.6598
 in:11.6161	prefix accepted: 
)(:11.2309	prefix accepted:)
 :13.8762
 ),:10.8337	prefix accepted: )
)[:10.574	prefix accepted:)

:10.2036
 =:10.1116	prefix accepted: 
,[:9.87298	rejected
 |:9.73248	prefix accepted: 
;:9.67381	rejected
  :9.53453
:::9.5162
)](:9.29668	prefix accepted:)
)):9.00186	prefix accepted:)
Rejected the highest logit candidate , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Todo
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Todo
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: String, Todo
  LSP: Concave: Infix: Lookahead: ++
LSP: commas: p_ana is prod: String Bool
LSP: commas: self syn is (Unknown TypeHole)
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ++
  LSP: Concave: Postfix: (
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "++" | "," | "]"
root ::= new-tokens

Top 20 Logits:
 ]:15.5715
 (:14.5187
((:14.0504	prefix accepted:(
([:13.5433	prefix accepted:(

:12.7551
 ,:12.7489
 todo:12.5973	prefix accepted: 
 :12.5973
 |:12.0057	prefix accepted: 
 ((:11.8535	prefix accepted: (
 in:11.549	prefix accepted: 
 ([:11.4494	prefix accepted: (
 todos:10.9848	prefix accepted: 
():10.9577	prefix accepted:(
  :10.756
][:10.714	prefix accepted:]
],:10.7002	prefix accepted:]
 @:10.6117	prefix accepted: 
 for:10.4482	prefix accepted: 
($:10.3252	prefix accepted:(
]):10.2954	prefix accepted:]

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ]

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ]
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:

:17.1293
 end:15.9749	prefix accepted: 
 :15.9749
  :15.0239
 in:14.742
 @:14.2876
   :14.2545
    :14.0021
                :13.7377
end:13.5841	rejected
            :13.1966
 #:12.856	prefix accepted: 
        :12.6624
     :12.6314
             :12.4006
       :12.3794
#:12.3537	rejected
      :12.3192
@:12.2841
              :11.8217
         :11.8086

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:

:19.8154
 end:17.4853	prefix accepted: 
 in:17.3376
 @:15.9495
 todos:15.4718	prefix accepted: 
 #:15.3432	prefix accepted: 
 (*:14.4375	prefix accepted: 
 todo:14.2014	prefix accepted: 
 (@:12.9748	prefix accepted: 
 //:12.7102	prefix accepted: 
 =:12.4821	prefix accepted: 
	:12.4121	rejected
 +:12.3691	prefix accepted: 
 []:12.2198	prefix accepted: 
 ():12.0908	prefix accepted: 
 ++:11.9783	prefix accepted: 
 (:11.926	prefix accepted: 
 :::11.9048	prefix accepted: 
 --:11.8836	prefix accepted: 
 ;:11.8471	prefix accepted: 
 *:11.6946	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:
   :17.8852
       :16.1933
in:15.18
           :15.0928
                :13.8841
            :13.8124
    :13.2979
        :13.2868
end:13.0761	rejected

:12.6352
               :12.6333
          :12.4846
  :12.3296
     :12.0677
         :11.9108
      :11.7251
             :11.5359
 in:11.3609
 :11.2404
              :11.0522
	:10.074	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
   

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
   
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], todo: Todo, i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:
 in:21.9267
 end:17.1412	prefix accepted: 
 fun:15.4053	prefix accepted: 
 go:15.0799	prefix accepted: 
 let:14.2075	prefix accepted: 
 #:13.0586	prefix accepted: 
 return:12.5151	prefix accepted: 
 (*:12.2297	prefix accepted: 

:12.137
 if:12.1285	prefix accepted: i
 and:11.8387	prefix accepted: 
 todo:11.5919	prefix accepted: 
 List:11.5727	prefix accepted: 
 case:11.5435	prefix accepted: 
 (:11.3316	prefix accepted: 
 print:10.9764	prefix accepted: 
 else:10.8976	prefix accepted: 
 todos:10.8804	prefix accepted: 
 match:10.4376	prefix accepted: 
 |:10.3834	prefix accepted: 
 tail:10.3485	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:18.2808
 go:16.9049	prefix accepted: 
 :16.9049
 fun:15.3384
    :15.2558
  :14.8024
        :13.0587
   :13.0293
                :12.8877
     :12.7923
            :12.649
       :12.3136
      :12.0826
 function:12.0118	prefix accepted: fun
 List:11.9987
 case:11.9331
         :11.5217
 (:11.3476
          :11.1564
 match:10.9517	prefix accepted: 
 func:10.8878	prefix accepted: fun

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
   :17.491
       :15.9503
    :14.803
go:13.9953	rejected

:13.9735
  :13.8834
 :12.8452
fun:12.8018
     :12.347
        :12.0728
let:11.8753
      :11.7684
           :11.3923
	:11.2785	rejected
 go:11.2645	prefix accepted: 
 fun:11.1012
in:11.06	prefix accepted:i
                :10.9946
func:10.8076	prefix accepted:fun
#:10.7096	rejected
            :10.6761

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
   

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
   
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((Int, [Todo]) -> [Todo])
  LSP: Convex: Target types: ((Int, [Todo]) -> [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 fun:18.316
 go:16.8093	prefix accepted: 
 let:14.3712
 if:13.3263
 case:13.2112
 function:12.818	prefix accepted: fun
 (:12.5843
 #:12.4131	prefix accepted: 
 List:12.0158
 match:11.9779	prefix accepted: 
 todo:11.8143	prefix accepted: t
 lambda:11.6176	prefix accepted: l
 func:11.4177	prefix accepted: fun
 fn:11.2099	prefix accepted: f
 len:10.7126	prefix accepted: le
 todos:10.4367	prefix accepted: t
 toggle:10.3618	prefix accepted: t
 i:10.3252
 list:10.2738	prefix accepted: l
 \:9.89811	prefix accepted: 
 print:9.82703	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
 i:17.9962
 index:16.9118
 idx:15.8781
 n:14.105
 (:13.5295
 x:13.3371
 id:13.2874
 todo:12.8711
 pos:12.8091
 ind:12.0412
 :11.6044
 position:11.5674
 k:11.2956
(:11.25
 t:11.063
 toggle:11.0549
 item:10.9542
 number:10.7785
 num:10.6631
 todos:10.5279
 at:10.4435

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <i>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {i: (Int, [Todo]), go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: i
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: i
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:17.0282
 ->:14.0574
 ,:13.6284
 todos:13.0955	prefix accepted: 
 xs:12.498	prefix accepted: 
x:11.9792
 todo:11.9765	prefix accepted: 
 =>:10.9153	prefix accepted: 
xs:10.4482
::10.3963	rejected
 x:10.3778	prefix accepted: 
 t:10.2001	prefix accepted: 
->:10.1664
 =:9.77733	prefix accepted: 
 ts:9.7678	prefix accepted: 
 :13.0955
1:9.40553
 l:9.38753	prefix accepted: 
 list:9.30517	prefix accepted: 
 tod:9.27467	prefix accepted: 
 index:9.13344	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (Int, [Todo])
  LSP: Info: Seft type: (Int, [Todo])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 todos:17.2247
 todo:14.254
 xs:13.9655
 ts:13.6263
 l:12.9123
 list:11.9215
 ls:11.7326
 x:11.3205
 lst:11.1473
 tod:11.004
 t:10.9263
 [:10.3119
 :10.1912
 items:10.1408
 model:9.9569
 Tod:9.9469	prefix accepted: 
 []:9.48994
 (:9.46053
 _:9.353
 td:9.34035
 state:9.30449

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (Int, [Todo])
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: todos
LSP: commas: p_ana is prod: Int (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Var "Todo"))])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: [] _ ~PATVAR~ ( [
  LSP: Convex: Lookahead: ( [ [] _ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->" | ":" | "::"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.0291
->:14.6266
 :13.4755
 =:12.2331	prefix accepted: 
,:11.8916	rejected

:11.7926
 =>:11.2764	prefix accepted: 
_:10.8361
 -:10.7795
  :10.4137
::10.0656
 in:9.92897	prefix accepted: 
1:9.8435
':9.78519	rejected
=:9.66897	rejected
2:9.53895
 ?:9.34617	prefix accepted: 
 when:9.10727	prefix accepted: 
 list:9.09059	prefix accepted: 
 ::9.06543
 -->:8.99095	prefix accepted: -

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos ->

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos ->
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.rev" | "List.tl" | "Model.get_buffer" | "Model.get_todo_list" | "String.reverse" | "String.transform" | "[" | "[]" | "case " | "go" | "if " | "let " | "string_concat" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "term_to_string" | "todos" | "type " | stringlit
root ::= new-tokens

Top 20 Logits:
 go:17.7614

:16.4567
 :15.0919
 if:14.3339
 List:13.4119
  :13.036
    :12.8058
go:12.0472
 todo:11.8996
 todos:11.6854
 (:11.4693
 case:11.2676
        :11.25
   :11.0162
 match:11.0049	prefix accepted: 
 #:10.865	prefix accepted: 
     :10.6948
                :10.6685
 i:10.6447
            :10.6408
 [:10.5946

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <go>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Var "Todo"));
           syn =
           (Arrow ((Prod [Int; (Var "Todo"); (List (Var "Todo"))]),
              (List (Var "Todo"))))})))
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  go
Nature of error: Expecting type [Todo] but got inconsistent type ((Int, Todo, [Todo]) -> [Todo])
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: go
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ((Int, Todo, [Todo]) -> [Todo])
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ((Int, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: go
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((Int, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "in"
root ::= new-tokens

Top 20 Logits:
(:20.896
 (:16.7085
 i:15.9871
(-:15.108	prefix accepted:(
((:14.8953	prefix accepted:(
([:13.1456	prefix accepted:(
::12.3271	rejected
 (-:12.1334	prefix accepted: (
(@:12.0224	prefix accepted:(
 :11.9851

:11.9647
():11.9084	prefix accepted:(
i:11.773
 ((:11.6344	prefix accepted: (
 end:11.4002	prefix accepted: 
[:11.3635	rejected
(?:11.2034	prefix accepted:(
.(:10.9916	rejected
(::10.791	prefix accepted:(
(|:10.5517	prefix accepted:(
:::10.5371	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
  LSP: Convex: Target types: Int, (Int, Todo, [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ((Int, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [Todo]
(String, Bool) <= [Todo]
(String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
String <= (String, Bool) <= [Todo]
  LSP: Convex: Target types: String, [Todo], (String, Bool)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ( List.cons List.filter List.fold_left List.fold_right List.init List.rev List.tl Model.get_buffer Model.get_todo_list String.reverse String.transform [ [] case  go if  let  string_concat string_of_bool string_of_float string_of_int string_sub string_trim term_to_string todos type  ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "i" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
i:19.4558
 i:13.5699
0:13.1765
List:12.7605
length:11.6655	prefix accepted:le
1:11.5018
tod:11.4562	prefix accepted:t
Int:11.416	rejected
string:11.2492
--:11.2008	prefix accepted:-
len:11.1311	prefix accepted:le
int:10.9043
String:10.3563	rejected
 (:10.0811
 List:9.93236
2:9.69329
t:11.4562
list:9.55937	prefix accepted:l
if:9.31749
index:9.31441	prefix accepted:in
Length:9.25617	prefix accepted:L

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <i>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: Int
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Var "Todo"); (List (Var "Todo"))]);
           syn = Int})))
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type Int  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: i
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Int
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: i
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is Int
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
  LSP: Convex: Target types: Int, (Int, Todo, [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "f " | "nt_of_float" | "nt_of_string"
new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "," | "-" | "/"
root ::= completions | new-tokens

Top 20 Logits:
,:18.6471
-:18.2371
 -:16.8599
+:15.3619
 ,:15.0551
,[:14.2808	prefix accepted:,
 +:14.1869
,(:12.7059	prefix accepted:,
-(:11.0085	prefix accepted:-
,-:10.9014	prefix accepted:,
 :10.4249
=:10.3939	rejected
):10.2477
::10.1268	rejected
:::9.77138	rejected
--:9.66259	prefix accepted:-
)(:9.43327	prefix accepted:)
,$:9.42327	prefix accepted:,
 =:9.41318	prefix accepted: 
/:9.23525
 @:9.19771	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i,

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i,
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: (Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Var "Todo"); (List (Var "Todo"))]);
           syn = (Prod [Int; (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (Int, Todo, [Todo])
  LSP: Info: Seft type: (Int, ?)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Prod [Int; (Var "Todo"); (List (Var "Todo"))]);
           syn = (Prod [Int; (Unknown Internal)])})))
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, ?
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
Int <= (Int, Todo, [Todo])
  LSP: Convex: Target types: Int, (Int, Todo, [Todo])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  i if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:14.6167
 todos:12.9655
 todo:11.6202
 (:11.1054
 [],:11.1	prefix accepted: []
 :10.8575
 i:10.6735
List:10.3439
 Tod:9.96902
 [:9.94579
 head:9.68825	prefix accepted: 
 list:9.63093	prefix accepted: l
 f:9.53433
 tod:9.32021
tod:9.22213
 {:9.00339	prefix accepted: 
 ,:8.90584	prefix accepted: 
 {},:8.3291	prefix accepted: 
 h:8.31097	prefix accepted: 
 TODO:8.28569	prefix accepted: T
 _,:8.27011	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined  
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".cons" | ".contains" | ".eq" | ".filter" | ".fold_left" | ".fold_right" | ".init" | ".is_empty" | ".length" | ".rev" | ".tl"
root ::= completions

Top 20 Logits:
.:19.6703
(:12.6365	rejected
.(:12.4533	prefix accepted:.
[:12.0069	rejected
@:10.9543	rejected
s:10.8658	rejected
_:10.8334	rejected
.[:10.5983	prefix accepted:.
[(:10.5287	rejected
<:10.3904	rejected
#:10.3603	rejected
Util:10.3289	rejected
(":10.1614	rejected
():10.0763	rejected
{:9.99059	rejected
:::9.94909	rejected
.@:9.94903	prefix accepted:.
.<:9.83167	prefix accepted:.
..:9.76414	prefix accepted:.
,:9.71673	rejected
((:9.66858	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  List.
Nature of error: "List." isn't a valid token
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "cons" | "contains" | "eq" | "filter" | "fold_left" | "fold_right" | "init" | "is_empty" | "length" | "rev" | "tl"
root ::= completions

Top 20 Logits:
hd:18.6172	rejected
nth:17.3713	rejected
tl:17.1735
rev:17.1278
cons:16.0798
head:15.6487	rejected
fold:14.9313
get:14.3411	rejected
filter:13.895
reverse:13.88	prefix accepted:rev
length:13.5582
hl:12.6608	rejected
list:12.463	prefix accepted:l
nl:12.4515	rejected
at:12.1526	rejected
sub:11.9775	rejected
index:11.7849	prefix accepted:in
find:11.7499	prefix accepted:fi
init:11.7257
take:11.5555	prefix accepted:t
td:11.5337	prefix accepted:t
Rejected the highest logit candidate hd with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.tl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ([?] -> [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ([?] -> [?]))
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: List.tl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: ([?] -> [?])
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Arrow ((List (Unknown TypeHole)), (List (Unknown TypeHole))))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: List.tl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (Arrow ((List (Unknown TypeHole)), (List (Unknown TypeHole))))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | "::"
root ::= new-tokens

Top 20 Logits:
(:19.4726
([:12.5355	prefix accepted:(
 (:12.5258
((:12.4641	prefix accepted:(
 todos:12.2155	prefix accepted: 
(@:12.1257	prefix accepted:(
[:11.7948	rejected
,:11.2013	rejected
@:10.4041	rejected
(!:10.3305	prefix accepted:(
{:9.66247	rejected
_:9.59805	rejected
():9.55816	prefix accepted:(
.(:9.52099	rejected
(),:9.40967	prefix accepted:(
 todo:9.33792	prefix accepted: 
.:9.0226	rejected
 @:8.9169	prefix accepted: 
[(:8.84139	rejected
({:8.69605	prefix accepted:(
 ,:8.69159	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(?)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: * ** + - /
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos i go Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ")"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "go" | "i" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "todos" | "true" | "type " | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
tod:17.5978
List:13.6696
 todos:12.6937
i:11.7279
go:11.4492
td:10.9165	prefix accepted:t
list:10.3809	prefix accepted:l
t:10.9165
 List:10.1583
odos:9.24277	rejected
reverse:9.00607	rejected
0:8.88791
tot:8.56258	prefix accepted:to
 i:8.49406
x:8.35425	rejected
to:8.56258
Array:8.24868	prefix accepted:A
Re:8.18346
index:7.98106	prefix accepted:in
 (:7.90575
hd:7.86853	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(tod

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(tod
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <tod>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "tod"))
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(tod)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])  
Error in term:
  tod
Nature of error: Variable tod is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: tod
LSP: Generating Completions for prefix: tod
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, [?]
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "o_list_eq" | "os"
root ::= completions

Top 20 Logits:
os:26.7057
ios:14.8645	rejected
 os:13.576	rejected
ors:12.195	prefix accepted:o
o:12.195
ols:12.0623	prefix accepted:o
ores:11.9042	prefix accepted:o
ons:11.7898	prefix accepted:o
ies:11.6055	rejected
otos:11.3088	prefix accepted:o
ос:11.1424	rejected
as:10.678	rejected
oi:10.6704	prefix accepted:o
is:10.6333	rejected
ots:10.2783	prefix accepted:o
odos:10.0758	prefix accepted:o
ows:9.97466	prefix accepted:o
ods:9.95877	prefix accepted:o
so:9.90566	rejected
s:9.74028	rejected
oss:9.61582	prefix accepted:os

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(tod
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <todos>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: [?]
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: todos
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, [?]
  LSP: Concave: Infix: Lookahead: :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: todos
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: ?, [?]
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: todos [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  go i if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq todos true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
),:19.4964	prefix accepted:)
):19.4964
)):15.8976	prefix accepted:)
)[:15.7403	prefix accepted:)
 ),:12.5994	prefix accepted: )
),(:12.3146	prefix accepted:)
)(:11.5835	prefix accepted:)
).:11.5298	prefix accepted:)
 @:11.3777
 ):12.5994
)),:11.3433	prefix accepted:)
@:11.2474
)]:10.7839	prefix accepted:)
[:10.6657	rejected
));:10.6631	prefix accepted:)
)*:10.6163	prefix accepted:)
,:10.5393	rejected
)+:10.517	prefix accepted:)
))):10.4398	prefix accepted:)
[@:10.3303	rejected
)-:10.1993	prefix accepted:)
Rejected the highest logit candidate ), with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
@:17.7495
 @:16.3633
 ,:15.312	prefix accepted: 
 ):12.2395
@@:11.5515	prefix accepted:@
 :15.312
 [],:10.9731	prefix accepted: 
 +:10.2395	prefix accepted: 
:::10.1766
@{:10.1461	prefix accepted:@
 -:9.35257	prefix accepted: 
 *:9.30839	prefix accepted: 
 [:9.29967	prefix accepted: 

:9.29852
 $:9.28024	prefix accepted: 
#:9.12964	rejected
[[:9.04444	rejected
  :8.99532
 |:8.87954	prefix accepted: 
 (:8.72545	prefix accepted: 
 ),:8.69225	prefix accepted: )

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos) 

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos) 
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.2783	prefix accepted: 
 @:17.6797
 ):15.2999
)):14.499	prefix accepted:)

:13.6233
,":13.5268	rejected
0:13.4868	rejected
 []:13.3354	prefix accepted: 
 [],:13.319	prefix accepted: 
 List:12.8606	prefix accepted: 
 [:12.6787	prefix accepted: 
 end:12.5702	prefix accepted: 
)$:12.0721	prefix accepted:)
1:12.0248	rejected
 ),:11.634	prefix accepted: )
 (@:11.4029	prefix accepted: 
 (:11.3186	prefix accepted: 
2:11.0338	rejected
))):10.9595	prefix accepted:)
 +:10.9101	prefix accepted: 
 -:10.9095	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)  

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)  
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos) 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.5401	prefix accepted: 
 @:17.449
 ):15.7654
)):13.9265	prefix accepted:)

:13.8933
 []:13.6072	prefix accepted: 
,":13.4911	rejected
 [],:13.3816	prefix accepted: 
 end:13.235	prefix accepted: 
 List:13.1542	prefix accepted: 
0:13.1391	rejected
 [:12.5803	prefix accepted: 
 (@:11.9424	prefix accepted: 
 todo:11.7482	prefix accepted: 
)$:11.5941	prefix accepted:)
 (:11.5642	prefix accepted: 
1:11.56	rejected
 ),:11.3343	prefix accepted: )
 +:11.0102	prefix accepted: 
 `@:10.8475	prefix accepted: 
 -:10.7933	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)   

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)   
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)  
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:18.2191	prefix accepted: 
 @:16.5505
 ):15.2309

:14.1997
 []:13.0787	prefix accepted: 
 [],:13.0261	prefix accepted: 
 end:12.7191	prefix accepted: 
)):12.7077	prefix accepted:)
 [:12.3726	prefix accepted: 
,":12.3284	rejected
0:12.3118	rejected
 List:12.1373	prefix accepted: 
 (@:11.869	prefix accepted: 
 todo:11.3969	prefix accepted: 
 (:11.1801	prefix accepted: 
1:10.9453	rejected
 #:10.7063	prefix accepted: 
 ),:10.587	prefix accepted: )
 todos:10.5421	prefix accepted: 
2:10.5039	rejected
 +:10.4032	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)    

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)    
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.9208	prefix accepted: 
 @:16.1086
 ):14.6428

:13.5612
 [],:12.8294	prefix accepted: 
 []:12.5721	prefix accepted: 
 [:12.456	prefix accepted: 
 List:11.7387	prefix accepted: 
)):11.605	prefix accepted:)
0:11.598	rejected
 (@:11.5229	prefix accepted: 
,":11.2845	rejected
 #:10.9653	prefix accepted: 
 end:10.9513	prefix accepted: 
 todo:10.8424	prefix accepted: 
 (:10.8158	prefix accepted: 
 todos:10.3749	prefix accepted: 
 ():10.2613	prefix accepted: 
 ),:10.2348	prefix accepted: )
 ;:10.1638	prefix accepted: 
1:10.0858	rejected
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)     

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)     
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)    
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.4731	prefix accepted: 
 @:15.6041
 ):14.2496

:13.0286
 [],:12.2123	prefix accepted: 
 [:12.1451	prefix accepted: 
 []:11.98	prefix accepted: 
0:11.1352	rejected
 List:11.0623	prefix accepted: 
 (@:10.8903	prefix accepted: 
)):10.853	prefix accepted:)
 #:10.7585	prefix accepted: 
,":10.691	rejected
 todo:10.4232	prefix accepted: 
 (:10.3547	prefix accepted: 
 ():10.3141	prefix accepted: 
 -:10.094	prefix accepted: 
 ;:10.0527	prefix accepted: 
 end:10.0137	prefix accepted: 
 .:10.0109	prefix accepted: 
 todos:9.95907	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)      

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)      
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.2047	prefix accepted: 
 @:15.1343
 ):14.1151

:12.7361
 [],:12.0093	prefix accepted: 
 [:11.9975	prefix accepted: 
 []:11.8539	prefix accepted: 
0:10.7989	rejected
 List:10.6026	prefix accepted: 
 #:10.5568	prefix accepted: 
 (@:10.5452	prefix accepted: 
 todo:10.3911	prefix accepted: 
 ():10.3694	prefix accepted: 
)):10.33	prefix accepted:)
 (:10.2275	prefix accepted: 
 -:10.0914	prefix accepted: 
 .:10.0344	prefix accepted: 
,":10.0192	rejected
 ;:9.93482	prefix accepted: 
 end:9.92067	prefix accepted: 
 todos:9.90097	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)       

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)       
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)      
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.0944	prefix accepted: 
 @:14.7713
 ):14.0525

:12.597
 [],:11.958	prefix accepted: 
 [:11.9535	prefix accepted: 
 []:11.9166	prefix accepted: 
 todo:10.5035	prefix accepted: 
 #:10.4114	prefix accepted: 
 List:10.3782	prefix accepted: 
 ():10.3382	prefix accepted: 
 (@:10.3103	prefix accepted: 
0:10.2802	rejected
 (:10.2026	prefix accepted: 
 end:10.1078	prefix accepted: 
 .:10.0365	prefix accepted: 
 todos:10.0315	prefix accepted: 
 -:10.0027	prefix accepted: 
)):9.9789	prefix accepted:)
 ;:9.79673	prefix accepted: 
 ":9.57871	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)        

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)        
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.7761	prefix accepted: 
 @:14.2961
 ):13.7934

:12.3228
 []:11.7547	prefix accepted: 
 [],:11.6926	prefix accepted: 
 [:11.6613	prefix accepted: 
 todo:10.3047	prefix accepted: 
 ():9.9941	prefix accepted: 
 end:9.9678	prefix accepted: 
 (:9.96353	prefix accepted: 
 List:9.95767	prefix accepted: 
 todos:9.94905	prefix accepted: 
 #:9.94299	prefix accepted: 
 (@:9.86007	prefix accepted: 
 .:9.73916	prefix accepted: 
 -:9.69593	prefix accepted: 
 ;:9.58232	prefix accepted: 
)):9.51694	prefix accepted:)
0:9.43038	rejected
	:9.35183	rejected
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)         

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)         
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)        
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.1774	prefix accepted: 
 @:13.6884
 ):13.2771
 :16.1774
  :11.783

:11.7736
 []:11.2651	prefix accepted: 
 [],:11.1539	prefix accepted: 
 [:11.0944	prefix accepted: 
   :10.2538
    :10.1397
     :9.98042
 todo:9.85491	prefix accepted: 
 todos:9.64544	prefix accepted: 
 end:9.62928	prefix accepted: 
                :9.53511
 (:9.50407	prefix accepted: 
 ():9.47028	prefix accepted: 
,:9.3398	rejected
 List:9.28958	prefix accepted: 
       :9.26728
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)          

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)          
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)         
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.226	prefix accepted: 
 @:13.7428
 ):13.3065
 :16.226

:11.8664
  :11.7877
 []:11.3869	prefix accepted: 
 [],:11.1695	prefix accepted: 
 [:11.116	prefix accepted: 
   :10.2684
    :10.2192
     :10.1012
 end:9.90853	prefix accepted: 
 todo:9.88246	prefix accepted: 
 todos:9.76139	prefix accepted: 
                :9.64159
 ():9.63675	prefix accepted: 
 (:9.61833	prefix accepted: 
       :9.38502
 ;:9.35299	prefix accepted: 
      :9.33831
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)           

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)           
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)          
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.5667	prefix accepted: 
 @:14.0726
 ):13.5208

:12.2229
 []:11.7554	prefix accepted: 
 :16.5667
 [],:11.4709	prefix accepted: 
 [:11.4199	prefix accepted: 
  :10.9365
 end:10.3734	prefix accepted: 
 todo:10.088	prefix accepted: 
 ():10.0439	prefix accepted: 
 todos:10.0315	prefix accepted: 
 (:9.95301	prefix accepted: 
 ;:9.64397	prefix accepted: 
 #:9.58797	prefix accepted: 
	:9.5847	rejected
 -:9.5406	prefix accepted: 
 (@:9.53756	prefix accepted: 
   :9.52229
 .:9.52109	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)            

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)            
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)           
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.8105	prefix accepted: 
 @:14.3127
 ):13.6317

:12.4377
 []:12.0078	prefix accepted: 
 [],:11.7122	prefix accepted: 
 [:11.6315	prefix accepted: 
 :16.8105
 end:10.669	prefix accepted: 
 ():10.2775	prefix accepted: 
  :10.2089
 (:10.1809	prefix accepted: 
 todo:10.1799	prefix accepted: 
 todos:10.1637	prefix accepted: 
 .:9.81675	prefix accepted: 
 ;:9.81591	prefix accepted: 
 #:9.74173	prefix accepted: 
 (@:9.73194	prefix accepted: 
	:9.71215	rejected
 -:9.67544	prefix accepted: 
 ),:9.63615	prefix accepted: )
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)             

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)             
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)            
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.8896	prefix accepted: 
 @:14.4045
 ):13.6427

:12.4646
 []:12.0927	prefix accepted: 
 [],:11.8175	prefix accepted: 
 [:11.6807	prefix accepted: 
 end:10.804	prefix accepted: 
 :16.8896
 ():10.268	prefix accepted: 
 (:10.2614	prefix accepted: 
 todos:10.1151	prefix accepted: 
 todo:10.112	prefix accepted: 
  :10.0498
 .:9.92597	prefix accepted: 
 ;:9.84513	prefix accepted: 
 (@:9.7993	prefix accepted: 
 -:9.71587	prefix accepted: 
 #:9.70258	prefix accepted: 
	:9.69401	rejected
 ),:9.64609	prefix accepted: )
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)              

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)              
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)             
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.7273	prefix accepted: 
 @:14.2388
 ):13.484

:12.2375
 :16.7273
 []:11.923	prefix accepted: 
 [],:11.7136	prefix accepted: 
 [:11.499	prefix accepted: 
  :11.0581
 end:10.7399	prefix accepted: 
 (:10.1215	prefix accepted: 
 ():10.0095	prefix accepted: 
 todos:9.88225	prefix accepted: 
 todo:9.84413	prefix accepted: 
 .:9.77428	prefix accepted: 
 ;:9.66012	prefix accepted: 
 (@:9.64452	prefix accepted: 
 -:9.57081	prefix accepted: 
	:9.49832	rejected
 ::9.4782
   :9.43207
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)               

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)               
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)              
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:15.9768	prefix accepted: 
 :15.9768
 @:13.5045
  :13.3669
 ):12.81
    :11.5469

:11.4284
     :11.4053
   :11.4014
 []:11.162	prefix accepted: 
 [],:11.1273	prefix accepted: 
 [:10.8009	prefix accepted: 
      :10.7188
                :10.5665
       :10.4893
 end:10.2044	prefix accepted: 
         :10.0477
        :9.95301
          :9.86097
            :9.76972
 (:9.45413	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)               
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :15.495
 ,:14.5075	prefix accepted: 
  :13.7433
 ):12.7429
 @:12.1963
    :12.0518
     :11.809
   :11.7856
,:11.3368	rejected
      :11.2033
       :10.8454
                :10.7876
         :10.3381

:10.3097
        :10.3047
          :10.1453
            :9.95486
 [],:9.87883	prefix accepted: 
@:9.76963
 []:9.72953	prefix accepted: 
 [:9.55585	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                 

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                 
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 :15.0315
 ,:13.7363	prefix accepted: 
  :13.3112
 ):12.1453
,:11.7734	rejected
    :11.6352
 @:11.5921
   :11.3738
     :11.3438
      :10.7714
       :10.358
@:10.2766
                :10.2728

:9.95314
         :9.88178
        :9.83201
          :9.6662
            :9.47668
 [],:9.27692	prefix accepted: 
):9.24329
 []:9.07655	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                   

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                   
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: (Int, Todo, [Todo])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [?]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, (Int, Todo, [Todo])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: Int (Prod [String; Bool]) (List (Prod [String; Bool]))
LSP: commas: self syn is (Prod [Int; (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:17.8722	prefix accepted: 
 ):16.1883
 @:15.603

:14.0887
 [:12.9179	prefix accepted: 
)):12.568	prefix accepted:)
 [],:11.9189	prefix accepted: 
0:11.916	rejected
 []:11.795	prefix accepted: 
 todos:11.6509	prefix accepted: 
 todo:11.4627	prefix accepted: 
 (:11.4239	prefix accepted: 
	:11.2338	rejected
 -:11.1265	prefix accepted: 
 ():11.1245	prefix accepted: 
,":11.1041	rejected
1:11.064	rejected
 end:11.0494	prefix accepted: 
 (@:11.0066	prefix accepted: 
 ;:10.6292	prefix accepted: 
 List:10.5711	prefix accepted: 
Rejected the highest logit candidate  , with logit -inf

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    )

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    )
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Int, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:

:16.1365
 :14.9356
 end:14.6621	prefix accepted: 
 in:13.4314
    :13.3559
  :13.3521
end:12.7778	rejected
@:12.529
   :12.5161
 @:12.3858
      :12.186
     :12.1784
        :12.0566
       :12.0175
 todos:11.9564	prefix accepted: 
in:11.9266
                :11.8384
#:11.7465	rejected
 #:11.6896	prefix accepted: 
[:11.3162	rejected
            :11.2604

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    ) 

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    ) 
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Int, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:

:18.7012
 end:16.5853	prefix accepted: 
 in:15.8405
 @:14.3709
 ;:13.7631	prefix accepted: 
 #:13.5757	prefix accepted: 
 todos:13.3525	prefix accepted: 
 ,:13.3192	prefix accepted: 
 todo:12.9694	prefix accepted: 
	:12.7575	rejected
 ):12.5148	prefix accepted: 
 [:12.3574	prefix accepted: 
 ():12.3323	prefix accepted: 
 (:12.2185	prefix accepted: 
 []:11.8603	prefix accepted: 
 ::11.8482	prefix accepted: 
 (@:11.6896	prefix accepted: 
 TODO:11.5663	prefix accepted: 
 Tod:11.5098	prefix accepted: 
 //:11.4094	prefix accepted: 
 where:11.3764	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    ) 


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    ) 

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    ) 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [Todo]
  LSP: Info: Seft type: [Todo]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {todos: [Todo], i: Int, go: ((Int, Todo, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Let expression
  LSP: Info: BidiCtx: Expected type: ((Int, [Todo]) -> [Todo])
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Todo]
  LSP: Concave: Infix: Base: @
  LSP: Concave: Infix: Lookahead types: ((Int, [Todo]) -> [Todo])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "@" | "in"
root ::= new-tokens

Top 20 Logits:
in:18.2082
                :14.8677
    :14.7878

:14.3657
   :13.8977
       :13.8098
        :13.4419
            :13.2032
           :12.9032
 in:12.722
 :12.6485
               :12.5816
      :12.5666
     :12.5655
             :12.3542
              :12.3329
  :12.2087
          :12.2005
         :11.9921
#:11.8073	rejected
end:11.495	rejected

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    ) 
in

LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    ) 
in
LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    ) 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {toggle: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: toggle Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq toggle true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "toggle" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.3355
 :16.6301
    :15.2525
  :14.6089
                :14.1876
      :13.8547
     :13.8107
   :13.6727
        :13.5199
       :13.4569
            :12.8045
         :12.3518
          :12.3271
           :12.1719
             :12.0585
	:11.7154	rejected
              :11.6298
               :11.392
 #:10.8734	prefix accepted: 
;:10.8362	rejected
 {:10.4479	prefix accepted: 

================
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    ) 
in


LSP: Command: Completions(Types)
LSP: New token mode: # A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    ) 
in

LSP: Process zipper: Recieved string:
# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String)
in

let Bool.eq: (Bool, Bool) -> Bool =
  fun (b1, b2) -> if b1 then b2 else !b2
in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
    d1 $== d2 && Bool.eq(s1, s2)
in

let todo_list_eq: ([Todo], [Todo]) -> Bool =
    fun xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => Todo.eq(x, y) && todo_list_eq(xs, ys)
    | _ => false end
in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && todo_list_eq(ts1, ts2)
in

let Model.init: Model = ("", []) in

let Model.get_buffer: Model -> String =
  fun buffer, todo_list -> buffer
in

let Model.get_todo_list: Model -> [Todo] =
  fun buffer, todo_list -> todo_list
in

# Toggle a todo item by its index #
let toggle: (Int, [Todo]) -> [Todo]= 
    let go: (Int, Todo, [Todo] ) -> [Todo] =
        fun i, todo, todos ->
            if i > 0 then
                todo::go(i-1, List.tl(todos)@[List.cons(todo, List.tl(todos)@[] )] )
            else
                 [List.fold_left(fun (todo, _) -> todo, true) ] 
    in
    fun i, todos -> go(i, List.tl(todos)                    ) 
in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {toggle: ((Int, [Todo]) -> [Todo]), Model.get_todo_list: (Model -> [Todo]), Model.get_buffer: (Model -> String), Model.init: Model, Model.eq: ((Model, Model) -> Bool), todo_list_eq: (([Todo], [Todo]) -> Bool), Todo.eq: ((Todo, Todo) -> Bool), Bool.eq: ((Bool, Bool) -> Bool), AddTodo: Action, RemoveTodo: (Int -> Action), ToggleTodo: (Int -> Action), UpdateBuffer: (String -> Action), Action:: (AddTodo + RemoveTodo(Int) + ToggleTodo(Int) + UpdateBuffer(String)), Model:: (String, [Todo]), Todo:: (String, Bool), List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: 
  LSP: Info: ALL errors:
Error in term:
  fun ((todo, _)) ->
 todo, true
Nature of error: Expecting type (((?, ?) -> ?), ?, [?]) but got inconsistent type (((?, ?) -> ?), Bool)  
Error in term:
  i - 1, List.tl(todos) @ List.cons(todo, List.tl(todos) @ )
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, ?)  
Error in term:
  i, List.tl(todos)
Nature of error: Expecting type (Int, Todo, [Todo]) but got inconsistent type (Int, [?])
  LSP: Info: BidiCtx: Cls: Type Alias definition
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent: Root
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: toggle Model.get_todo_list Model.get_buffer Model.init Model.eq todo_list_eq Todo.eq Bool.eq List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity AddTodo RemoveTodo ToggleTodo UpdateBuffer Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddTodo App Bool.eq List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl Model.eq Model.get_buffer Model.get_todo_list Model.init RemoveTodo Reverse String.reverse String.starts_with String.transform Todo.eq ToggleTodo Trim UpdateBuffer Var [ [] abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  todo_list_eq toggle true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddTodo" | "App" | "Bool.eq" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "Model.eq" | "Model.get_buffer" | "Model.get_todo_list" | "Model.init" | "RemoveTodo" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Todo.eq" | "ToggleTodo" | "Trim" | "UpdateBuffer" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "todo_list_eq" | "toggle" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:

:19.148
#:16.8699	rejected
    :16.006
let:15.7847
            :14.3836
        :14.3565
                :14.2618
 :14.0159
  :13.5528
   :13.1766
       :13.0336
     :13.0189
      :12.9745
             :12.7961
           :12.7045
          :12.4006
 #:12.3939	prefix accepted: 
         :12.1929
(*:11.8936	prefix accepted:(
              :11.8084
               :11.567
