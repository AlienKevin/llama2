

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Target types: ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:

:19.7245
 :17.0451
 fun:14.7637
  :14.6908
    :13.9412
                :12.5682
   :11.9667
     :11.9231
 function:11.8912	prefix accepted: fun
 #:11.8717	prefix accepted: 
	:11.7508	rejected
      :11.3313
        :11.2887
 (:11.2319
 \:10.8053	prefix accepted: 
       :10.7318
            :10.4447
 {:10.3739	prefix accepted: 
 ?:10.355	prefix accepted: 
 (*:10.3354	prefix accepted: (
         :10.1648

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Target types: ((PlayList, PlayListAction) -> PlayList)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  fun  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right case  fun  if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "case " | "fun " | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 :20.1497
   :18.4172
fun:18.2632
  :15.5168
	:14.8403	rejected
 fun:14.8055
     :13.8627
let:13.5713
       :13.4282

:13.1
    :13.0311
func:12.5827	prefix accepted:fun
#:12.327	rejected
(*:12.0909	prefix accepted:(
(:12.0909
 let:11.3247
      :10.958
{:10.7912	rejected
function:10.7528	prefix accepted:fun
fn:10.7392	prefix accepted:f
           :10.3523

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "[" | "[]" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
 play:16.924
 (:16.1964
 pl:14.9746
 p:14.0131
 current:13.0508
 ((:12.9355	prefix accepted: (
(:12.7434
 pair:12.6487
 ([:12.4576	prefix accepted: (
 [:12.3512
 old:12.2989
 state:12.2264
 list:11.903
 pal:11.8327
 song:11.7622
 args:11.7545
 action:11.5078
 x:11.498
 ({:11.2124	prefix accepted: (
 s:11.1241
 a:10.9946

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {pl: (PlayList, PlayListAction), update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: pl
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: pl
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Unknown Internal)
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | "->"
root ::= completions | new-tokens

Top 20 Logits:
,:15.061
ist:13.725
st:12.3165
_:12.0875
s:12.0735
 ,:10.366
p:9.93399
state:9.23917
al:9.19308
c:8.93926
1:8.8811
id:8.84746
 ->:8.69634
S:8.66668
m:8.50255
0:8.41644
 as:8.08552	prefix accepted: 
State:8.0801
A:8.00642
r:7.99965
Action:7.83631

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: (PlayList, PlayListAction)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (PlayList, PlayListAction)
  LSP: Info: Seft type: (PlayList, PlayListAction)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Prod [(Var "PlayList"); (Var "PlayListAction")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( [ [] _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 action:15.721
 act:14.681
 a:14.501
 pa:12.9444
 p:12.7484
 play:12.434
 pl:11.8123
 x:11.458
action:11.3556
 cmd:11.0725
 command:10.9293
 la:10.9245
a:10.4384
 actions:10.4141
 pal:10.356
 al:10.2854
 e:10.1847
 ac:10.0754
 current:9.78369
 new:9.69404
 song:9.68225

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: -> in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (PlayList, PlayListAction)
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Prod [(Var "PlayList"); (Var "PlayListAction")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: action
LSP: commas: p_ana is prod: (Prod
   [(List Int);
     (Sum
        [("Playing", (Some Int)); ("PausedOn", (Some Int));
          ("NoSongSelected", None)])
     ]) (Sum
   [("PlaySong", (Some Int)); ("PauseCurrentSong", None);
     ("RemoveSong", (Some Int)); ("AddSong", (Some Int))])
LSP: commas: self syn is (Prod [(Var "PlayList"); (Var "PlayListAction")])
  LSP: Concave: Backpack: ->
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "->"
root ::= completions | new-tokens

Top 20 Logits:
 ->:18.8818
->:14.8911
 =>:14.2334	prefix accepted: 
 :14.2334
_:11.6431

:11.3917
::11.3809	rejected
1:10.6048
 =:10.3156	prefix accepted: 
 →:10.1794	prefix accepted: 
0:10.1318
':9.95976	rejected
 ::9.95486	prefix accepted: 
 -->:9.91274	prefix accepted: -
2:9.60884
 -:9.91274
 in:9.37353	prefix accepted: 
,:9.29488	rejected
 >>:9.27261	prefix accepted: 
?:9.1651	rejected
  :9.0656

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:19.4807
 :17.1404
  :15.5609
 case:14.8668
    :14.6486
 match:14.2776	prefix accepted: ma
   :12.9582
                :12.9298
        :12.5272
     :12.4802
	:12.3481	rejected
 {:12.3219	prefix accepted: 
      :12.3166
 #:12.1792	prefix accepted: 
 begin:11.8336	prefix accepted: 
 let:11.8026
 (*:11.7955	prefix accepted: (
       :11.6984
         :11.3348
 if:11.2442
            :11.2026

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 :18.2625
   :17.6193
case:17.5718
match:16.3427	prefix accepted:ma
  :15.7648
       :15.2986
	:14.8888	rejected
     :14.8293
let:14.753
 case:14.1919
    :13.8318

:13.3288
if:13.2825
 match:13.1934	prefix accepted: ma
switch:12.6281	prefix accepted:s
(:12.6211
      :12.4346
           :12.3196
         :12.2197
#:12.0608	rejected
(*:12.0245	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <fun -><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in
  LSP: Info: BidiCtx: Cls: Function literal
  LSP: Info: BidiCtx: Expected type: ((PlayList, PlayListAction) -> PlayList)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 case:18.8868
 let:17.3398
 match:17.2866	prefix accepted: ma
 switch:15.5109	prefix accepted: s
 #:13.3253	prefix accepted: 
 if:13.2535
 (*:12.8913	prefix accepted: (
 fun:12.7978	prefix accepted: 
 (:12.8913
 print:11.4615	prefix accepted: p
 {:11.0741	prefix accepted: 
 play:10.688	prefix accepted: pl
 //:10.5732	prefix accepted: 
 printf:10.5209	prefix accepted: p
 pl:10.688
 List:10.2372
 ((:10.2227	prefix accepted: (
 begin:10.1483	prefix accepted: 
 assert:10.1224	prefix accepted: a
 open:10.0836	prefix accepted: 
 cases:9.97958	prefix accepted: case

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action pl update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "pl" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 action:17.4664
 pl:15.9557
 get:14.8942
 play:13.734	prefix accepted: pl
 (:12.7657
 :11.2195

:11.1715
 #:10.4712	prefix accepted: 
(:10.3696
 let:10.322
 actions:10.0986	prefix accepted: action
 [:9.85204
 act:9.71054
 p:9.57327
 List:9.52969
 {:9.50907	prefix accepted: 
 player:9.48236	prefix accepted: pl
 plt:9.38488	prefix accepted: pl
 pair:9.2713	prefix accepted: pa
 *:9.24684	prefix accepted: 
 Play:9.22376

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: action
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListAction
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: action
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: action pl update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.2488
 :17.2777
 of:16.0491	prefix accepted: 
,:15.8672
  :14.645
 with:14.2015	prefix accepted: 
 |:13.8693
    :12.9003
 {:12.7609	prefix accepted: 
 #:12.0033	prefix accepted: 
                :11.6522
   :11.5546
     :11.4598
::11.4349
 match:11.3162	prefix accepted: 
 in:11.2988	prefix accepted: 
 =>:11.2843	prefix accepted: 
 ,:11.2809
      :11.1455
;:11.1449	rejected
 //:11.1116	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListAction
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:22.4275
 |:15.5436
	:14.3094	rejected
 of:14.0415	prefix accepted: 
 #:13.6368	prefix accepted: 
 =>:13.1176	prefix accepted: 
 {:13.0646	prefix accepted: 
 with:12.8397	prefix accepted: 
 //:12.1374	prefix accepted: 
 ,:11.9743
 ->:11.559	prefix accepted: 
 ::11.1853
 do:11.1685	prefix accepted: 
1:10.7014	rejected
 =:10.5071	prefix accepted: 
:10.1218	rejected
 :::10.0833
 (*:9.95581	prefix accepted: 
 ||:9.94372	prefix accepted: |
0:9.9142	rejected
 ##:9.8985	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListAction
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :21.3676
   :19.5672
     :18.3316
  :18.3076
    :17.0638
|:16.6126

:16.5897
       :16.4646
	:15.7004	rejected
 |:15.4836
      :15.3362
         :15.0763
        :14.4392
           :14.0245
#:13.6914	rejected
          :13.5099
                :13.3199
             :12.8069
            :12.6541
               :12.3824
(*:11.5418	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <action>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListAction
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.6007
 #:17.9853	prefix accepted: 
 (*:14.9916	prefix accepted: 
 of:14.3617	prefix accepted: 
 +:13.0586	prefix accepted: 
 ##:12.9774	prefix accepted: 
 {:12.8795	prefix accepted: 
 ~:12.8416	prefix accepted: 
 /*:12.6599	prefix accepted: 
 ||:12.4825	prefix accepted: |
 //:12.4815	prefix accepted: 
 ,:12.1919
 with:12.0621	prefix accepted: 
 *:12.0169	prefix accepted: 
 ###:11.7288	prefix accepted: 
 %:11.5593	prefix accepted: 
 <:11.4816	prefix accepted: 
 =>:11.4397	prefix accepted: 
 #{:11.2579	prefix accepted: 
 match:11.1407	prefix accepted: 
 /:11.0697	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Play:17.6335
 Add:16.8499
 P:16.5576
 Remove:15.0655
 No:13.7466	prefix accepted: 
Play:11.8406
 _:11.69
 (:11.4464
 :13.7466
 #:11.1951	prefix accepted: 
 Player:10.735	prefix accepted: Play
P:10.4535
Add:9.78253
 Stop:9.70653	prefix accepted: 
 Start:9.43797	prefix accepted: 
 {:9.42482	prefix accepted: 
  :9.33009
 App:9.29543	prefix accepted: A
 Rem:9.15746
 Next:9.1262	prefix accepted: 
 Song:9.0924	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | Add

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | Add
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Add>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Add"))))
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  Add
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Add
LSP: Generating Completions for prefix: Add
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:21.9838
(:13.403	rejected
song:12.5331	rejected
 song:10.9294	rejected
_:10.8866	rejected
To:10.8427	rejected
s:10.1817	rejected
New:10.1544	rejected
 Song:9.85999	rejected
Id:9.28682	rejected
 =>:9.28176	rejected
(_:9.0515	rejected
 (:8.8961	rejected
 if:8.82937	rejected

:8.72997	rejected
On:8.52337	rejected
 ->:8.49981	rejected
All:8.4956	rejected
 a:8.45131	rejected
():8.39035	rejected
 new:8.37093	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | Add
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "AddS"))))
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  AddS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: AddS
LSP: Generating Completions for prefix: AddS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:26.7553
ongs:17.0608	prefix accepted:ong
song:12.5736	rejected
on:12.4303
 song:11.4926	rejected
(:11.3226	rejected
ongo:11.2778	prefix accepted:ong
ang:11.2348	rejected
oon:10.8273	prefix accepted:o
ng:10.6872	rejected
ame:10.4953	rejected
n:10.2984	rejected
ug:9.93513	rejected
ond:9.9077	prefix accepted:on
oup:9.57891	prefix accepted:o
one:9.45323	prefix accepted:on
ons:9.17576	prefix accepted:on
ONG:9.08549	rejected
lide:9.075	rejected
ig:8.80278	rejected
old:8.73341	prefix accepted:o

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <AddSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: (Id -> PlayListAction)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListAction");
           syn = (Arrow ((Var "Id"), (Var "PlayListAction")))})))
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  AddSong
Nature of error: Expecting type PlayListAction but got inconsistent type (Id -> PlayListAction)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: AddSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: AddSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.4131
 id:15.198	prefix accepted: 
 song:14.3592	prefix accepted: 
(_:13.3933	prefix accepted:(
 s:12.6606	prefix accepted: 
 sid:12.6113	prefix accepted: 
 x:12.5227	prefix accepted: 
 i:12.5083	prefix accepted: 
 (:12.0296
 new:11.9377	prefix accepted: 
 a:10.6499	prefix accepted: 
 =>:10.2397
 _:10.0742	prefix accepted: 
((:9.91941	prefix accepted:(
 n:9.84362	prefix accepted: 
 e:9.5964	prefix accepted: 
 idx:9.48489	prefix accepted: 
 k:9.48053	prefix accepted: 
 v:9.41802	prefix accepted: 
 track:9.29112	prefix accepted: 
 pid:9.25182	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
id:18.3075
song:17.9654
x:15.6416
s:15.5046
i:15.3785
new:15.2763
n:13.293
Id:12.9226	rejected
idx:12.6852
a:12.549
track:12.4769
current:12.2999
next:12.0218
index:11.4133
v:11.3293
k:11.2585
vid:11.2034
name:11.1689
play:11.1689
curr:10.9355
value:10.9327

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):18.8836
_:14.7015
)->:14.6167	prefix accepted:)
),:13.5643	prefix accepted:)
1:13.1185
)=:12.9183	prefix accepted:)
To:12.6022
_):12.4764	prefix accepted:_
'):12.2032	rejected
)::12.0193	prefix accepted:)
 as:11.813	prefix accepted: 
t:11.7368
2:11.7211
::11.6438	rejected
0:11.28
 ):10.6996
New:10.573
S:10.2557
n:10.0364
){:9.95714	prefix accepted:)
 ::9.94135	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.9764
 ->:16.0613	prefix accepted: 
 when:13.8093	prefix accepted: 
  :13.626
 if:13.4329	prefix accepted: 
 :16.0613
     :13.0331
    :13.0097
 as:12.6729	prefix accepted: 
      :12.5569
       :12.4529
         :12.0975
        :12.0613
   :12.0562
          :11.7322

:11.3966
                :11.2832
           :11.1753
            :10.6991
             :10.5817
 :::10.4801	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:17.2924
 :16.7553
  :14.9502
 if:14.6582
 let:14.3877
 (:14.3588
 #:13.9179	prefix accepted: 
 add:13.395	prefix accepted: a
    :13.2435
                :12.6744
 {:12.6723	prefix accepted: 
 List:12.5097
 fun:12.4736	prefix accepted: 
 ((:12.3436	prefix accepted: (
 update:12.2632
 (*:12.242	prefix accepted: (
 pl:12.2173
 [:12.1883
     :12.1513
 <:11.9332	prefix accepted: 
   :11.8518

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
     :18.4733
   :18.0713
       :16.3034
    :15.9341
         :14.5538
  :14.3057
 :14.1654
      :13.9972
           :13.4305
	:13.3066	rejected
        :12.9924
             :12.1465
                :11.8783
               :11.7904
          :11.7897
            :11.2086

:10.9852
              :10.4058
#:9.98324	rejected
let:9.96828
if:9.39837

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 let:19.4263
 if:19.0814
 #:18.3781	prefix accepted: 
 case:16.6124
 (:16.3987
 (*:16.1952	prefix accepted: (
 begin:15.7508	prefix accepted: 
 fun:15.3135	prefix accepted: 
 match:15.2033	prefix accepted: ma
 ((:14.1566	prefix accepted: (
 get:14.0674
 add:13.983	prefix accepted: a
 List:13.772
 pl:13.6353
 {:13.3695	prefix accepted: 
 print:12.9441	prefix accepted: p
 #(:12.8927	prefix accepted: 
 [:12.8443
 update:12.8294
 //:12.4906	prefix accepted: 
 fail:12.3097	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:15.4989
 current:13.2652
 song:12.6672
 new:12.6223
 ids:12.3235
 old:12.125
 cur:11.5898
 (:11.4323
 play:11.4039
 add:11.3811
 curr:11.1998
 existing:11.1175
 all:11.095
 s:10.8727
 xs:10.8115
 list:10.7831
 id:10.5157
 _,:10.4724	prefix accepted: _
 pl:10.2686
 prev:10.2417
 get:10.1876

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:19.4676
 =:17.3849
_:16.6614
',:14.9482	rejected
1:14.033
 ,:13.3864
::13.3266
 ::13.2622
_,:13.1627	prefix accepted:_
0:12.866
':12.7863	rejected
=:12.7134
@:12.3554	rejected
2:12.1661
  :12.0026
In:11.86
 :=:11.7546	prefix accepted: :
 :11.5704
    :11.1295
 @:10.7872	prefix accepted: 
      :10.7063

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:16.2708
 state:15.6542
 _:14.3907
 curr:12.2388
 old:11.9038
 song:11.7936
 play:11.6082
 s:11.4884
 playing:11.436
 status:11.3066
 cur:11.2612
state:10.9854
 st:10.587
 prev:10.3349
 selected:10.114
 cs:10.0215
current:10.0207
 pl:10.0111
 p:9.9978
 c:9.76922
 id:9.67668

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: ?, songs: ?, id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:19.65
_:18.7134
State:16.9935
=:14.7086
state:14.2555
 :13.6481
S:13.5764
  :11.7605
Play:11.7013
Id:11.666
Status:11.4523
 ::11.3634
::11.2688
St:11.0604
song:10.9432
Pl:10.5407
play:10.4746
    :10.3994
,:10.3887	rejected
1:10.0239
 :=:9.80856	prefix accepted: :

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_: ?, songs: ?, id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current_
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current_
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
state:21.0486
song:18.6985
play:16.8139
status:16.7622
s:14.8614
pl:14.8328
id:14.2966
st:13.7703
action:13.7622
selection:13.646
stat:13.5168
player:13.0413
selected:12.9147
track:12.7295
State:12.6663
index:12.5747
states:12.0995
p:12.0994
value:12.0768
idx:12.0398
position:12.004

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: ?, songs: ?, id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current_state
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current_state
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:20.8028
=:16.3047
 :14.9562
_:13.8666
  :12.9449
,:12.828	rejected
 ::12.7028
::12.3494
 as:12.1594	prefix accepted: 
    :11.8899
   :11.2778
      :11.0931

:11.0127
 ==:10.9645	prefix accepted: =
       :10.8275
                :10.6869
        :10.6468
 :=:10.6277	prefix accepted: :
1:10.5543
':10.3211	rejected
     :10.3177

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "pl" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 pl:19.2592
 get:15.2108
 play:13.8751	prefix accepted: pl
 :13.3134

:12.9848
 (:12.2307
pl:11.6639
 List:11.3938
 match:10.9209	prefix accepted: ma
 action:10.8269
 plt:10.7974	prefix accepted: pl
 if:10.7412
 update:10.6797
 p:10.388
 add:10.1387	prefix accepted: a
 Pl:10.013
 Play:10.0026
 f:9.93042
 current:9.81341	prefix accepted: c
 list:9.68886	prefix accepted: l
 case:9.28632

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: pl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: pl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:19.2856

:14.3229
,:13.952
 :13.9106
;:12.9507	rejected
.:12.8285	rejected
 and:12.6042	prefix accepted: 
  :11.3823
                :10.518
 ,:10.2556
 #:10.0312	prefix accepted: 
    :9.83458
 |:9.77903	prefix accepted: 
      :9.68324
():9.67139	rejected
 ;:9.53866	prefix accepted: 
.(:9.40488	rejected
   :9.15849
,(:9.15033	prefix accepted:,
       :9.02489
        :8.98997

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:19.6034
 :16.9946
  :16.0702
    :14.9644
      :14.095
                :13.2874
   :13.2041
       :12.9906
        :12.9788
     :12.9715
            :12.7009
          :12.6836
         :12.4341
 #:12.1131	prefix accepted: 
           :12.0476
              :11.7852
             :11.7266
	:11.3325	rejected
               :11.099
 (*:11.0512	prefix accepted: (
 (:11.0512

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
     :20.0011
       :17.9067
      :16.808
         :16.2741

:15.2984
        :15.1577
    :15.0288
	:14.752	rejected
   :14.4819
           :13.9143
          :13.8233
  :13.5998
 :12.6763
            :12.4979
             :12.3832
                :12.241
#:11.6273	rejected
               :11.618
              :10.9044
(*:10.3589	prefix accepted:(
if:9.80787

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 if:20.0801
 let:18.8371
 #:18.2053	prefix accepted: 
 (:17.7813
 case:16.7584
 match:16.4139	prefix accepted: ma
 ((:16.2573	prefix accepted: (
 ([:16.2284	prefix accepted: (
 (*:16.1143	prefix accepted: (
 songs:14.6624
 {:14.291	prefix accepted: 
 pl:14.144
 List:14.111
 Play:13.864	prefix accepted: 
 [:13.8199
 get:13.7002
 song:13.6543
 //:13.5529	prefix accepted: 
 begin:13.4095	prefix accepted: 
 add:13.2703	prefix accepted: a
 play:12.8188	prefix accepted: pl

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "String.reverse" | "String.starts_with" | "String.transform" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 List:17.993
 not:15.531	prefix accepted: n
 (:13.4231
 contains:13.3864	prefix accepted: co
 id:13.2625
 get:13.1662	prefix accepted: 
 current:12.8987	prefix accepted: c
 songs:11.8096	prefix accepted: s
 !:11.7671
 Id:11.461	prefix accepted: 
 #:11.3874	prefix accepted: 
 :13.1662
 Song:10.9212	prefix accepted: S
 Songs:10.6461	prefix accepted: S
 song:10.6444	prefix accepted: s
 is:10.5022
 String:10.4715
 list:10.4355	prefix accepted: l
 Play:10.3758	prefix accepted: 
(:10.248
 ((:10.2332	prefix accepted: (

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "List"))))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  List
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: List
LSP: Generating Completions for prefix: List
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= ".contains" | ".eq" | ".fold_left" | ".fold_right" | ".is_empty" | ".length"
root ::= completions

Top 20 Logits:
.:24.1803
.(:16.432	prefix accepted:.
_:14.1564	rejected
.@:12.446	prefix accepted:.
s:12.2647	rejected
.[:11.7674	prefix accepted:.
/:11.6754	rejected
Contains:11.6527	rejected
@:11.2499	rejected
contains:11.2215	rejected
 contains:11.0372	rejected
.<:10.9406	prefix accepted:.
._:10.815	prefix accepted:.
Util:10.6792	rejected
(:10.6748	rejected
..:10.6287	prefix accepted:.
[:10.5684	rejected
 .:10.5091	rejected
#:10.4183	rejected
:::10.2595	rejected
<:10.0642	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Invalid expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (BadToken "List."))))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  List.
Nature of error: "List." isn't a valid token
  LSP: Info: BidiCtx: Cls: Invalid expression
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Bad token; only completion
  LSP: Syntax: Must complete: List.
LSP: Generating Completions for prefix: List.
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "contains" | "eq" | "fold_left" | "fold_right" | "is_empty" | "length"
root ::= completions

Top 20 Logits:
contains:22.9969
eq:18.1535
length:17.4468
is:17.2475
exists:16.7007	prefix accepted:e
filter:16.6388	prefix accepted:f
mem:16.2376	rejected
fold:15.3731
includes:14.7348	prefix accepted:i
member:14.6628	rejected
find:13.7391	prefix accepted:f
equals:13.7104	prefix accepted:eq
rev:13.6749	rejected
cons:13.4794	prefix accepted:con
get:13.264	rejected
elem:13.1997	prefix accepted:e
Contains:13.1307	rejected
starts:12.9468	rejected
in:12.8609	prefix accepted:i
tl:12.7783	rejected
any:12.6474	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <List.contains>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: (((? -> Bool), [?]) -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = Bool;
           syn =
           (Arrow (
              (Prod
                 [(Arrow ((Unknown TypeHole), Bool));
                   (List (Unknown TypeHole))]),
              Bool))})))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  List.contains
Nature of error: Expecting type Bool but got inconsistent type (((? -> Bool), [?]) -> Bool)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: List.contains
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (((? -> Bool), [?]) -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: List.contains
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "then"
root ::= new-tokens

Top 20 Logits:
((:18.7065	prefix accepted:(
(:18.7065
 ((:13.6363	prefix accepted: (
([:13.5821	prefix accepted:(
(?:13.2917	prefix accepted:(
(_:13.2302	prefix accepted:(
(():13.1774	prefix accepted:(
($:12.6839	prefix accepted:(
({:12.5241	prefix accepted:(
 (:13.6363
(\:11.9059	prefix accepted:(
<:11.6482	rejected
(|:11.2059	prefix accepted:(
(@:11.1659	prefix accepted:(
?(:10.6247	rejected
(":10.3698	prefix accepted:(
(&:10.3171	prefix accepted:(
(%:10.0926	prefix accepted:(
($(:10.0752	prefix accepted:(
(`:9.93492	prefix accepted:(
[:9.85677	rejected
Rejected the highest logit candidate (( with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "String.starts_with" | "bool_of_string" | "case " | "fun " | "if " | "is_finite" | "is_infinite" | "is_nan" | "let " | "type "
root ::= new-tokens

Top 20 Logits:
fun:14.0292
eq:13.9957	rejected
id:12.4606	prefix accepted:i
x:11.9922	rejected
equal:11.992	rejected
fn:11.4449	prefix accepted:f
Id:11.4073	rejected
function:11.0827	prefix accepted:fun
equals:10.9957	rejected
song:10.9005	rejected
 fun:10.6079
is:10.5959
Int:10.586	rejected
func:10.5743	prefix accepted:fun

:10.5252
 (:10.4104
lambda:10.375	prefix accepted:l
i:12.4606
<:10.1638	rejected
s:10.0094	rejected
a:9.968	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(i

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(i
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <i>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "i"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  i
Nature of error: Variable i is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: i
LSP: Generating Completions for prefix: i
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "f " | "s_finite" | "s_infinite" | "s_nan"
root ::= completions

Top 20 Logits:
 ->:14.3382	rejected
 =>:12.9187	rejected
->:12.5366	rejected
$:11.6981	rejected
 $:10.4244	rejected
=>:10.2051	rejected
 ==:10.1871	rejected
id:10.1788	rejected
_:9.85546	rejected
 =:9.81235	rejected
=:9.75632	rejected
::9.72688	rejected
,:9.56508	rejected
 ==>:9.10142	rejected
 id:9.00614	rejected
1:8.87394	rejected
 -:8.81617	rejected
 <:8.67254	rejected
:::8.66508	rejected
=$:8.59735	rejected
 ::8.56492	rejected
Rejected the highest logit candidate  -> with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(i
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <is>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "is"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  is
Nature of error: Variable is is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: is
LSP: Generating Completions for prefix: is
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_finite" | "_infinite" | "_nan"
root ::= completions

Top 20 Logits:
_:15.6701
Equal:14.8324	rejected
Eq:12.7439	rejected
(:12.111	rejected
Id:12.0391	rejected
 id:11.6718	rejected
S:11.1768	rejected
 i:10.8186	rejected
,:10.6315	rejected
The:10.5866	rejected
Equals:10.2539	rejected
E:10.0153	rejected
id:9.84273	rejected
 equal:9.80033	rejected
 eq:9.6095	rejected
 =:9.52326	rejected
 ==:9.00661	rejected
 ->:8.90078	rejected
=:8.83363	rejected
 =>:8.81968	rejected
This:8.72013	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <is_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "is_"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  is_
Nature of error: Variable is_ is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: is_
LSP: Generating Completions for prefix: is_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "finite" | "infinite" | "nan"
root ::= completions

Top 20 Logits:
equal:18.641	rejected
same:17.6981	rejected
eq:16.971	rejected
id:16.4509	prefix accepted:i
song:16.2364	rejected
the:16.1141	rejected
this:14.5961	rejected
equals:14.3184	rejected
play:13.4985	rejected
current:13.4213	rejected
it:13.1423	prefix accepted:i
i:16.4509
equ:12.7198	rejected
in:12.646
ident:12.2873	prefix accepted:i
Id:12.0171	rejected
e:11.9988	rejected
a:11.9722	rejected
selected:11.9301	rejected
not:11.7958	prefix accepted:n
elem:11.6716	rejected
Rejected the highest logit candidate equal with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_i

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_i
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <is_i>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "is_i"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  is_i
Nature of error: Variable is_i is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: is_i
LSP: Generating Completions for prefix: is_i
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "nfinite"
root ::= completions

Top 20 Logits:
(:14.5495	rejected
,:14.0746	rejected
_:13.7551	rejected
 id:13.344	rejected
)(:11.3956	rejected
id:11.1442	rejected
D:10.6422	rejected
 =:10.5413	rejected
 i:10.5006	rejected
1:10.1529	rejected
.(:10.0672	rejected
=:9.39799	rejected
 ,:9.31651	rejected
0:9.18485	rejected
.:9.1476	rejected
):9.10797	rejected
ota:9.04019	rejected
3:8.93051	rejected
 (:8.87295	rejected
?(:8.85967	rejected
 equal:8.82982	rejected
Rejected the highest logit candidate ( with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_i
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <is_in>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "is_in"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  is_in
Nature of error: Variable is_in is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: is_in
LSP: Generating Completions for prefix: is_in
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "finite"
root ::= completions

Top 20 Logits:
_:12.0417	rejected
(:11.8628	rejected
,:11.491	rejected
 id:11.4536	rejected
j:10.6743	rejected
ter:9.59743	rejected
 i:9.23608	rejected
v:8.89867	rejected
([:8.45504	rejected
)(:8.40856	rejected
 [:8.36386	rejected
st:8.30225	rejected
__:8.22311	rejected
Eq:8.12156	rejected
teger:7.99719	rejected
js:7.99699	rejected
):7.94063	rejected
[:7.92347	rejected
 (:7.92203	rejected
 eq:7.8351	rejected
((:7.82504	rejected
Rejected the highest logit candidate _ with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_inf

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_inf
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <is_inf>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "is_inf"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  is_inf
Nature of error: Variable is_inf is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: is_inf
LSP: Generating Completions for prefix: is_inf
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "inite"
root ::= completions

Top 20 Logits:
(:12.0879	rejected
 id:11.8159	rejected
,:11.6692	rejected
_:10.9774	rejected
 i:10.7793	rejected
ct:8.35952	rejected
us:8.30178	rejected
.:8.02354	rejected
)(:8.02283	rejected
 equal:7.98781	rejected
de:7.95292	rejected
os:7.94733	rejected
 (:7.75313	rejected
j:7.61813	rejected
am:7.49662	rejected
):7.46401	rejected
.(:7.45892	rejected
1:7.3767	rejected
Id:7.37622	rejected
,(:7.35931	rejected
 =:7.35607	rejected
Rejected the highest logit candidate ( with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinit

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinit
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_inf
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <is_infinit>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "is_infinit"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  is_infinit
Nature of error: Variable is_infinit is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: is_infinit
LSP: Generating Completions for prefix: is_infinit
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "e"
root ::= completions

Top 20 Logits:
ly:11.8078	rejected
ive:11.5648	rejected
_:11.2575	rejected
,:10.9354	rejected
(:10.6106	rejected
es:10.4366	prefix accepted:e
elo:10.3681	prefix accepted:e
el:10.0383	prefix accepted:e
able:9.4279	rejected
ude:9.10417	rejected
us:8.96952	rejected
 i:8.89858	rejected
et:8.60339	prefix accepted:e
ary:8.47722	rejected
um:8.44875	rejected
ie:8.40695	rejected
i:8.38823	rejected
 id:8.33835	rejected
ively:8.2864	rejected
elly:8.16978	prefix accepted:e
est:8.0864	prefix accepted:e
Rejected the highest logit candidate ly with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinit
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <is_infinite>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: (Float -> Bool)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {
           ana =
           (Prod
              [(Arrow ((Unknown TypeHole), Bool)); (List (Unknown TypeHole))]);
           syn = (Arrow (Float, Bool))})))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  is_infinite
Nature of error: Expecting type ((? -> Bool), [?]) but got inconsistent type (Float -> Bool)
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: is_infinite
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Float -> Bool)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow (Float, Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: is_infinite
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Arrow (Float, Bool))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")" | ","
root ::= new-tokens

Top 20 Logits:
,:12.4548
_:12.419	rejected
(:12.0463
 id:11.6772	prefix accepted: 
 i:9.83672	prefix accepted: 
)(:9.60205	prefix accepted:)
Loop:9.29108	rejected
):9.60205
((:8.14039	prefix accepted:(
 loop:8.03588	prefix accepted: 
,(:8.03037	prefix accepted:,
play:7.80624	rejected
(),:7.79634	prefix accepted:(
.:7.75878	rejected
?:7.69262	rejected
id:7.56522	rejected
 ,:7.52981
Id:7.52637	rejected
 s:7.52597	prefix accepted: 
Equal:7.52582	rejected
lem:7.47028	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((Float -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ((? -> Bool), [?])
  LSP: Info: Seft type: ((Float -> Bool), [?])
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current_state epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow (Float, Bool)); (List (Unknown TypeHole))])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
(? -> Bool) <= ((? -> Bool), [?])
  LSP: Convex: Target types: (? -> Bool), ((? -> Bool), [?])
  LSP: Convex: Backpack: 
  LSP: Convex: Base: ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.contains List.eq List.fold_left List.fold_right List.is_empty String.starts_with bool_of_string case  fun  if  is_finite is_infinite is_nan let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "pl" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 id:13.9304
 songs:13.8249
 [:13.3317
 get:13.1509
 i:11.3478
 List:11.302
song:11.0195
 song:10.5486
 (:10.1135
 ids:9.70907	prefix accepted: id
 pl:9.49809
 add:9.32608	prefix accepted: a
 play:9.25972	prefix accepted: pl
id:9.19279
 [(:9.08415	prefix accepted: [
 current:9.04176
 list:8.8879	prefix accepted: l
get:8.8192
 map:8.72073	prefix accepted: ma
 {:8.43821	prefix accepted: 
 :8.43821

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (List (Unknown TypeHole)); syn = (Var "Id")})))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) then else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: ((? -> Bool), [?])
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow (Float, Bool)); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: id
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: (? -> Bool), ((? -> Bool), [?])
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (Arrow ((Unknown TypeHole), Bool)) (List (Unknown TypeHole))
LSP: commas: self syn is (Prod [(Arrow (Float, Bool)); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current_state epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):14.863
:::14.6049	rejected
,:13.7661	rejected
)(:12.4786	prefix accepted:)
 :::11.5764	prefix accepted: 
),:10.486	prefix accepted:)
)):10.0541	prefix accepted:)
 +:9.38184	prefix accepted: 
 =:9.30908	prefix accepted: 
 ):9.29032
)[:8.90405	prefix accepted:)
 ,:8.87702	prefix accepted: 
;:8.73079	rejected
 ||:8.6839	prefix accepted: 
 in:8.53018	prefix accepted: 
).:8.37893	prefix accepted:)
 ==:8.3672	prefix accepted: 
);:8.26946	prefix accepted:)
)::8.24733	prefix accepted:)
){:8.22362	prefix accepted:)
 @:8.17084	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Application
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Bool
  LSP: Concave: Infix: Base: && \/
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: && \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: && \/
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "&&" | "\\/" | "then"
root ::= new-tokens

Top 20 Logits:
 then:15.715
 &&:13.3482

:13.1886
 ||:12.5627	prefix accepted: 
 :12.5627
 songs:12.3255	prefix accepted: 
 (:11.6692	prefix accepted: 
 #:11.0468	prefix accepted: 
 ==:10.8221	prefix accepted: 
 =:10.3788	prefix accepted: 
 current:10.198	prefix accepted: 
 id:9.93114	prefix accepted: 
 in:9.80943	prefix accepted: 
((:9.79953	rejected
 and:9.72785	prefix accepted: 
 ((:9.66627	prefix accepted: 
 false:9.66107	prefix accepted: 
 {:9.54916	prefix accepted: 
 true:9.53144	prefix accepted: t
 pl:9.40534	prefix accepted: 
 i:9.33841	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:15.7412
 pl:14.4173
 :14.2576
 #:13.6954	prefix accepted: 
 (:13.5583
 [:12.688
 songs:12.4643
 {:12.4012	prefix accepted: 
 play:12.3784	prefix accepted: pl
 []:12.0752
 ():12.0303	prefix accepted: (
  :11.9895
 ([:11.8177	prefix accepted: (
 add:11.6377	prefix accepted: a
 ((:11.2936	prefix accepted: (
 id:11.0913
 raise:11.012	prefix accepted: 
 error:10.9155	prefix accepted: 
 get:10.8691
    :10.8355
   :10.7131

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:19.446
 #:16.0714	prefix accepted: 
 pl:14.6523
0:13.9215
 [:13.7741
 (:13.7457
 songs:13.4561
1:13.3667
 (*:13.3617	prefix accepted: (
 play:13.2122	prefix accepted: pl
 {:12.5782	prefix accepted: 
 []:12.3843
	:12.0321	rejected
 ([:11.9484	prefix accepted: (
 song:11.7249
 ((:11.6567	prefix accepted: (
 List:11.5874
 ():11.5657	prefix accepted: (
 fail:11.5112	prefix accepted: 
2:11.1759
 add:11.0821	prefix accepted: a

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
       :20.0621
         :19.2502
        :16.2337
     :15.8341
           :15.1613
      :14.9018
	:14.6913	rejected
          :14.6211
             :13.6176
                :13.2282
   :12.739
               :12.6788
            :12.6513
    :12.3532

:11.9578
              :11.3759
  :11.0397
#:10.5896	rejected
 :10.3753
(:8.84846
(*:8.83606	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
       

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
       
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:15.433
 #:14.9861	prefix accepted: 
 pl:14.6977
 let:13.7635
 ([:13.6817	prefix accepted: (
 play:13.3006	prefix accepted: pl
 if:13.0014
 [:12.3924
 songs:12.2494
 ((:12.1845	prefix accepted: (
 case:11.8871
 add:11.8786	prefix accepted: a
 fail:11.8716	prefix accepted: 
 (*:11.7281	prefix accepted: (
 raise:11.6901	prefix accepted: 
 match:11.5147	prefix accepted: ma
 error:11.3091	prefix accepted: 
 update:10.9041
 {:10.8509	prefix accepted: 
 print:10.8443	prefix accepted: p
 Play:10.7505	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
       
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:14.8084
id:13.563
List:11.9342
get:11.2128
pl:10.9882
add:10.7998	prefix accepted:a
play:10.6978	prefix accepted:pl
if:10.54
current:10.176	prefix accepted:c
i:10.0679
in:10.0536
list:9.79782	prefix accepted:l
 songs:9.71975
[]:9.62196
Id:9.40801	rejected
ids:9.39053	prefix accepted:id
remove:9.20597	rejected
cons:9.11546	prefix accepted:c
sing:9.04781	prefix accepted:s

:9.01588
 id:8.90625

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:19.1211
:::12.781	rejected
,:11.6634	rejected
 :::11.2572	rejected
_:11.1685	rejected
@:10.9156	rejected
 @:10.5378	rejected
Id:9.62062	rejected
 +:9.29005	rejected
ss:8.84468	prefix accepted:s
list:8.68677	rejected
 //:8.65674	rejected
es:8.59878	rejected
.:8.57222	rejected
si:8.53704	prefix accepted:s
 id:8.51023	rejected
::8.41943	rejected
st:8.41345	prefix accepted:s
id:8.4131	rejected
//:8.3824	rejected
[:8.36625	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
 @:16.7295
,:15.413
@:13.2368
 ++:13.1478	prefix accepted: 
 ,:11.2203
 +:11.1591	prefix accepted: 
++:10.5871	rejected
:::10.2296	rejected
 ::10.1107	prefix accepted: 
 :::9.33998	prefix accepted: 
::8.93155	rejected
++,:8.66115	rejected
 #:8.65882	prefix accepted: 
 :13.1478
+:8.49592	rejected
 |:8.46538	prefix accepted: 
):8.36905

:8.33018
.:8.26768	rejected
,[:8.15482	prefix accepted:,
@@:8.09397	prefix accepted:@

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current_state get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "current_state" | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 current:15.3027
 No:14.9421
 P:12.846
 state:11.8962	prefix accepted: 
current:11.1667
 get:11.0133
 add:10.9539	prefix accepted: 
 Play:10.6697
 Add:10.4974	prefix accepted: 
 no:10.3651	prefix accepted: 
 In:9.79551	prefix accepted: 
 play:9.6747	prefix accepted: 
 pl:9.63824	prefix accepted: 
 Current:9.52422	prefix accepted: 
 (:9.32438
 :11.8962
 song:9.15685	prefix accepted: 
 id:8.98463	prefix accepted: i
 Song:8.91881	prefix accepted: 
 inf:8.91216	prefix accepted: i
 if:8.69046

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, No

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, No
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  No
Nature of error: Constructor is not defined  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current_state get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:18.7671
Current:12.6766	rejected
Play:11.7142	rejected
In:11.455	rejected
Selected:11.3796	prefix accepted:S
Selection:11.2685	prefix accepted:S
State:11.1255	prefix accepted:S
Sound:11.0006	prefix accepted:So
_:10.8626	rejected
New:10.6608	rejected
Action:10.561	rejected
P:10.5208	rejected
Inf:10.2269	rejected
Add:10.047	rejected
Sing:10.0077	prefix accepted:S
Change:9.92491	rejected
More:9.79058	rejected
Music:9.71735	rejected
C:9.7157	rejected
Track:9.63539	rejected
Error:9.59951	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, No
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  NoS
Nature of error: Constructor is not defined  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current_state get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:18.0978
ongs:12.6936	prefix accepted:ong
on:12.1062
In:11.1663	rejected
in:10.7085	rejected
ng:10.6789	rejected
ung:10.4939	rejected
song:10.0433	rejected
oon:9.98368	prefix accepted:o
n:9.57312	rejected
ongo:9.18939	prefix accepted:ong
ing:9.1653	rejected
ang:9.13364	rejected
inger:9.1295	rejected
om:9.00936	prefix accepted:o
ond:8.72583	prefix accepted:on
og:8.61049	prefix accepted:o
ou:8.55408	prefix accepted:o
one:8.54694	prefix accepted:on
oup:8.54516	prefix accepted:o
inf:8.50074	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  NoSong
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current_state get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:21.1144
Se:14.1375
Select:14.062
selected:13.104	rejected
Add:12.659	rejected
Play:12.6548	rejected
):12.4887	rejected
S:12.1946
Available:11.8532	rejected
Selection:11.8072	prefix accepted:Select
P:11.483	rejected
In:11.0762	rejected
Selector:11.0158	prefix accepted:Select
Is:10.7307	rejected
Error:10.6575	rejected
Start:10.6242	prefix accepted:S
Found:10.4993	rejected
Id:10.4648	rejected
 Selected:10.4278	rejected
Set:10.3797	prefix accepted:Se
Current:10.1775	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current_state get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):18.8016
 ):14.9222
);:13.5915	prefix accepted:)
()):13.549	rejected
),:12.6474	prefix accepted:)
)):12.5419	prefix accepted:)
)::12.241	prefix accepted:)
 @:11.502	prefix accepted: 
::11.4394	rejected
(:11.2862	rejected
 ::11.1088	prefix accepted: 
(*:10.9898	rejected
 :11.502
,:10.7558	rejected
():10.4696	rejected
(@:10.2705	rejected
@:10.2657	rejected

:10.2207
).:10.0599	prefix accepted:)
)(:9.712	prefix accepted:)
 as:9.58295	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "else"
root ::= new-tokens

Top 20 Logits:

:18.7615
 :17.6817
  :17.0534
 #:16.9288	prefix accepted: 
 else:15.7184
   :15.6639
    :14.9955
 (*:14.843	prefix accepted: 
 @:14.4242	prefix accepted: 
      :14.3441
        :14.1824
                :14.044
          :13.3364
         :13.279
            :12.9413
     :12.9321
#:12.877	rejected
 end:12.7858	prefix accepted: e
           :12.7414
 --:12.7	prefix accepted: 
       :12.5397

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "else"
root ::= new-tokens

Top 20 Logits:

:21.2182
 #:19.8111	prefix accepted: 
 (*:16.6924	prefix accepted: 
	:15.0905	rejected
 --:15.0676	prefix accepted: 
 else:15.0578
 *:13.9158	prefix accepted: 
 ##:13.9006	prefix accepted: 
 #(:13.7863	prefix accepted: 
 //:13.5754	prefix accepted: 
 -:12.9703	prefix accepted: 
 ###:12.7189	prefix accepted: 
 %:12.4889	prefix accepted: 
 #[:12.449	prefix accepted: 
 end:12.389	prefix accepted: e
 ::12.3353	prefix accepted: 
 ---:12.2423	prefix accepted: 
 @:12.2146	prefix accepted: 
 <:12.1225	prefix accepted: 
 (:12.0123	prefix accepted: 
1:11.9638	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "else"
root ::= new-tokens

Top 20 Logits:
     :20.241
       :16.6268
      :16.4539
   :16.1198
    :15.1817
         :14.8389
        :14.7747
	:14.0181	rejected
           :13.6856
          :13.6626

:13.5323
else:12.9134
                :12.6384
             :12.2139
#:12.08	rejected
            :12.0783
 :12.0598
               :11.8268
              :11.5349
  :11.4235
(*:10.1385	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "else"
root ::= new-tokens

Top 20 Logits:
 else:22.7888
 #:18.3457	prefix accepted: 
 elif:17.6845	prefix accepted: el
 end:16.9504	prefix accepted: e
 els:16.5007
 (*:14.5348	prefix accepted: 
 if:13.8032	prefix accepted: 
 fi:13.7139	prefix accepted: 
 ##:12.9381	prefix accepted: 
 el:17.6845
 //:12.5363	prefix accepted: 
 let:12.3434	prefix accepted: 
 Else:12.2481	prefix accepted: 
 --:12.1929	prefix accepted: 
 #(:11.4942	prefix accepted: 
 otherwise:11.3862	prefix accepted: 
 {:11.3202	prefix accepted: 
 *:11.3016	prefix accepted: 
 es:11.2202	prefix accepted: e
 ###:11.1765	prefix accepted: 
 (:11.1764	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 :17.1123

:16.79
 if:16.5185
 (:15.2116
  :14.9719
   :14.6229
    :14.1139
 #:13.6446	prefix accepted: 
      :12.7463
        :12.4739
 ((:12.2001	prefix accepted: (
 let:12.1445
if:12.086
                :12.0837
 {:12.083	prefix accepted: 
 case:12.0358
 ():12	prefix accepted: (
 [:11.9018
         :11.8989
     :11.8445
 match:11.7837	prefix accepted: ma

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
id:14.0827
List:14.0758
song:13.8939

:12.7135
if:12.0939
add:11.1949	prefix accepted:a
get:11.1733
cons:11.1694	prefix accepted:c
current:10.932	prefix accepted:c
play:10.7193	prefix accepted:pl
pl:10.7193
i:10.4673
ids:10.2049	prefix accepted:id
 :10.1478
list:10.0675	prefix accepted:l
 songs:9.93436
Cons:9.74561	rejected
in:9.69662
 id:9.60428
unique:9.48452	prefix accepted:u
((:9.12924	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:19.4578
:::12.6382	rejected
_:11.0033	rejected
,:10.8751	rejected
Id:10.4339	rejected
 :::10.3387	rejected
::9.70187	rejected
 @:9.14471	rejected
song:9.05173	prefix accepted:s
 id:8.92396	rejected
@:8.7396	rejected
 ::8.68132	rejected
):8.63914	rejected
 songs:8.48864	rejected
 i:8.44516	rejected
ss:8.42576	prefix accepted:s
is:8.41851	rejected
id:8.36887	rejected
.:8.26639	rejected
[:8.25589	rejected
List:8.21254	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
 @:17.3094
 ++:14.0705	prefix accepted: 
@:13.7642
,:13.6897
 +:12.1115	prefix accepted: 
++:11.595	rejected
:::10.407	rejected
 ::10.1163	prefix accepted: 
 :::9.54327	prefix accepted: 
::9.41366	rejected
+:9.29746	rejected
 ,:9.27152
++,:8.85153	rejected
 ^:8.73376	prefix accepted: 
 #:8.71497	prefix accepted: 
 &:8.67416	prefix accepted: 
 |:8.63612	prefix accepted: 
 $:8.63383	prefix accepted: 
 :14.0705
 <:8.50854	prefix accepted: 
 <>:8.48075	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >@<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List Concatenation
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: @
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current_state epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: @
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "pl" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 [:19.4905
 id:14.6035
[:14.5805
 i:13.3562
 [],:13.0139	prefix accepted: []
 (:12.7827
 [(:12.7826	prefix accepted: [
 List:11.9965
 ids:11.838	prefix accepted: id
 Id:11.7627	prefix accepted: 
 get:11.7111
 ([:11.3124	prefix accepted: (
 if:10.7523
 :11.7627
 {:10.5998	prefix accepted: 
 list:10.4771	prefix accepted: l
 <:10.4609	prefix accepted: 
 #[:10.1742	prefix accepted: 
 Cons:10.1418	prefix accepted: 
 [[:10.0856	prefix accepted: [
 :10.0501	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <[ ]<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [?]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs @ ?
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-convex or complete: [
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs id action pl update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current_state epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Generating Completions for prefix: [
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 [?]
? <= [?]
? <= [?]
  LSP: Convex: Target types: ?, [?]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songs [] ( [ case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current_state epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "]"
new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current_state" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "pl" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= completions | new-tokens

Top 20 Logits:
id:18.0512
i:12.6217
Id:12.427	rejected
song:11.7254
current:11.7188
get:11.4082
 id:11.0806
if:10.9599
inf:10.8932
play:10.838	prefix accepted:pl
Play:10.7385
add:10.6573	prefix accepted:a
1:10.5473
x:10.2935	rejected
new:10.2275	prefix accepted:ne
0:10.1681
In:10.0381	rejected
List:10.0206
#:10.0009	rejected
pl:10.838
Add:9.82727

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ] ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs @ id
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: List literal
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: == != <= >= < > + - * / ** ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != * ** + - / :: < <= == > >=
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != * ** + - / :: < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: id
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: ]
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state songs id action pl update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current_state epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "," | "-" | "/" | "::" | "<" | "<=" | "==" | ">" | ">=" | "]"
root ::= new-tokens

Top 20 Logits:
],:20.9367	prefix accepted:]
]:20.9367
]):15.1523	prefix accepted:]
]),:12.4994	prefix accepted:]
::12.0145
],[:11.8442	prefix accepted:]
 +:11.6501
 ::11.6263
]::11.5293	prefix accepted:]
];:11.5021	prefix accepted:]
,:11.233
 ],:11.2196	prefix accepted: ]
:::10.806
 %:10.4902	prefix accepted: 
].:10.4473	prefix accepted:]
])):10.4389	prefix accepted:]
 -:10.4177
;:10.3392	rejected
+:10.2879
](:9.99109	prefix accepted:]
 as:9.87537	prefix accepted: 
Rejected the highest logit candidate ], with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id]

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id]
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <[ ]>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: List literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: [?]
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs @ id
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: List Concatenation
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: :: @
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: :: @
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "::" | "@"
root ::= new-tokens

Top 20 Logits:
 ,:16.5684
 @:14.1138
 |:12.2508	prefix accepted: 
 ::11.6522

:11.6374
 :::11.6367
 #:11.5183	prefix accepted: 
 ++:11.285	prefix accepted: 
:::10.9639
 +:10.8882	prefix accepted: 
 :12.2508
 List:10.7139	prefix accepted: 
@:10.71
 -:10.5966	prefix accepted: 
 ):10.3315
 &:9.73408	prefix accepted: 
 ||:9.31958	prefix accepted: 
   :9.1901
 --:9.12456	prefix accepted: 
 {:9.11858	prefix accepted: 
 %:9.08879	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] ,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] ,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id]
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current_state get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "current_state" | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 current:14.6086
 No:14.5774
current:13.9256
No:13.1938
 P:12.4304
 get:10.9569
 if:10.613
 :10.5958
P:10.2786
 Play:10.2178
 state:9.92933	prefix accepted: 
 (:9.92456
if:9.82718
 no:9.74917	prefix accepted: 
 add:9.69037	prefix accepted: 

:8.99366
get:8.9139
 Current:8.72739	prefix accepted: 
 Get:8.27624	prefix accepted: 
 play:8.27367	prefix accepted: 
 Add:8.18084	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] ,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "current"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  current
Nature of error: Variable current is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: current
LSP: Generating Completions for prefix: current
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current_state get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "_state"
root ::= completions

Top 20 Logits:
_:20.4197
):13.5581	rejected
 state:13.2341	rejected
State:13.03	rejected
 ):12.0004	rejected
state:11.0817	rejected
()):10.6696	rejected
(:10.5429	rejected
-:10.1434	rejected
 _:10.1273	rejected
_):9.82167	prefix accepted:_
():9.43164	rejected
S:8.9403	rejected
.:8.68709	rejected

:8.66976	rejected
__:8.60933	prefix accepted:_
);:8.58352	rejected
 =:8.28399	rejected
)):8.21262	rejected
::8.1846	rejected
:::7.89858	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current_>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "current_"))
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  current_
Nature of error: Variable current_ is not bound
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: current_
LSP: Generating Completions for prefix: current_
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current_state get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "state"
root ::= completions

Top 20 Logits:
state:21.5216
stat:13.0868
states:13.0381	prefix accepted:state
s:12.7482
status:12.6546	prefix accepted:stat
st:12.6434
State:12.4137	rejected
 state:12.2012	rejected
name:11.9681	rejected
stage:11.7044	prefix accepted:sta
value:11.3296	rejected
time:11.251	rejected
type:11.2119	rejected
sta:11.7044
step:10.9234	prefix accepted:st
statement:10.6749	prefix accepted:state
string:10.6181	prefix accepted:st
size:10.5937	prefix accepted:s
station:10.5407	prefix accepted:stat
str:10.5002	prefix accepted:st
style:10.4737	prefix accepted:st

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current_state>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: current_state
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: current_state
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current_state NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current_state get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):19.559
 ):17.8087
);:13.9913	prefix accepted:)
 end:12.9661	prefix accepted: 
)):12.6915	prefix accepted:)
 :12.9661
 @:12.4879	prefix accepted: 

:12.2041
),:12.0045	prefix accepted:)
@:11.1588	rejected
()):11.002	rejected
 +:10.943	prefix accepted: 
,:10.7947	rejected
  :10.6111
)]:10.4259	prefix accepted:)
(:10.3576	rejected
 (*:10.3346	prefix accepted: 
 );:10.3189	prefix accepted: )
 #:10.1196	prefix accepted: 
 ::10.1171	prefix accepted: 
 ==:10.113	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.0567
 :17.5938
   :16.8667
  :16.7681
 end:16.6599
    :16.3805
 #:15.9828	prefix accepted: 
      :15.8405
                :14.9277
        :14.9041
         :14.0288
     :14.0102
          :13.9995
            :13.9699
 (*:13.759	prefix accepted: 
              :13.6588
           :13.3015
       :13.2634
             :12.9823
               :12.7413
#:12.5869	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :18.8702
   :17.2288
      :16.9302

:16.5183
    :16.2903
        :15.8609
  :15.8137
     :14.5775
          :14.1326
|:13.8549
end:13.8522
            :13.4721
                :13.335
 |:13.1265
       :12.8078
         :12.7775
	:12.7544	rejected
in:12.599	rejected
#:12.5636	rejected
              :12.0027
(*:11.9744	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:20.8444
 #:17.1025	prefix accepted: 
 end:17.0189
 |:15.7828
 (*:15.2108	prefix accepted: 
	:14.1446	rejected
 else:13.7643	prefix accepted: e
 ::13.6618	prefix accepted: 
 where:12.7877	prefix accepted: 
 *:12.5526	prefix accepted: 
 fi:12.4413	prefix accepted: 
 ||:12.2113	prefix accepted: |
 <:12.1959	prefix accepted: 
 case:12.0495	prefix accepted: 
 (:11.9999	prefix accepted: 
 elif:11.9619	prefix accepted: e
 #(:11.7094	prefix accepted: 
 in:11.5689	prefix accepted: 
 /:11.5469	prefix accepted: 
0:11.4763	rejected
 (**:11.4411	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :18.4795
   :15.78
    :15.0025
  :14.5257

:14.3993
      :14.285
|:13.8796
     :13.759
        :13.6631
 |:13.4671
#:13.4227	rejected
let:12.9739	rejected
          :12.1554
            :12.0362
	:11.9382	rejected
end:11.916
       :11.8729
(*:11.5637	rejected
                :11.5069
 #:11.2744	prefix accepted: 
         :11.1945

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current_state: PlayListState, songs: [Id], id: Id, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.5243
 #:17.4891	prefix accepted: 
 (*:15.4176	prefix accepted: 
 case:14.4471	prefix accepted: 
 end:14.3598
 //:13.7808	prefix accepted: 
 /*:12.1102	prefix accepted: 
 else:11.9934	prefix accepted: e

:11.841
 *:11.8253	prefix accepted: 
 (**:11.647	prefix accepted: 
 --:11.5933	prefix accepted: 
 ||:11.4672	prefix accepted: |
 ##:11.4072	prefix accepted: 
 let:11.3008	prefix accepted: 
 elif:11.1209	prefix accepted: e
 ~:11.1125	prefix accepted: 
 in:11.0502	prefix accepted: 
 ///:11.0073	prefix accepted: 
 <:10.9962	prefix accepted: 
 -:10.9613	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "AddSong" | "PauseCurrentSong" | "PlaySong" | "RemoveSong" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Play:17.3859
 Remove:17.1467
 P:16.1846
 _:12.8747
Play:10.9579
 Rem:10.8077
Remove:10.5926
 No:10.3423	prefix accepted: 
 :10.3423
 Player:9.93138	prefix accepted: Play
 Add:9.78951
 Delete:9.67665	prefix accepted: 
P:9.63108
 Next:9.48052	prefix accepted: 
 play:9.29156
 remove:9.25569
 Move:8.95289	prefix accepted: 
 Start:8.95178	prefix accepted: 
 Stop:8.83939	prefix accepted: 
 Change:8.83353	prefix accepted: 
 Clear:8.81515	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "auseCurrentSong" | "laySong"
root ::= completions

Top 20 Logits:
ause:22.7119
aused:14.7794	prefix accepted:ause
ush:13.2014	rejected
au:12.8195
ull:12.4329	rejected
aus:12.193
LAY:12.1884	rejected
rep:11.9989	rejected
urchase:11.2471	rejected
ulse:11.1468	rejected
aste:10.9104	prefix accepted:a
ose:10.7032	rejected
ure:10.622	rejected
aint:10.5696	prefix accepted:a
ending:10.4651	rejected
refix:10.4514	rejected
lay:10.3324
lain:10.0563	prefix accepted:la
alette:10.0465	prefix accepted:a
ace:9.87291	prefix accepted:a
play:9.87018	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | Pause

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | Pause
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Pause>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Pause"))))
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Pause
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Pause
LSP: Generating Completions for prefix: Pause
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "CurrentSong"
root ::= completions

Top 20 Logits:
Current:21.171
 =>:14.3705	rejected
S:13.5729	rejected
C:13.0725
On:12.4872	rejected
 ->:10.9064	rejected
():10.7021	rejected
(:10.6793	rejected
Cur:10.5717
 Current:10.5145	rejected
current:10.0451	rejected
_:10.0033	rejected
All:9.84464	rejected
 on:9.82455	rejected
Play:9.65416	rejected
Or:9.36229	rejected
Action:9.22179	rejected

:8.99871	rejected
=>:8.95467	rejected
 |:8.87759	rejected
Music:8.82137	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrent

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrent
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | Pause
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrent>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PauseCurrent"))))
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  PauseCurrent
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PauseCurrent
LSP: Generating Completions for prefix: PauseCurrent
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Song"
root ::= completions

Top 20 Logits:
S:20.9739
Sound:12.328	prefix accepted:So
 song:11.2808	rejected
 =>:11.2288	rejected
 Song:11.1368	rejected
SON:11.0929	prefix accepted:S
ly:10.5941	rejected
(:10.4588	rejected
():10.2969	rejected
 ->:10.2383	rejected
On:10.0197	rejected
Play:10.0157	rejected

:9.5655	rejected
song:9.34764	rejected
State:9.19367	prefix accepted:S
 on:9.16374	rejected
SO:9.03127	prefix accepted:S
Action:8.95033	rejected
_:8.55675	rejected
 :8.51038	rejected
 |:8.40284	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrent
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrentS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "PauseCurrentS"))))
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  PauseCurrentS
Nature of error: Constructor is not defined  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: PauseCurrentS
LSP: Generating Completions for prefix: PauseCurrentS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ong"
root ::= completions

Top 20 Logits:
ong:21.9703
ongs:14.2826	prefix accepted:ong
on:14.2322
 song:12.456	rejected
song:12.123	rejected
ng:12.034	rejected
ongo:11.3015	prefix accepted:ong
oon:11.1517	prefix accepted:o
og:10.8016	prefix accepted:o
ony:10.4941	prefix accepted:on
ou:10.2667	prefix accepted:o
ig:10.2595	rejected
g:9.86315	rejected
one:9.82435	prefix accepted:on
n:9.74151	rejected
onic:9.58626	prefix accepted:on
oup:9.49195	prefix accepted:o
ug:9.46913	rejected
ond:9.36867	prefix accepted:on
oul:9.34268	prefix accepted:o
ang:9.29153	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PauseCurrentSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListAction
  LSP: Info: Seft type: PlayListAction
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListAction
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PauseCurrentSong
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: PauseCurrentSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: PauseCurrentSong _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( AddSong PauseCurrentSong PlaySong RemoveSong _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.5336
=>:13.5242
 :13.1379
 when:12.2497	prefix accepted: 
 ->:12.1326	prefix accepted: 

:11.2741
,:10.7449	rejected
  :10.7443
 if:10.5545	prefix accepted: 
   :10.4038
 |:10.0368	prefix accepted: 
    :9.99195
 :=:9.61503	prefix accepted: 
 ||:9.51462	prefix accepted: 
 or:9.07259	prefix accepted: 
 =:8.97286
 as:8.94321	prefix accepted: 
	:8.86763	rejected
 ==>:8.61191	prefix accepted: =
     :8.60705
 ,:8.57916	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:18.4145
 :17.2114
  :14.633
 #:14.4736	prefix accepted: 
 let:14.144
    :13.9799
   :13.9105
 (:13.3301
 case:13.0861
 (*:12.9068	prefix accepted: (
 match:12.6897	prefix accepted: ma
                :12.6621
        :12.4398
 get:12.4254
 if:12.2801
            :12.1289
         :11.9867
 P:11.9035	prefix accepted: 
 pause:11.8167	prefix accepted: p
     :11.8108
      :11.6431

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:20.5345
 #:15.5968	prefix accepted: 
 case:15.2447
 let:14.5599
 (*:13.8769	prefix accepted: (
	:13.7882	rejected
 (:13.8769
 match:13.7134	prefix accepted: ma
 P:12.6795	prefix accepted: 
 if:12.2705
 song:12.217	prefix accepted: s
 fun:12.0499	prefix accepted: 
 get:12.0421
 ():11.9461	prefix accepted: (
 play:11.6233	prefix accepted: pl
 pause:11.5989	prefix accepted: p
1:11.4738
0:11.4232
 begin:11.2251	prefix accepted: 
 ((:11.1623	prefix accepted: (
 s:12.217

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
   :19.2149
     :19.014
    :16.7967
       :16.0315
         :15.6452
      :14.8705
        :14.2733
 :14.0575
           :13.7498
  :13.5646
	:13.507	rejected
          :12.8686

:12.7557
             :12.6891
                :12.0625
            :11.9951
               :11.9071
              :11.1113
#:10.0502	rejected
let:9.27266
(*:8.86986	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 let:21.9102
 case:18.9533
 #:17.3386	prefix accepted: 
 match:17.0815	prefix accepted: ma
 (:16.7587
 if:16.6105
 get:15.2917
 begin:14.7183	prefix accepted: 
 (*:14.4365	prefix accepted: (
 ((:13.7913	prefix accepted: (
 update:13.5956
 play:13.4805	prefix accepted: pl
 P:13.4639	prefix accepted: 
 Play:13.2266	prefix accepted: 
 fun:12.9857	prefix accepted: 
 ([:12.7984	prefix accepted: (
 pause:12.7191	prefix accepted: p
 fail:12.3927	prefix accepted: 
 assert:12.3123	prefix accepted: a
 pl:13.4805
 //:12.3017	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:18.4289
 song:13.8997
 ids:12.2231
 s:12.1641
 current:11.6918
 play:11.6373
 _,:11.5798	prefix accepted: _
 all:11.5077
 _:11.5798
 (:10.8521
 list:10.7999
 cur:10.7205
 new:10.2902
 curr:10.2224
 id:10.1966
 state:10.0259
 i:9.93859
 xs:9.90108
 Songs:9.79949	prefix accepted: 
 l:9.79485
 ss:9.78947

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:19.7046
 =:17.3232
 ,:14.9865
_:13.8076
::12.5006
 ::12.2981
_,:12.2462	prefix accepted:_
=:11.5055
1:10.9735
 :10.7495
@:10.3148	rejected
',:10.1668	rejected
 list:9.94296	prefix accepted: 
2:9.85451
List:9.49957
 @:9.42224	prefix accepted: 
0:9.38708
 in:9.33921	prefix accepted: 
 _,:9.28286	prefix accepted: 
=[:9.23358	prefix accepted:=
,(:9.18079	prefix accepted:,

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:15.6341
 state:15.0082
 _:12.7816
 playing:12.7262
 song:12.1854
 play:11.8033
current:11.5061
 Play:11.2748
 old:11.112
 No:10.86
 P:10.8406
 curr:10.5588
 cur:10.3663
 c:10.1987
 selected:9.73335
 s:9.72274
 id:9.5972
 cs:9.43678
 p:9.27883
 paused:9.19868
 no:8.98451

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: ?, songs: ?, action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
_:20.3991
 =:19.5586
State:15.7543
=:13.6878
S:12.9061
state:12.4127
 :12.2689
Play:11.6826
 state:11.4068	prefix accepted: 
__:11.1579
 ->:10.6833	prefix accepted: 
Id:10.6221
play:10.26
St:10.0627
 song:9.97986	prefix accepted: 
Status:9.84605
1:9.72822
song:9.5416
::9.49339
-:9.31685	rejected
 ::9.28733

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "pl" | "sin" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 pl:20.2028
 get:15.6171
 play:15.0881	prefix accepted: pl
 :12.7238
pl:12.1479
 p:10.8892
 (:10.796

:10.7362
 current:10.5925	prefix accepted: c
 plt:10.5237	prefix accepted: pl
 Play:9.69655
 action:9.62907
 Pl:9.37252
 Get:9.30128	prefix accepted: 
 list:8.85794	prefix accepted: l
play:8.61841	prefix accepted:pl
 plays:8.47918	prefix accepted: pl
 pal:8.46731	prefix accepted: pa
 plat:8.43592	prefix accepted: pl
 update:8.4036
 pr:8.37539	prefix accepted: p

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: pl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: pl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:21.2008
 :14.2202

:13.3414
,:11.615
.:11.4118	rejected
 and:11.1949	prefix accepted: 
  :11.1639
;:11.092	rejected
   :10.6329
in:9.79881
    :9.71184
 ;:9.30929	prefix accepted: 
 where:9.17002	prefix accepted: 
 #:9.1355	prefix accepted: 
 ,:9.07357
 |:8.98183	prefix accepted: 
#:8.96399	rejected
	:8.81646	rejected
():8.72798	rejected
::8.52489
                :8.37511

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:20.0133
 :18.2226
   :16.0638
  :15.9524
    :15.8174
      :13.8799
     :13.7796
        :13.7593
          :13.4948
                :13.4445
 case:13.2931
         :13.2072
 (:13.0239
            :12.9516
 #:12.9107	prefix accepted: 
 match:12.8279	prefix accepted: ma
       :12.7565
           :12.5716
              :12.2628
             :12.1796
 (*:12.1379	prefix accepted: (

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
     :20.0725
       :16.902
   :16.5686
         :16.1814
    :15.8693
      :15.7336
        :15.4897

:14.2366
	:14.1486	rejected
           :14.1074
          :13.9659
 :12.982
  :12.8685
            :12.7415
             :12.423
                :12.3151
               :12.0923
              :11.3295
#:10.4289	rejected
(*:9.71053	prefix accepted:(
let:8.84969

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Function literal
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 case:21.5999
 if:19.6807
 match:18.9155	prefix accepted: ma
 (:18.5472
 let:17.7701
 #:17.5899	prefix accepted: 
 begin:14.8402	prefix accepted: 
 Play:14.7074	prefix accepted: 
 P:14.5828	prefix accepted: 
 ((:14.4457	prefix accepted: (
 ([:14.1284	prefix accepted: (
 get:14.0694
 {:13.9611	prefix accepted: 
 song:13.635
 play:13.6213	prefix accepted: pl
 (*:13.4341	prefix accepted: (
 current:13.3779	prefix accepted: c
 pause:13.1181	prefix accepted: p
 songs:12.8893
 //:12.7539	prefix accepted: 
 #(:12.5643	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action pl update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "pl" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 current:18.3306
 get:14.6284
 songs:13.3124
 play:12.509	prefix accepted: pl
 (:12.4397
 List:11.9142
 is:11.6298
 id:11.4951	prefix accepted: i
 song:11.414
 curr:11.3591
 :11.243
 pause:11.1242	prefix accepted: pa
 pl:12.509
 i:11.4951
(:10.5986
 p:10.2955
 c:10.2169
 Id:10.1136	prefix accepted: 
 Songs:10.068	prefix accepted: S
 state:10.0474	prefix accepted: st
 list:9.97602	prefix accepted: l

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: current
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs action pl update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :18.2409

:17.929
 of:16.0904	prefix accepted: 
  :14.7213
 with:14.2967	prefix accepted: 
   :13.9542
    :13.4641
_:12.7514	rejected
                :12.106
 #:11.9582	prefix accepted: 
::11.9297
 {:11.8853	prefix accepted: 
 =:11.7862	prefix accepted: 
        :11.6483
      :11.474
     :11.4672
          :11.2553
         :11.1522
,:11.0603
 in:10.7937	prefix accepted: 
 ->:10.6804	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:23.0077
 of:15.2872	prefix accepted: 
 #:14.4009	prefix accepted: 
	:14.1545	rejected
 with:13.3744	prefix accepted: 
 |:12.5205
 {:12.2732	prefix accepted: 
 =:11.758	prefix accepted: 
 =>:11.5715	prefix accepted: 
 //:11.2439	prefix accepted: 
 (*:10.9965	prefix accepted: 
0:10.9777	rejected
 ==:10.7991	prefix accepted: 
 ->:10.7656	prefix accepted: 
1:10.7413	rejected
 is:10.6716	prefix accepted: 
 as:10.5386	prefix accepted: 
 in:10.443	prefix accepted: 
 (:10.2562	prefix accepted: 
 ::10.2333
 :::10.2072

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :23.5512
       :21.3573
         :21.0329
        :19.8449
      :19.5184
   :19.2493
    :18.7118
          :18.3611
	:18.2433	rejected
           :18.0616
             :16.4506
                :16.436

:16.4305
            :16.3255
               :16.0549
 :15.32
              :14.9329
  :14.7321
|:13.4483
#:13.2302	rejected
 |:11.2586

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.0564
 #:17.0222	prefix accepted: 
 (*:14.1925	prefix accepted: 
 match:12.8567	prefix accepted: 
 with:12.2321	prefix accepted: 
 ~:12.1752	prefix accepted: 
 ||:11.9035	prefix accepted: |
 *:11.5765	prefix accepted: 
 <:11.4408	prefix accepted: 
 of:11.3653	prefix accepted: 
 when:11.3115	prefix accepted: 
 (:11.1023	prefix accepted: 
 if:11.0444	prefix accepted: 
 {:10.9796	prefix accepted: 
 //:10.9347	prefix accepted: 
 -:10.9195	prefix accepted: 
 P:10.7152	prefix accepted: 
 --:10.6074	prefix accepted: 
 ##:10.5562	prefix accepted: 
 /*:10.3961	prefix accepted: 
 ::10.1502

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Play:17.6283
 No:15.4569
 P:15.2188
Play:12.2151
P:11.9196
 :11.0786
No:10.9716
 _:10.8293
 (:10.7798
 Player:10.2892	prefix accepted: Play
 playing:9.31549
 no:9.07273
 Song:8.63065	prefix accepted: 
 None:8.55975	prefix accepted: No
  :8.55137
 N:8.51199
 Current:8.41751	prefix accepted: 
 Some:8.29394	prefix accepted: 
(:8.18132
	:8.15845	rejected
 NO:8.11341	prefix accepted: N

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ing"
root ::= completions

Top 20 Logits:
ing:22.8474
S:15.6068	rejected
(:13.4587	rejected
List:11.8781	rejected
ed:11.7409	rejected
Sing:11.5876	rejected
list:11.4213	rejected
i:11.3231
ling:11.0317	rejected
State:10.672	rejected
P:10.4862	rejected
in:10.4744
ng:9.93942	rejected
ING:9.87883	rejected
ings:9.81752	prefix accepted:ing
(_:9.77747	rejected
Play:9.64275	rejected
eing:9.57397	rejected
On:9.43736	rejected
sing:9.41718	rejected
 ing:9.40401	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.3586
(_:15.4208	prefix accepted:(
 i:13.4541	prefix accepted: 
 id:12.9761	prefix accepted: 
 song:12.7688	prefix accepted: 
 (:12.5872
 _:11.3385	prefix accepted: 
 x:11.0543	prefix accepted: 
 s:11.0324	prefix accepted: 
 p:10.5949	prefix accepted: 
():10.4006	prefix accepted:(
 =>:10.3617
 current:10.3341	prefix accepted: 
 n:9.9116	prefix accepted: 
 ->:9.76745	prefix accepted: 
((:9.75697	prefix accepted:(
 k:9.65581	prefix accepted: 
 a:9.59977	prefix accepted: 
 :13.4541
 (_:9.43491	prefix accepted: (
 c:9.39198	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
id:16.4007
i:15.6919
current:14.9348
song:14.5563
x:14.2333
play:13.0502
s:12.916
idx:12.8984
curr:12.8012
n:12.5877
cur:12.4153
p:12.4151
Id:12.1243	rejected
index:12.065
a:11.847
pid:11.673
selected:11.524
now:11.1979
k:11.1614
c:10.9991
cid:10.9159

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
_:16.7202
):16.3675
Id:15.9556
id:14.2152
ID:14.0597
s:12.142
1:11.9234
)=:11.56	prefix accepted:)
)->:11.3707	prefix accepted:)
Index:10.7681
),:10.5738	prefix accepted:)
)|:10.2718	prefix accepted:)
_):10.2694	prefix accepted:_
i:9.8132
Play:9.61837
:::9.58457	rejected
 ):9.55745
I:9.43639
idx:9.3826
0:9.1731
name:9.09607

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songId
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):18.2978
),:14.3052	prefix accepted:)
)=:14.1689	prefix accepted:)
x:13.6277
 as:12.537	prefix accepted: 
1:12.4288
 ):11.9581
)->:11.9521	prefix accepted:)
)|:11.5017	prefix accepted:)
)::11.002	prefix accepted:)
'):10.9542	rejected
_):10.715	prefix accepted:_
2:10.6554
n:10.6446
In:10.3481
0:10.2704
_:10.715
d:10.1961
:::10.1608	rejected
To:10.0571
::10.0075	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.2789
 if:13.2205	prefix accepted: 
 :13.2205
 ->:12.7698	prefix accepted: 
 when:12.5733	prefix accepted: 
   :12.1911
 as:11.5739	prefix accepted: 
  :11.5261
    :11.402
 |:10.866	prefix accepted: 

:10.6479
 ||:10.6216	prefix accepted: 
     :10.0799
 :=:9.72824	prefix accepted: 
      :9.68568
        :9.65288
         :9.63846
          :9.35813
	:9.34166	rejected
 or:9.3319	prefix accepted: 
       :9.30059

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:18.1216
 :16.3261

:15.8034
 ([:15.4329	prefix accepted: (
 if:15.0891
 ((:14.8912	prefix accepted: (
 songs:13.8716
  :13.3026
 let:12.7799
(:12.606
   :12.5273
 #:11.9683	prefix accepted: 
    :11.9469
 get:11.8197
 play:11.7047	prefix accepted: pl
 List:11.6404
 [:11.3906
 pl:11.7047
 (*:11.0194	prefix accepted: (
 [(:10.9563	prefix accepted: [
 P:10.8693	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:18.5566
List:12.858
get:12.8172
 songs:12.3044
pl:12.1496
remove:11.9191	rejected
play:11.8749	prefix accepted:pl
list:10.698	prefix accepted:l

:10.312
if:10.2989
let:10.2585
current:10.0516	prefix accepted:c
[]:10.0396
sing:9.95393	prefix accepted:s
p:9.44087
P:9.30426	rejected
Remove:9.22827	rejected
update:9.21631
s:9.95393
lists:8.96176	prefix accepted:l
Play:8.88863	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id" | "s"
root ::= completions

Top 20 Logits:
s:21.6474
Id:14.2232
,:14.0778	rejected
Ids:12.3732	prefix accepted:Id
List:11.7186	rejected
_:11.5368	rejected
es:11.3713	rejected
ss:11.2324	prefix accepted:s
:::10.835	rejected
@:10.7105	rejected
S:9.94692	rejected
 ,:9.92554	rejected
ID:9.90728	prefix accepted:I
sl:9.59565	prefix accepted:s
.:9.51517	rejected
sBy:9.37395	prefix accepted:s
::9.35617	rejected
z:9.23174	rejected
[:9.20937	rejected
sd:9.18283	prefix accepted:s
list:9.10451	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:18.8753
 ,:15.0212
 @:13.6034
@:12.6203
,(:10.9504	prefix accepted:,
 :10.5324
 ::10.3049	prefix accepted: 
,,:9.56987	prefix accepted:,
,[:9.51966	prefix accepted:,
 +:9.47882	prefix accepted: 
::9.44831	rejected
 ++:9.40485	prefix accepted: 
.:9.28939	rejected
 P:9.11517	prefix accepted: 
 :::8.65221	prefix accepted: 
 List:8.56257	prefix accepted: 
 [],:8.4726	prefix accepted: 
[@:8.38281	rejected
):8.34155
[:8.31925	rejected
   :8.22981

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "current" | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 P:18.3016
P:13.507
 (:12.8955
 :12.5374
 No:12.4006
 paused:12.126	prefix accepted: 
 if:11.8402
 current:11.5311
 song:11.3571	prefix accepted: 
 pause:10.994	prefix accepted: 
 Play:10.8813
 new:10.3585	prefix accepted: 
 Some:9.95602	prefix accepted: 
 get:9.74685
 state:9.46403	prefix accepted: 
  :9.45826
 Song:9.31974	prefix accepted: 
 ((:9.28105	prefix accepted: (
   :9.07946
 play:8.98499	prefix accepted: 
 Pa:8.97274

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ausedOn" | "laying"
root ::= completions

Top 20 Logits:
aused:23.6275
ause:15.5854
aus:13.1116
au:12.8563
ased:12.0172	prefix accepted:a
ushed:11.8959	rejected
osed:11.833	rejected
 paused:11.4262	rejected
used:10.7171	rejected
leased:10.0338	prefix accepted:l
P:9.39662	rejected
oused:9.28319	rejected
ained:9.05248	prefix accepted:a
icked:9.03662	rejected
usted:8.93642	rejected
ued:8.85549	rejected
ared:8.8022	prefix accepted:a
ending:8.69485	rejected
auss:8.6729	prefix accepted:aus
p:8.65341	rejected
anned:8.65269	prefix accepted:a

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, Paused

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, Paused
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:22.5615
(:14.3324	rejected
on:13.0438	rejected
S:12.0577	rejected
O:11.6205
 on:11.276	rejected
_:11.1001	rejected
 On:10.9999	rejected
ON:10.9898	prefix accepted:O
 song:10.8255	rejected
In:10.8078	rejected
Of:10.6973	prefix accepted:O
One:10.6214	prefix accepted:On
 (:10.189	rejected
Current:10.152	rejected
):9.94918	rejected
At:9.85601	rejected
State:9.66293	rejected
o:9.45703	rejected
By:9.40539	rejected
song:9.3273	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, Paused
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Id -> PlayListState)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:20.6068
 song:16.5405	prefix accepted: 
 (:14.1052
((:13.0582	prefix accepted:(
()):11.6306	prefix accepted:(
([:11.572	prefix accepted:(
[:11.1311	rejected
({:11.0612	prefix accepted:(
(@:10.7776	prefix accepted:(
):10.6997
(-:10.6994	prefix accepted:(
($:10.6112	prefix accepted:(
(":9.84875	prefix accepted:(
{:9.79307	rejected
(_:9.76107	prefix accepted:(
(*:9.65594	prefix accepted:(
(!:9.64734	prefix accepted:(
song:9.64312	rejected
)(:9.38742	prefix accepted:)
():9.33361	prefix accepted:(
 id:9.28739	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
song:20.2752
current:15.0101	prefix accepted:c
 song:13.6165
id:13.4313	prefix accepted:i
i:13.4313
get:12.7548	rejected
0:12.3018
play:12.2887	rejected
S:11.7749	rejected
s:11.6575
Id:11.3485	rejected
1:11.1995
son:11.118
p:10.9358	rejected
sound:10.8811	prefix accepted:so
P:10.807	rejected
Play:10.7073	rejected
pl:10.5906	rejected
curr:10.5897	prefix accepted:c
sing:10.5624	prefix accepted:s
No:10.4548	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:20.9818
id:14.8111	rejected
)):14.7809	rejected
_:13.4983	rejected
ID:13.4036	prefix accepted:I
s:11.9443	rejected
Name:11.7901	rejected
Ids:11.6825	prefix accepted:Id
Inf:11.4968	prefix accepted:I
Index:11.4822	prefix accepted:I
In:11.4718	prefix accepted:I
 Id:11.1511	rejected
 id:11.0664	rejected
Count:10.9367	rejected
Num:10.9092	rejected
S:10.7348	rejected
i:10.6257	rejected
I:13.4036
))):10.498	rejected
Is:10.4204	prefix accepted:I
):10.3668	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
)):23.2683	prefix accepted:)
));:16.0329	prefix accepted:)
):23.2683
)),:15.5009	prefix accepted:)
))):13.8748	prefix accepted:)
),:13.6394	prefix accepted:)
 :13.4522
)).:12.8762	prefix accepted:)
))::12.8513	prefix accepted:)
 +:12.2408
 ):11.9677
)));:11.6789	prefix accepted:)
))]:11.6095	prefix accepted:)
)))):11.561	prefix accepted:)
);:11.1043	prefix accepted:)
 @:11.0039	prefix accepted: 
 -:10.7535
)){:10.6362	prefix accepted:)
@:10.4476	rejected
))`:10.4018	prefix accepted:)
)(:10.2983	prefix accepted:)
Rejected the highest logit candidate )) with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 ):18.6491

:14.3891
 :14.1848
  :12.4799
   :12.0612
 @:12.0386	prefix accepted: 
 ::11.8962	prefix accepted: 
 as:11.8343	prefix accepted: 
@:11.4581	rejected
    :11.3631
 |:10.8454	prefix accepted: 
 ),:10.8233	prefix accepted: )
 ,:10.6031	prefix accepted: 
 :::10.533	prefix accepted: 
:::10.3705	rejected
 );:10.3454	prefix accepted: )
	:10.284	rejected
                :10.2036
        :10.1856
     :10.1442
       :9.98269

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.4515
 :17.8229
   :16.1745
  :16.1498
    :15.356
 #:14.2745	prefix accepted: 
      :14.0021
       :13.8406
        :13.7939
 (*:13.7443	prefix accepted: 
 end:13.325
     :13.2496
          :13.2062
                :13.0859
         :13.0744
#:12.6503	rejected
            :12.5617
           :12.4727
 |:12.1625
              :12.1167
             :11.9735

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :21.4325
       :17.2509
      :16.4964
   :16.2997
        :16.1511
    :15.7184
                :15.5261
	:15.2973	rejected
         :15.2508
          :15.1547

:14.9211
            :14.4498
           :14.4202
  :14.3763
              :13.8481
 :13.6498
             :13.4657
               :13.4233
#:13.2434	rejected
|:12.239
(*:11.4554	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.9795
 #:18.7947	prefix accepted: 
 end:17.1623
 (*:16.3795	prefix accepted: 
 _:13.8696	prefix accepted: 
 //:13.7882	prefix accepted: 
 else:13.4724	prefix accepted: e
 *:12.8147	prefix accepted: 
 /*:12.6936	prefix accepted: 
 (_:12.6135	prefix accepted: 
 --:12.4923	prefix accepted: 
 ||:12.4269	prefix accepted: |
 ##:12.2405	prefix accepted: 
 (:12.0159	prefix accepted: 
 #(:11.9001	prefix accepted: 
 (**:11.8324	prefix accepted: 

:11.6025
 ~:11.5287	prefix accepted: 
 !:11.4923	prefix accepted: 
 <:11.4891	prefix accepted: 
 case:11.0866	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 _:16.0741
 P:14.8552
 No:14.6466
 x:11.9998
 other:11.7284
 otherwise:11.5309
_:10.3937
 p:10.2141
 state:10.1802
 :10.1582
 s:10.1518
 paused:10.1234
 Play:9.97411
P:9.91057
 others:9.60706
 a:9.48257
 current:9.12488
 rest:8.78052
 e:8.49262
 song:8.48297
 Pa:8.30408

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | No

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | No
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  No
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:20.0635
Selected:12.1526	prefix accepted:S
P:11.3455	rejected
_:11.266	rejected
Sound:11.1676	prefix accepted:So
Play:11.1386	rejected
Selection:11.0541	prefix accepted:S
State:10.9187	prefix accepted:S
Current:10.7845	rejected
Action:10.1917	rejected
Sing:10.017	prefix accepted:S
More:9.5552	rejected
Music:9.43266	rejected
 Song:9.40448	rejected
New:9.39231	rejected
C:9.34564	rejected
Change:9.2555	rejected
SS:9.21946	prefix accepted:S
Se:9.19194	prefix accepted:S
 song:9.18681	rejected
Track:9.00896	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | No
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  NoS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:20.9232
ongs:14.2135	prefix accepted:ong
song:13.2745	rejected
on:12.4074
ng:12.0379	rejected
ung:11.9964	rejected
ug:11.5081	rejected
oon:10.959	prefix accepted:o
oup:10.8931	prefix accepted:o
ou:10.817	prefix accepted:o
om:10.5651	prefix accepted:o
 song:10.4127	rejected
ugg:10.3316	rejected
uch:10.3065	rejected
ongo:10.2209	prefix accepted:ong
n:10.1436	rejected
ig:10.0078	rejected
g:9.94055	rejected
ond:9.76398	prefix accepted:on
son:9.7236	rejected
ang:9.623	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  NoSong
Nature of error: Constructor is not defined  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:21.0318
Select:13.8401
Se:13.3762
Play:13.2258	rejected
selected:13.111	rejected
S:12.7076
Start:11.5537	prefix accepted:S
Selection:11.4406	prefix accepted:Select
To:11.4236	rejected
 =>:11.4022	rejected
P:11.339	rejected
Available:11.1333	rejected
Is:11.1049	rejected
In:10.188	rejected
SELECT:10.1455	prefix accepted:S
Has:10.0723	rejected
 Selected:10.0641	rejected
Selector:9.92057	prefix accepted:Select
Set:9.90987	prefix accepted:Se
Pres:9.63008	rejected
_:9.48278	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.1389
 |:14.0568	prefix accepted: 
 :14.0568
 ||:12.627	prefix accepted: 
  :12.467
=>:12.4563
|:12.2221	rejected
 or:12.065	prefix accepted: 

:11.0034
   :10.7745
 _:10.6244	prefix accepted: 
 ->:10.092	prefix accepted: 
,:9.81427	rejected
    :9.67646
 :=:9.49826	prefix accepted: 
():9.41672	rejected
 =:9.34513
	:8.9917	rejected
 then:8.84365	prefix accepted: 
 ,:8.73098	prefix accepted: 
 end:8.54796	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:17.0637
 pl:15.3654
 :14.3504
 raise:13.3252	prefix accepted: 
 fail:12.8246	prefix accepted: 
  :12.6966
 error:12.0673	prefix accepted: 
 play:11.9826	prefix accepted: pl

:11.482
 ((:11.3992	prefix accepted: (
(:11.1667
 let:11.1553
 if:11.1357
   :10.9295
 no:10.8458	prefix accepted: 
 ([:10.8153	prefix accepted: (
 assert:10.6917	prefix accepted: a
 print:10.3918	prefix accepted: p
 {:10.3406	prefix accepted: 
 throw:10.304	prefix accepted: t
 (-:10.2004	prefix accepted: (

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: pl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: pl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.763
 :17.1014
  :16.714
 #:15.7663	prefix accepted: 
   :14.7884
 (*:14.7785	prefix accepted: 
    :14.3667
 end:13.4192
                :13.377
#:13.1697	rejected
        :13.0725
       :12.9438
      :12.8784
 |:12.6095
            :12.4139
     :12.3768
         :12.2845
          :12.1061
 @:12.0283	prefix accepted: 
              :12.0282
(*:11.7918	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :20.9024
   :16.304
      :15.6497
       :15.6437
    :14.9571
	:14.3154	rejected
        :14.1545

:14.0801
  :14.0261
         :13.6776
 :13.3627
                :13.3186
end:13.1725
          :13.1181
           :13.072
            :12.6606
#:12.4037	rejected
(*:11.6515	rejected
              :11.4792
             :11.4008
|:11.3807

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.2722
 end:18.7717
 #:18.1321	prefix accepted: 
 (*:16.2285	prefix accepted: 
 _:13.8357	prefix accepted: 
 else:13.0996	prefix accepted: e
 (_:12.6809	prefix accepted: 
 //:12.6411	prefix accepted: 
 *:12.374	prefix accepted: 
 ~:12.2276	prefix accepted: 
 /*:12.1794	prefix accepted: 
 ||:12.1647	prefix accepted: |
 (:11.893	prefix accepted: 
 --:11.8584	prefix accepted: 
 (**:11.5311	prefix accepted: 
 #(:11.4322	prefix accepted: 
 ##:11.3025	prefix accepted: 
 End:11.1402	prefix accepted: 
 {:11.0915	prefix accepted: 
 <:11.0354	prefix accepted: 
 -:11.033	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 P:16.5388
 _:15.7617
 x:11.8274
P:11.8011
 paused:11.6442
 other:11.1892
 :10.976
 otherwise:10.8994
_:10.8387
 p:10.2151
 Play:10.0031
 s:9.88708
 song:9.77922
 e:9.44417
 i:9.31628
 pause:9.23369
 a:9.21792
 state:8.99379
 others:8.70176
 :8.46653	rejected
 c:8.38631

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ausedOn" | "laying"
root ::= completions

Top 20 Logits:
aused:21.0485
ause:14.7966
aus:13.1309
au:12.6749
ased:11.4071	prefix accepted:a
ushed:10.7819	rejected
 paused:10.6972	rejected
osed:10.2843	rejected
auss:8.71418	prefix accepted:aus
P:8.66163	rejected
ared:8.46395	prefix accepted:a
used:8.42204	rejected
oused:8.30387	rejected
apsed:7.89117	prefix accepted:a
anned:7.75181	prefix accepted:a
asse:7.74952	prefix accepted:a
ashed:7.72161	prefix accepted:a
leased:7.68865	prefix accepted:l
aux:7.585	prefix accepted:au
lapsed:7.50068	prefix accepted:la
ued:7.4283	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | Paused

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | Paused
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:18.7134
(:13.354	rejected
on:12.5621	rejected
 =>:12.493	rejected
(_:11.633	rejected
O:11.0566
S:10.8049	rejected
 on:10.2764	rejected
In:10.1917	rejected
 ->:10.0509	rejected
():10.0497	rejected
 On:9.9655	rejected
 _:9.80947	rejected
 song:9.58099	rejected
One:9.54708	prefix accepted:On
ON:9.41848	prefix accepted:O
 (:9.32352	rejected
_:9.06626	rejected
o:9.04546	rejected
At:8.91698	rejected
Current:8.62838	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | Paused
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(_:17.7783	prefix accepted:(
(:17.7783
 _:13.2033	prefix accepted: 
 song:11.4946	prefix accepted: 
 (:11.4
():11.2586	prefix accepted:(
 =>:11.0085
 (_:10.918	prefix accepted: (
 id:9.97941	prefix accepted: 
 i:9.65128	prefix accepted: 
(*):9.33017	prefix accepted:(
 s:9.31845	prefix accepted: 
((:9.23933	prefix accepted:(
 ->:9.13155	prefix accepted: 
 :13.2033
(...):8.60196	prefix accepted:(
(":8.45403	prefix accepted:(
 x:8.33092	prefix accepted: 
(*:8.21106	prefix accepted:(
(__:8.17162	prefix accepted:(
([:8.1277	prefix accepted:(
Rejected the highest logit candidate (_ with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
song:16.352
id:14.4065
i:13.3381
x:12.4618
p:12.0995
current:11.9125
s:11.899
play:11.1476
 song:11.0975
a:10.7253
some:10.3372
old:10.2983
..:9.94968	rejected
 _:9.88914
prev:9.78848
Id:9.76977	rejected
 _):9.74252	prefix accepted: _
state:9.59139
S:9.55708	rejected
n:9.49913
curr:9.44297

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
Id:19.665
id:16.6491
ID:15.986
_:15.6974
):15.4313
I:14.0006
i:12.5111
s:12.4536
d:12.4161
Ids:12.2726
Name:11.5843
Index:11.2563
P:11.0606
Play:11.0042
l:10.9517
1:10.9063
_):10.8653	prefix accepted:_
In:10.6555
Is:10.347
)=:10.3282	prefix accepted:)
Int:10.1485

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songId
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):19.1955
)=:14.6184	prefix accepted:)
)->:13.1929	prefix accepted:)
 ):13.0154
1:12.6519
2:12.3311
 as:12.1887	prefix accepted: 
 =>:11.2306	prefix accepted: 
'):11.2096	rejected
_):10.9893	prefix accepted:_
x:10.8679
_:10.9893
P:10.4251
),:10.2139	prefix accepted:)
)':10.2009	prefix accepted:)
)):10.1732	prefix accepted:)
0:9.92813
)|:9.44766	prefix accepted:)
:::9.41859	rejected
r:9.29925
)_:9.28764	prefix accepted:)

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.6322
 ->:14.7549	prefix accepted: 
 :14.7549
 as:11.8121	prefix accepted: 
  :11.6693
   :10.0686
 :=:9.61197	prefix accepted: 

:9.59603
 :::9.52882	prefix accepted: 
 =:9.43631
 ==>:9.25609	prefix accepted: =
:::9.22315	rejected
	:9.02371	rejected
 then:9.02028	prefix accepted: 
 >:8.93886	prefix accepted: 
 if:8.89327	prefix accepted: 
    :8.84259
 when:8.72201	prefix accepted: 
 -->:8.62847	prefix accepted: 
 ||:8.39586	prefix accepted: 
 |:8.38847	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:16.7586
 pl:16.7469
 :14.1359
pl:12.1101
  :11.9138
 if:11.885
(:11.8712
 ((:11.5248	prefix accepted: (

:11.4835
 fail:11.4068	prefix accepted: 
 raise:11.1285	prefix accepted: 
 play:11.106	prefix accepted: pl
 p:10.4813
 error:10.4623	prefix accepted: 
 let:10.1915
 plt:10.1597	prefix accepted: pl
   :9.84142
 print:9.70155	prefix accepted: p
 (*:9.53805	prefix accepted: (
 update:9.51161
 #:9.40969	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: pl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: pl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 end:18.9626

:18.6615
 :17.0189
  :16.9008
      :15.9629
 #:15.5551	prefix accepted: 
   :15.4748
    :15.293
 (*:14.4268	prefix accepted: 
        :14.1835
                :13.9943
       :13.9604
     :13.4414
          :13.3685
            :13.3615
         :13.3539
              :12.8417
#:12.5137	rejected
           :12.5012
	:12.3959	rejected
;:12.3074	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
      :17.7864
     :17.2468
   :15.7848

:15.0078
  :14.759
    :14.7056
        :14.4062
 :14.3241
       :13.6012
          :12.9992
end:12.9981
            :12.9962
                :12.4534
         :12.426
           :11.5473
              :11.3082
in:10.5713	rejected
	:10.5555	rejected
             :10.2909
 end:10.2779
#:9.98359	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:21.5698
 end:19.4173
 #:15.3229	prefix accepted: 
	:14.6631	rejected
 (*:14.0917	prefix accepted: 
 |:13.636
 else:12.759	prefix accepted: e
 *:12.2559	prefix accepted: 
0:11.6118	rejected
 ():11.5907	prefix accepted: 
 //:11.3777	prefix accepted: 
1:11.3557	rejected
 _:11.3222	prefix accepted: 
 ;:11.318	prefix accepted: 
 in:11.145	prefix accepted: 
 if:11.1148	prefix accepted: 
 (:10.8444	prefix accepted: 
 @:10.7512	prefix accepted: 
2:10.7373	rejected
 .:10.7242	prefix accepted: 
 }:10.6626	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :19.8285
  :17.3003
   :15.7063
      :15.6557
    :15.0949
     :15.0228

:14.8379
        :13.2694
|:13.1998
       :12.8124
#:12.6238	rejected
 |:12.5713
let:12.4083	rejected
            :12.3823
end:12.0569
                :11.9678
 #:11.8412	prefix accepted: 
	:11.8198	rejected
          :11.4498
(*:11.3227	rejected
         :10.8497

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.8965
 #:17.9153	prefix accepted: 
 (*:14.6918	prefix accepted: 
 Remove:14.6279	prefix accepted: 
 end:13.9712
 *:12.7894	prefix accepted: 

:12.4671
 //:11.9966	prefix accepted: 
 else:11.8408	prefix accepted: e
 ||:11.8376	prefix accepted: |
 remove:11.6512	prefix accepted: 
 _:11.5007	prefix accepted: 
 --:11.2951	prefix accepted: 
 Play:11.1931	prefix accepted: 
 in:10.9921	prefix accepted: 
 play:10.8077	prefix accepted: 
 /:10.7816	prefix accepted: 
 ##:10.7522	prefix accepted: 
 elif:10.7009	prefix accepted: e
 /*:10.6558	prefix accepted: 
 -:10.619	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Remove:18.0184	prefix accepted: 
 Play:17.8463
 Player:12.3011	prefix accepted: Play
Play:12.2247
 Rem:12.1795	prefix accepted: 
 P:12.1352
 _:11.2322
 :18.0184
Remove:10.4857	rejected
 play:10.403
 Res:10.0042	prefix accepted: 
 Pl:9.984
 remove:9.63992
 Move:9.39596	prefix accepted: 
 Add:9.22498	prefix accepted: 
 Delete:8.96604	prefix accepted: 
 No:8.95571
 Re:8.9034	prefix accepted: 
 Stop:8.88243	prefix accepted: 
 Pick:8.76906	prefix accepted: P
 Next:8.68149	prefix accepted: N
Rejected the highest logit candidate  Remove with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  Play
Nature of error: Constructor is not defined  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ing"
root ::= completions

Top 20 Logits:
S:21.0314	rejected
ing:11.9012
(:11.1912	rejected
Current:11.0512	rejected
 song:10.8201	rejected
_:10.5655	rejected
song:10.3685	rejected
 Song:9.99825	rejected
list:9.94535	rejected
Sound:9.92832	rejected
Next:9.88537	rejected
Sing:9.26617	rejected
P:9.21025	rejected
current:8.80612	rejected
SON:8.73095	rejected
 if:8.62424	rejected
ed:8.55167	rejected
Music:8.51246	rejected
List:8.41045	rejected
Selected:8.35841	rejected
 =>:8.30809	rejected
Rejected the highest logit candidate S with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:14.4973
S:14.0917	rejected
Current:11.4696	rejected
 song:11.0058	prefix accepted: 
 =>:10.6042
(_:10.6006	prefix accepted:(
On:10.0704	rejected
Selected:9.56934	rejected
Next:9.31187	rejected
P:9.27302	rejected
 (:9.19791
Play:9.14276	rejected
_:9.06025	rejected
 ->:9.02299	prefix accepted: 
Of:8.84657	rejected
():8.80022	prefix accepted:(
 Song:8.78462	prefix accepted: 
Now:8.77749	rejected
 _:8.59737	prefix accepted: 
 id:8.53077	prefix accepted: 
At:8.43686	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
id:16.2339
song:16.0046
i:13.1076
play:12.393
new:12.351
current:12.2241
index:11.1617
0:11.1511
x:11.0645
Id:11.0474	rejected
idx:10.94
Play:10.544	rejected
p:10.5265
n:10.4992
s:10.4054
1:10.3631
next:10.2646
 song:10.1016
None:9.93208	rejected
S:9.91866	rejected
curr:9.58289

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):17.0983
)=:13.5552	prefix accepted:)
1:12.6842
_:12.5353
2:11.577
 as:11.2305	prefix accepted: 
)->:11.1532	prefix accepted:)
),:11.0686	prefix accepted:)
Play:10.4924
S:10.4295
 ):10.3048
In:10.2206
'):10.2077	rejected
To:10.1869
::10.1817	rejected
_):10.1015	prefix accepted:_
0:9.93772
Of:9.85634
)):9.78895	prefix accepted:)
,:9.71308	rejected
New:9.41984

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.5224
 :12.6084
 ->:12.3879	prefix accepted: 
 if:12.2197	prefix accepted: 

:11.3696
 when:11.0245	prefix accepted: 
  :10.8853
   :9.66904
 =:9.59089
 |:9.32307	prefix accepted: 
 as:9.27546	prefix accepted: 
=>:9.16321
    :8.97489
 :=:8.95583	prefix accepted: 
 {:8.73996	prefix accepted: 
 #:8.63663	prefix accepted: 
 ==>:8.60053	prefix accepted: =
 ,:8.56782	prefix accepted: 
 ||:8.56218	prefix accepted: 
 ==:8.49428	prefix accepted: =
 &&:8.3564	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 :18.0313

:17.7446
  :16.481
 let:14.9083
 if:14.6293
 (:14.4659
   :14.3636
 pl:14.259
 #:13.9661	prefix accepted: 
    :13.7855
 (*:12.1814	prefix accepted: (
 raise:12.0868	prefix accepted: 
        :12.0607
       :12.0351
     :12.0158
                :12.0116
         :11.9471
 play:11.7158	prefix accepted: pl
 update:11.6592
 fail:11.6315	prefix accepted: 
      :11.5995

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:21.4771
 if:14.6349
 #:14.5914	prefix accepted: 
 (:14.5074
 let:14.3681
 List:13.4441
 pl:13.3762
 (*:13.171	prefix accepted: (
	:13.1547	rejected
 play:12.3436	prefix accepted: pl
 get:12.1652
0:12.1424
 inf:12.0971	prefix accepted: in
 is:11.8146	prefix accepted: i
 ((:11.76	prefix accepted: (
 case:11.6566
 fail:11.5089	prefix accepted: 
1:11.4704
 ():11.1326	prefix accepted: (
 [:10.8643
 id:10.8483

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
     :19.6498
   :18.5478
       :17.3284
    :17.1236
         :15.5941
      :15.4979
  :14.8207
        :14.4936
           :13.8449
 :13.7855
	:13.6432	rejected
          :13.2
             :12.8776

:12.8607
            :12.3439
                :12.1282
               :11.7284
              :11.4414
#:9.47629	rejected
(:8.63058
let:8.35593

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 let:22.4679
 if:18.9847
 #:16.7092	prefix accepted: 
 (:16.6327
 case:16.116
 get:14.042
 pl:13.7775
 ((:13.6751	prefix accepted: (
 (*:13.6007	prefix accepted: (
 match:13.1803	prefix accepted: ma
 play:13.0816	prefix accepted: pl
 fail:12.8908	prefix accepted: 
 print:12.6887	prefix accepted: p
 assert:12.6271	prefix accepted: a
 begin:12.5925	prefix accepted: 
 {:12.2511	prefix accepted: 
 ([:12.2507	prefix accepted: (
 ():12.1387	prefix accepted: (
 update:12.1236
 raise:12.0606	prefix accepted: 
 fun:12.0382	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:19.2419
 song:14.0448
 s:12.3265
 play:11.4795
 all:11.189
 _,:10.961	prefix accepted: _
 new:10.8986
 ids:10.8897
 list:10.7573
 id:10.7228
 (:10.6513
 current:10.6031
 Songs:10.535	prefix accepted: 
 _:10.961
 :10.535
 is:10.1534
 xs:9.82008
 cur:9.73069
 state:9.68067
 ss:9.6547
 l:9.62967

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:18.9519
 =:15.7426
 ,:15.2838
_:12.2868
_,:10.8668	prefix accepted:_
::10.3771
 ::10.0179
 :9.98426
Ids:9.98184
=:9.93246
List:9.73799
.:9.72606	rejected
1:9.60116
 list:9.57375	prefix accepted: 
 in:9.5074	prefix accepted: 
 ids:9.49346	prefix accepted: 
 play:9.46752	prefix accepted: 
 current:9.30316	prefix accepted: 
,,:9.26256	prefix accepted:,
 id:9.21261	prefix accepted: 
 _,:9.19653	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:16.4948
 state:14.8644
 _:13.8345
current:12.4001
 curr:11.7404
 play:11.4551
 song:11.3845
 playing:10.9726
 cur:10.9151
 old:10.4754
 c:10.3809
 :9.95293
 status:9.8665
 previous:9.73994
 p:9.7255
 paused:9.69426
 s:9.66584
 prev:9.5634
 id:9.49213
_:9.41613
 states:9.33251

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: ?, songs: ?, id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:21.2482
_:19.3572
State:15.5356
=:15.4715
 :14.0496
S:12.9565
state:12.3293
Play:11.4757
St:11.022
 ->:10.9486	prefix accepted: 
1:10.8621
Id:10.6142
  :10.5244
Status:10.4163
2:10.1871
 ==:10.0583	prefix accepted: =
P:9.92449
__:9.47496
List:9.42157
::9.39479
 <-:9.3777	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "pl" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 pl:18.9832
 play:14.5654	prefix accepted: pl
pl:13.1578
 :12.9189
 get:11.9038
 p:11.5541
 (:10.8612
 current:10.8351
 plt:10.7964	prefix accepted: pl
 update:10.5639
 action:9.95636
 song:9.95102
 Pl:9.88625
 list:9.87662	prefix accepted: l

:9.45427
 in:9.43659
 Play:9.40278
 f:9.28455
 state:9.2569	prefix accepted: st
 pal:9.18525	prefix accepted: pa
 pr:9.18142	prefix accepted: p

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: pl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: pl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:21.4806
 :14.1693

:13.2251
  :12.3946
in:11.6455
.:11.4234	rejected
   :10.8528
;:10.7286	rejected
,:10.0444
    :9.6904
 and:9.53128	prefix accepted: 
	:8.71295	rejected
 ;:8.63716	prefix accepted: 
 i:8.29991
                :8.2419
     :8.22486
 is:8.16487	prefix accepted: i
::8.16388
      :8.0939
       :7.98647
s:7.97614	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:19.1549
 :16.2266
  :16.0432
   :14.8695
    :14.8433
      :13.5522
       :13.411
        :13.2268
     :13.0667
         :12.4793
          :12.458
                :12.245
            :11.8775
           :11.5658
              :11.1503
	:10.8468	rejected
             :10.7859
               :10.4565
 #:9.91641	prefix accepted: 
 (:9.87735
 case:9.71428

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
     :21.1123
       :18.2891
   :16.7441
    :16.5919
      :16.5513
         :16.0613
        :15.6394
  :14.5492

:14.3523
	:14.262	rejected
           :14.1974
          :14.101
 :13.4431
            :12.9171
                :12.3312
             :12.1446
               :11.6397
              :11.1266
case:10.2696
#:10.1147	rejected
(*:9.79351	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 case:22.804
 if:21.1742
 (:18.3413
 match:17.3182	prefix accepted: ma
 #:17.3001	prefix accepted: 
 let:17.2882
 (*:14.6242	prefix accepted: (
 ((:14.4207	prefix accepted: (
 List:14.1986
 get:13.874
 print:13.8446	prefix accepted: p
 play:13.7399	prefix accepted: pl
 {:13.5563	prefix accepted: 
 song:13.5521
 assert:12.8219	prefix accepted: a
 //:12.7173	prefix accepted: 
 pl:13.7399
 ([:12.5565	prefix accepted: (
 cases:12.4816	prefix accepted: case
 current:12.3928	prefix accepted: c

:12.2947

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs id current songs action pl update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "pl" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 current:18.1312
 List:14.6009
 get:14.3136
 id:14.2612
 contains:12.8765	prefix accepted: co
 songs:12.6629
 (:12.3418
 is:11.8767
 song:11.5116
 curr:11.4358
 :11.3912
 play:11.3279	prefix accepted: pl
 i:11.1031
 find:10.8552	prefix accepted: f
 pl:11.3279
 list:10.2347	prefix accepted: l
 c:9.88319
 Songs:9.85601	prefix accepted: S
(:9.75836
 Id:9.72044	prefix accepted: 
 Song:9.71271	prefix accepted: S

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: current
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs id current songs action pl update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :19.3282

:18.2449
  :16.9355
   :14.3145
 of:13.8292	prefix accepted: 
    :13.6505
_:12.9456	rejected
                :12.0624
       :12.0152
     :12.0035
      :11.9364
        :11.8368
 #:11.7356	prefix accepted: 
 |:11.4146
         :11.3777
          :11.3068
 =:11.0454	prefix accepted: 
::10.6257
            :10.5786
           :10.5515
 {:10.5234	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:23.7255
	:14.5047	rejected
 #:13.1748	prefix accepted: 
 in:12.4882	prefix accepted: 
 of:12.1571	prefix accepted: 
 |:11.9369
 (*:10.9229	prefix accepted: 
 ||:10.5895	prefix accepted: |
 //:10.5261	prefix accepted: 
 ==:10.4772	prefix accepted: 
 =:10.4607	prefix accepted: 
 *:10.4215	prefix accepted: 
 =>:10.3521	prefix accepted: 
 {:10.1602	prefix accepted: 
1:10.0966	rejected
 (:10.0834	prefix accepted: 
 P:10.0497	prefix accepted: 
0:9.96237	rejected
 ?:9.96037	prefix accepted: 
 :9.89603	prefix accepted: 
 ->:9.8677	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :23.4682
       :21.0469
         :18.67
      :18.4103
   :18.1725
    :18.146
        :18.0344
	:16.6416	rejected
          :16.577
           :16.3823
  :15.314

:15.309
                :15.1437
             :15.0325
            :15.024
 :14.601
               :14.3934
              :13.766
|:12.8695
#:12.052	rejected
 |:10.8553

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.2357
 #:15.6433	prefix accepted: 
 (*:11.9711	prefix accepted: 
 *:11.8912	prefix accepted: 
 ||:11.721	prefix accepted: |
 if:11.124	prefix accepted: 
 <:11.1201	prefix accepted: 
 case:10.7404	prefix accepted: 

:10.4784
 (:10.2451	prefix accepted: 
 //:10.1303	prefix accepted: 
 ##:9.95394	prefix accepted: 
 ,:9.86472
 @:9.80758	prefix accepted: 
 /*:9.79305	prefix accepted: 
 |\:9.65056	prefix accepted: |
 ::9.64239
 [:9.5338	prefix accepted: 
 ?:9.43747	prefix accepted: 
 _:9.4333	prefix accepted: 
 !:9.32729	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Play:16.1611
 P:15.3421
 No:15.1201
Play:12.2156
 _:11.9503
P:11.6909
 :10.5864
No:10.356
 Player:9.87193	prefix accepted: Play
 playing:9.40266
 (:9.32681
 Remove:9.1711	prefix accepted: 
 N:8.77299
 Song:8.55486	prefix accepted: 
 no:8.50446
 Add:8.46925	prefix accepted: 
 play:8.38024
 Current:8.30532	prefix accepted: 
_:8.20025
 Next:8.17992	prefix accepted: N
 Not:8.16022	prefix accepted: No

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ing"
root ::= completions

Top 20 Logits:
ing:20.0767
S:15.279	rejected
ed:13.5032	rejected
i:12.2085
in:11.6605
(:11.5769	rejected
Sing:11.2455	rejected
ling:11.0835	rejected
List:10.8785	rejected
P:10.7079	rejected
ng:10.6916	rejected
sing:10.5094	rejected
ig:10.1126	prefix accepted:i
ings:10.1046	prefix accepted:ing
able:10.0369	rejected
list:9.96407	rejected
ign:9.81304	prefix accepted:i
ong:9.56324	rejected
ting:9.36733	rejected
State:9.34217	rejected
ING:9.28492	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:17.9483
(_:17.3102	prefix accepted:(
 song:13.5409	prefix accepted: 
():12.3847	prefix accepted:(
 _:12.2751	prefix accepted: 
 =>:11.6774
 (:11.6689
 (_:10.3438	prefix accepted: (
 ->:10.0754	prefix accepted: 
(*):9.91232	prefix accepted:(
((:9.85044	prefix accepted:(
 i:9.81136	prefix accepted: 
 id:9.75205	prefix accepted: 
 s:9.32839	prefix accepted: 
 :13.5409
 current:8.79715	prefix accepted: 
(*:8.61505	prefix accepted:(
 old:8.38625	prefix accepted: 
([:8.30381	prefix accepted:(
 a:8.28407	prefix accepted: 
 x:8.22537	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
song:16.8481
current:14.4932
i:13.3133
play:13.1461
old:12.9759
prev:12.4786
id:12.397
curr:12.3057
cur:12.1776
s:11.9288
x:11.7964
other:11.7399
p:11.6823
previous:11.4411
some:11.3759
same:11.1837
pre:10.9855
new:10.9139
last:10.7363
another:10.6872
 song:10.6747

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
Id:19.7699
_:16.0873
ID:15.4879
id:14.7689
):14.6557
I:14.372
s:12.8031
Play:12.592
d:12.5556
Ids:12.4858
i:12.4204
In:12.0392
1:11.9399
2:11.5781
P:11.3196
Current:11.2481
l:10.7904
On:10.72
Name:10.6448
play:10.6429
A:10.6105

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songId
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):19.4226
)=:14.2619	prefix accepted:)
),:13.7995	prefix accepted:)
2:13.5653
1:13.1231
'):12.8981	rejected
)->:12.6086	prefix accepted:)
 ):12.3726
_):11.8453	prefix accepted:_
_:11.8453
 as:11.2608	prefix accepted: 
 =>:10.9122	prefix accepted: 
n:10.8398
0:10.8391
)|:10.7061	prefix accepted:)
)::10.702	prefix accepted:)
)':10.581	prefix accepted:)
P:10.3684
)):10.0837	prefix accepted:)
x:9.94116
In:9.92456

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.6637
 if:14.7828	prefix accepted: 
 when:14.3345	prefix accepted: 
 :14.7828
 ->:12.6584	prefix accepted: 
 ||:11.6206	prefix accepted: 

:11.0565
 &&:11.033	prefix accepted: 
 |:10.9684	prefix accepted: 
 as:10.9323	prefix accepted: 
  :10.6628
 or:10.1407	prefix accepted: 
 and:9.96543	prefix accepted: 
 ,:9.61017	prefix accepted: 
   :9.25511
 then:8.96011	prefix accepted: 
 &:8.8643	prefix accepted: 
=>:8.75629
 :=:8.67735	prefix accepted: 
 :::8.64949	prefix accepted: 
 unless:8.58847	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:18.3822
 if:17.1544
 pl:16.2337
 :15.2103
 ((:14.2782	prefix accepted: (

:14.0136
  :13.5396
 play:12.6169	prefix accepted: pl
 #:11.8231	prefix accepted: 
pl:11.6412
 ([:11.5926	prefix accepted: (
(:11.4322
 [:11.3002
   :11.1022
 update:10.9307
 let:10.927
 songs:10.5954
if:10.5113
 p:10.4854
 {:10.4252	prefix accepted: 
 (*:10.3922	prefix accepted: (

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "String.reverse" | "String.starts_with" | "String.transform" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "songId" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 song:16.2566
 id:16.1081
 (:13.7515
 is:13.7243
 List:13.2172
 i:13.1498
 not:12.169	prefix accepted: n
(:10.759
 current:10.6188	prefix accepted: c
 songs:10.4456	prefix accepted: song
 get:10.3548	prefix accepted: 
 String:10.3018
 same:10.2974	prefix accepted: s
 :10.3548
 eq:10.1007	prefix accepted: e
 string:9.99218
 Song:9.9385	prefix accepted: S
 Id:9.85846	prefix accepted: 
 ids:9.61765	prefix accepted: id
 contains:9.59252	prefix accepted: co
 !:9.43177

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Variable song is not bound  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:19.5166
_:16.0368	rejected
ID:13.6026	prefix accepted:I
id:13.3676	rejected
I:13.6026
Is:11.8631	prefix accepted:I
Ids:11.6021	prefix accepted:Id
i:11.4228	rejected
 ==:11.3552	rejected
In:11.2954	prefix accepted:I
 id:11.0818	rejected
 !=:10.8393	rejected
d:10.6275	rejected
(:10.338	rejected
 =:10.1979	rejected
l:9.86578	rejected
.:9.83779	rejected
 is:9.81044	rejected
Inf:9.64589	prefix accepted:I
Exists:9.60389	rejected
Eq:9.53692	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = (Var "Id")})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end in
  LSP: Info: ALL errors:
Error in term:
  songId
Nature of error: Expecting type Bool but got inconsistent type Id  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: == != <= >= < >
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= new-tokens

Top 20 Logits:
 ==:15.7182
 $:14.9213	prefix accepted: 
 =:14.7896
 !=:14.0272
 <>:13.0246	prefix accepted: <
 is:12.6397	prefix accepted: 
 ===:12.2584	prefix accepted: ==
==:11.3214
=:11.2661
 <:13.0246
 >:11.0375
 !==:10.7788	prefix accepted: !=
 +:10.5798
$:10.5565	rejected
 !:10.3833
=$:10.3121	prefix accepted:=
 i:10.0235	prefix accepted: 
 <=:9.93533
 :14.9213
 ~:9.85734	prefix accepted: 
 inf:9.70919	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId ==

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId ==
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: ==
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= completions | new-tokens

Top 20 Logits:
 id:18.393
 i:13.115
 :11.2324
 (:11.0723
 Id:11.0069	prefix accepted: 
id:10.7162
 get:10.7099	prefix accepted: 
 inf:10.4592	prefix accepted: in
 song:10.2778
 is:10.0768	prefix accepted: i
 current:10.0612	prefix accepted: c
 -:9.817
?:9.56259	rejected
 n:9.34383	prefix accepted: 
 songs:9.25695	prefix accepted: song
 play:9.23436	prefix accepted: 
~:9.0434	rejected
 Int:8.97213	prefix accepted: 
#:8.91177	rejected
 infinite:8.85297	prefix accepted: in
 ids:8.83306	prefix accepted: id

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId ==
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: id
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= new-tokens

Top 20 Logits:
 then:19.7005
 :14.2627
 &&:14.2094	prefix accepted: 
 ||:13.381	prefix accepted: 

:12.1525
 (:11.9076	prefix accepted: 
 ((:11.4411	prefix accepted: 
 the:11.3349
  :11.2776
 pl:11.1867	prefix accepted: 
 and:10.093	prefix accepted: 
 ?:9.84723	prefix accepted: 
 Then:9.71605	prefix accepted: 
 (*:9.64301	prefix accepted: 
 or:9.6204	prefix accepted: 
 [:9.5771	prefix accepted: 
 =:9.50626
 {:9.46867	prefix accepted: 
 ,:9.28771	prefix accepted: 
then:9.22637
 than:9.15945	prefix accepted: th

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:17.5127
 pl:17.325
 :14.3899
 play:13.9931	prefix accepted: pl
 ((:13.474	prefix accepted: (

:12.982
 [:12.1606
 current:11.8405	prefix accepted: c
  :11.7031
 ([:11.5047	prefix accepted: (
 {:11.3608	prefix accepted: 
 p:11.3519
 songs:10.732
 [(:10.5927	prefix accepted: [
 plt:10.4084	prefix accepted: pl
 (*:10.3418	prefix accepted: (
 ():10.1398	prefix accepted: (
(:10.0951
 #:10.064	prefix accepted: 
 update:9.76048
 Play:9.61236	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:17.7747
pl:13.5448
 songs:11.9935
play:11.8145	prefix accepted:pl
List:11.2977
current:10.8988	prefix accepted:c
id:10.8855
get:10.6377
list:10.5126	prefix accepted:l
remove:10.4992	rejected
s:10.4734
sing:10.3194	prefix accepted:s
if:9.32926
p:9.25577
[]:9.24868
 song:9.24522
 [:8.96061
ids:8.87496	prefix accepted:id
i:8.83315

:8.62503
plays:8.59772	prefix accepted:pl

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id" | "s"
root ::= completions

Top 20 Logits:
s:22.0889
,:14.135	rejected
List:12.8744	rejected
 ,:11.9052	rejected
Id:11.8316
is:11.5816	rejected
es:11.4049	rejected
ss:11.262	prefix accepted:s
ls:11.2296	rejected
.:11.0809	rejected
[:10.4903	rejected
_:10.2178	rejected
gs:10.1185	rejected
Is:9.92563	prefix accepted:I
si:9.3204	prefix accepted:s
i:9.25636	rejected
x:9.24237	rejected
Ids:9.21646	prefix accepted:Id
@:9.19033	rejected
S:9.15677	rejected
sl:9.00783	prefix accepted:s

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end in
  LSP: Info: ALL errors:
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:19.0171
 ,:16.4932
 @:14.9563
@:12.6144
):10.7087
 +:10.1604	prefix accepted: 
,(:10.14	prefix accepted:,
 :10.1604
 ::9.83148	prefix accepted: 
::9.74306	rejected
,,:9.58255	prefix accepted:,
),:9.54617	prefix accepted:)
.:9.29813	rejected
,[:9.1914	prefix accepted:,
 [:9.13894	prefix accepted: 
[:8.88844	rejected
 current:8.81705	prefix accepted: 
 P:8.79216	prefix accepted: 
 ++:8.72007	prefix accepted: 
;:8.62114	rejected
 List:8.59431	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "current" | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 current:15.7574
 Play:15.1563
 P:15.0002
 No:14.4756
current:12.5905
 playing:11.746	prefix accepted: 
P:11.6088
Play:11.3404
 play:11.0617	prefix accepted: 
 :11.746
No:10.2366
 paused:9.79492	prefix accepted: 
 (:9.75288
 Player:9.72324	prefix accepted: Play
 Current:9.49379	prefix accepted: 
 state:9.4136	prefix accepted: 
 Pl:9.28344
 no:8.86485	prefix accepted: 
 pl:8.61994	prefix accepted: 
 p:8.60421	prefix accepted: 
 curr:8.28859

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: current
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):19.5005
 ):17.9605
_:16.4767	rejected
 @:12.6631	prefix accepted: 
@:11.712	rejected
 :12.6631
_):11.4517	rejected
);:11.3325	prefix accepted:)
),:11.2946	prefix accepted:)
)):10.7627	prefix accepted:)
::10.6427	rejected
  :10.3015
)::10.1829	prefix accepted:)
,:10.1734	rejected
State:10.153	rejected
)(:10.0654	prefix accepted:)
 else:10.0395	prefix accepted: 
()):9.92395	rejected

:9.56443
 +:9.49648	prefix accepted: 
 ::9.40969	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "else"
root ::= new-tokens

Top 20 Logits:
 else:20.6392
 :15.6021

:15.3482
  :14.5508
else:13.2573
 elif:12.7468	prefix accepted: el
   :12.656
 el:12.7468
 els:12.0004
    :11.9724
 #:11.7951	prefix accepted: 
                :10.6846
 (*:10.6379	prefix accepted: 
 @:10.5196	prefix accepted: 
       :10.3703
        :10.3466
     :10.2428
      :10.1466
          :10.1082
 Else:9.8879	prefix accepted: 
         :9.88181

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:17.6897
 pl:15.104
 ((:15.0737	prefix accepted: (
 :14.6575
 play:13.8204	prefix accepted: pl
 update:13.3326

:13.2859
 ([:13.2194	prefix accepted: (
 if:12.7059
  :12.4666
 [(:12.1777	prefix accepted: [
(:11.9566
 fail:11.7073	prefix accepted: 
 [:12.1777
 raise:11.6178	prefix accepted: 
 List:11.4596
 songs:11.283
   :10.9525
 let:10.8073
 get:10.8016
 error:10.3889	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:17.8821
List:13.2414
pl:12.502
 songs:12.0108
remove:11.9693	rejected
play:11.8708	prefix accepted:pl
get:11.3266
current:10.8526	prefix accepted:c
id:10.7983
sing:10.5523	prefix accepted:s
if:10.5194
update:10.3792
list:9.70716	prefix accepted:l
s:10.5523
add:9.43087	prefix accepted:a
 List:9.22998
let:9.22293
filter:9.17927	rejected
Remove:9.13572	rejected
p:9.08802

:8.96971

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id" | "s"
root ::= completions

Top 20 Logits:
s:19.8141
,:13.719	rejected
is:11.0704	rejected
ss:10.3344	prefix accepted:s
_:10.1663	rejected
i:10.064	rejected
List:9.90611	rejected
 ,:9.83617	rejected
[:9.77637	rejected
Id:9.77209
es:9.61565	rejected
.:9.60182	rejected
):9.58118	rejected
d:9.15978	rejected
::9.13857	rejected
,[:9.12823	rejected
 :8.95439	rejected
 -:8.90982	rejected
 i:8.83397	rejected
Is:8.82599	prefix accepted:I
 is:8.76509	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:18.9708
 ,:15.9722
 @:15.2325
@:12.5031
,(:11.3652	prefix accepted:,
,[:10.0378	prefix accepted:,
 :9.86537
 [:9.81507	prefix accepted: 
,,:9.77919	prefix accepted:,
 +:9.66726	prefix accepted: 
.:9.59906	rejected
):9.59069
 P:9.26069	prefix accepted: 
 ::9.17562	prefix accepted: 
[:9.0507	rejected
::8.95871	rejected
[@:8.8579	rejected
 ++:8.75626	prefix accepted: 
 [],:8.75279	prefix accepted: 
),:8.72015	prefix accepted:)
 (:8.51746	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "current" | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 Play:16.1354
 No:15.2623
 current:14.7814
 P:14.4903
Play:12.4608
 playing:12.1728	prefix accepted: 
current:11.2077
 (:11.1702
 :12.1728
P:10.8948
 play:10.824	prefix accepted: 
 Current:10.0006	prefix accepted: 
 Player:9.97054	prefix accepted: Play
No:9.4898
 Pl:9.46348
 get:9.25717
 new:9.10856	prefix accepted: 
 no:8.5466	prefix accepted: 
 if:8.45829
 state:8.31868	prefix accepted: 
 pl:8.16638	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ausedOn" | "laying"
root ::= completions

Top 20 Logits:
aused:19.1471
ause:15.5389
aus:13.7461
LAY:12.8187	rejected
ending:12.0892	rejected
au:11.674
ushed:11.1427	rejected
osed:10.7766	rejected
ased:10.7564	prefix accepted:a
leased:10.7322	prefix accepted:l
lay:10.4449
lain:10.2175	prefix accepted:la
 paused:10.2122	rejected
anned:9.85193	prefix accepted:a
icked:9.75248	rejected
lying:9.75152	prefix accepted:l
Play:9.71354	rejected
asing:9.42781	prefix accepted:a
ued:9.41679	rejected
ained:9.34252	prefix accepted:a
ushing:9.32878	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, Paused

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, Paused
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:19.4972
S:13.823	rejected
(:12.9233	rejected
on:12.7002	rejected
Current:12.6716	rejected
O:11.5468
Off:10.9683	prefix accepted:O
In:10.9166	rejected
ON:10.915	prefix accepted:O
Play:10.715	rejected
):10.683	rejected
_:10.586	rejected
One:10.4887	prefix accepted:On
Of:10.024	prefix accepted:O
By:9.61739	rejected
 on:9.44415	rejected
 On:9.41741	rejected
C:9.39823	rejected
State:9.2377	rejected
No:9.20455	rejected
.:9.11454	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, Paused
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Id -> PlayListState)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:19.5246
 song:13.5577	prefix accepted: 
 (:13.4805
((:12.4038	prefix accepted:(
()):12.2595	prefix accepted:(
 id:12.2191	prefix accepted: 
(-:11.9143	prefix accepted:(
):11.3357
([:10.5952	prefix accepted:(
(@:10.5871	prefix accepted:(
():10.5009	prefix accepted:(
(_:10.4832	prefix accepted:(
[:10.1182	rejected
($:9.94245	prefix accepted:(
(*:9.82834	prefix accepted:(
(":9.46397	prefix accepted:(
 current:9.34976	prefix accepted: 
 i:9.28757	prefix accepted: 
song:9.26394	rejected
(?:9.00786	prefix accepted:(
 ):8.97761

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
song:17.4642
id:17.0208
current:12.2085	prefix accepted:c
i:11.9864
 song:11.2606
0:11.0448
sing:10.5678	prefix accepted:s
Id:10.4174	rejected
S:9.96116	rejected
 id:9.85579
1:9.7971
play:9.57569	rejected
get:9.55566	rejected
s:10.5678
sound:9.27634	prefix accepted:so
if:9.06908
son:8.90884
2:8.83806
p:8.75762	rejected
sent:8.61975	prefix accepted:s
int:8.61684

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:20.1908
_:14.0867	rejected
s:14.0333	rejected
id:13.704	rejected
)):13.6234	rejected
Ids:13.5594	prefix accepted:Id
ID:13.5322	prefix accepted:I
I:13.5322
i:11.778	rejected
):11.5154	rejected
d:11.0473	rejected
.:10.9816	rejected
l:10.4857	rejected
S:10.2465	rejected
 Id:9.92343	rejected
ld:9.89979	rejected
Is:9.79054	prefix accepted:I
In:9.74056	prefix accepted:I
 id:9.41459	rejected
(:9.1441	rejected
ed:9.04951	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
)):20.8468	prefix accepted:)
):20.8468
));:14.4689	prefix accepted:)
)),:13.8975	prefix accepted:)
),:13.6858	prefix accepted:)
 ):12.9286
))):12.661	prefix accepted:)
 :12.5183
)).:12.4764	prefix accepted:)
);:12.4301	prefix accepted:)
))]:11.3053	prefix accepted:)
 @:11.2208	prefix accepted: 
)))):10.9458	prefix accepted:)
))::10.8469	prefix accepted:)
)));:10.8406	prefix accepted:)
))`:10.7965	prefix accepted:)
)){:10.7625	prefix accepted:)
 +:10.6275
@:10.0871	rejected
)]:10.0837	prefix accepted:)
)(:9.65396	prefix accepted:)
Rejected the highest logit candidate )) with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 ):18.9255
 @:16.3239	prefix accepted: 
 :16.3239
@:12.7019	rejected
 );:12.127	prefix accepted: )
  :11.6567
 ,:11.6263	prefix accepted: 
 ;:11.3699	prefix accepted: 
 ),:11.186	prefix accepted: )
 +:10.7821	prefix accepted: 

:10.7636
@@:9.81443	rejected
 (@:9.5795	prefix accepted: 
   :9.53478
 :::9.52815	prefix accepted: 
 |:9.49478	prefix accepted: 
 ::9.17374	prefix accepted: 
 &:9.10838	prefix accepted: 
 &&:9.05286	prefix accepted: 
 <>:9.04478	prefix accepted: 
 ++:9.03502	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.3256
  :17.2509
 :17.0759
   :15.6818
 else:15.1425	prefix accepted: e
    :15.1012
 #:14.4403	prefix accepted: 
 (*:13.7779	prefix accepted: 
 end:13.7745
      :13.539
#:13.4353	rejected
       :12.9259
     :12.9255
        :12.8741
                :12.5644
 @:12.2056	prefix accepted: 
         :12.166
          :12.0789
            :11.9307
	:11.906	rejected
else:11.7546	prefix accepted:e

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :21.2288
      :16.1844
       :16.1524
                :15.4473
    :15.1193
        :15.1169
   :15.0816
         :14.5754
          :14.425

:14.3923
	:14.3293	rejected
           :14.2393
            :14.1962
  :13.7357
              :13.2998
             :13.2212
 :13.1519
               :12.6588
|:12.0894
(*:11.2353	rejected
#:10.8801	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.8321
 #:17.1139	prefix accepted: 
 else:16.1426	prefix accepted: e
 end:15.1485
 (*:14.8054	prefix accepted: 
 elif:13.3933	prefix accepted: e
 if:13.3676	prefix accepted: 

:13.3626
 //:13.2118	prefix accepted: 
 (:12.7922	prefix accepted: 
 case:12.4179	prefix accepted: 
 _:12.3283	prefix accepted: 
 --:11.9912	prefix accepted: 
 ||:11.9448	prefix accepted: |
 (_:11.7	prefix accepted: 
 otherwise:11.5717	prefix accepted: 
 *:11.4864	prefix accepted: 
 /*:11.4575	prefix accepted: 
 P:11.4016	prefix accepted: 
 when:11.3204	prefix accepted: 
 ((:11.3023	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 No:19.5485
 P:16.4149
 _:15.9669
 Play:12.7745
No:11.5371
 N:11.0734
 :11.0385
_:10.7783
 no:10.7449
P:10.35
 paused:9.9753
 Not:9.90388	prefix accepted: No
 None:9.6528	prefix accepted: No
 NO:9.17481	prefix accepted: N
 Pa:9.13384
 Other:8.95518	prefix accepted: 
 Remove:8.91092	prefix accepted: 
 p:8.9068
 (:8.72874
 Player:8.47985	prefix accepted: Play
  :8.3021

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | No

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | No
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  No
Nature of error: Constructor is not defined  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:21.8767
SON:11.8985	prefix accepted:S
Selected:11.8658	prefix accepted:S
 Song:11.3902	rejected
_:11.3373	rejected
Sound:11.108	prefix accepted:So
Play:10.98	rejected
Selection:10.7597	prefix accepted:S
Se:10.6376	prefix accepted:S
Sing:10.4595	prefix accepted:S
P:10.014	rejected
 song:9.98899	rejected
e:9.87853	rejected
So:11.108
Sh:9.53987	prefix accepted:S
SS:9.39877	prefix accepted:S
Current:9.31901	rejected
SO:9.20661	prefix accepted:S
State:9.02994	prefix accepted:S
Session:8.9215	prefix accepted:S
User:8.64072	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | No
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  NoS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:23.9735
ongs:14.1352	prefix accepted:ong
on:13.4818
ony:11.946	prefix accepted:on
ng:11.9287	rejected
ung:11.6555	rejected
ongo:10.8897	prefix accepted:ong
one:10.862	prefix accepted:on
song:10.8374	rejected
oon:10.7251	prefix accepted:o
ons:10.5422	prefix accepted:on
ond:10.4481	prefix accepted:on
ug:10.2653	rejected
og:10.2193	prefix accepted:o
om:10.1968	prefix accepted:o
onic:9.82441	prefix accepted:on
onn:9.75055	prefix accepted:on
ang:9.54922	rejected
now:9.33748	rejected
ame:9.32822	rejected
n:9.30537	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  NoSong
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:23.1331
Select:15.905
Selection:14.3213	prefix accepted:Select
selected:13.8978	rejected
S:13.4174
Se:13.3946
SELECT:12.67	prefix accepted:S
Selector:12.3599	prefix accepted:Select
Rem:11.2823	rejected
SE:11.044	prefix accepted:S
 Selected:10.909	rejected
Current:10.8433	rejected
 selected:10.7382	rejected
Remove:10.6404	rejected
 =>:10.4859	rejected
sel:10.1242	rejected
P:10.0544	rejected
Section:9.97087	prefix accepted:Se
Available:9.92626	rejected
E:9.76369	rejected
ed:9.55166	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:18.8224
=>:13.7716
 :13.7298
 ||:13.0469	prefix accepted: 
 |:12.5864	prefix accepted: 
 ->:12.4153	prefix accepted: 
 if:11.9377	prefix accepted: 
  :11.8186
 or:11.4221	prefix accepted: 
 then:11.2198	prefix accepted: 
 &&:10.7831	prefix accepted: 
 when:10.7722	prefix accepted: 
|:10.5924	rejected

:10.5001
,:10.1137	rejected
   :9.93919
 and:9.85001	prefix accepted: 
	:9.72388	rejected
 ,:9.55257	prefix accepted: 
 &:9.16163	prefix accepted: 
    :9.1314

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:16.9278
 pl:16.0568
 if:15.1662
 :14.5391
 ((:12.714	prefix accepted: (
  :12.6492
 let:12.4462

:12.3232
 play:11.668	prefix accepted: pl
(:11.5063
pl:11.3566
 ([:10.3363	prefix accepted: (
   :10.2871
 p:10.2157
 [:10.1438
 fail:10.1187	prefix accepted: 
 {:10.0847	prefix accepted: 
if:9.99156
 get:9.93288
 plt:9.88793	prefix accepted: pl
 case:9.84148

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:18.7384
pl:13.1493
 songs:12.5879
List:12.5223
play:12.043	prefix accepted:pl
if:11.9004
get:11.6455
sing:11.1575	prefix accepted:s
current:10.7778	prefix accepted:c
remove:10.5679	rejected
list:10.5568	prefix accepted:l
id:10.5176
s:11.1575
[]:10.1366
let:10.0682
 [:9.81962
p:9.36442
No:9.32938	rejected
ids:9.31713	prefix accepted:id
 song:9.17664
 [],:9.13605	prefix accepted: []

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:19.5297
,:13.1067	rejected
S:12.0492	rejected
es:11.0726	rejected
Id:10.7897	rejected
ls:10.3794	rejected
[:10.2296	rejected
Ids:10.2139	rejected
ss:10.1396	prefix accepted:s
os:10.0875	rejected
is:10.068	rejected
Play:9.91892	rejected
_:9.78775	rejected
List:9.69321	rejected
 ,:9.54925	rejected
.:9.39234	rejected
song:9.03572	prefix accepted:s
State:8.9189	rejected
i:8.68016	rejected
sBy:8.67948	prefix accepted:s
us:8.64452	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:19.3533
 ,:16.0029
 @:14.7407
@:12.1323
 [:11.7047	prefix accepted: 
,[:11.1573	prefix accepted:,
[:10.7368	rejected
,,:10.6998	prefix accepted:,
,(:10.5594	prefix accepted:,
 [],:10.4322	prefix accepted: 
 :11.7047
.:10.216	rejected
 P:10.1026	prefix accepted: 
::9.98816	rejected
 ::9.69185	prefix accepted: 
):9.66738
[@:9.6197	rejected
 +:9.5146	prefix accepted: 
 []:9.19352	prefix accepted: 
),:8.97018	prefix accepted:)
 List:8.80552	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "current" | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 Play:15.8445
 current:15.4265
 P:15.2732
 No:14.8534
Play:12.3963
current:12.3302
P:12.0911
 playing:11.8321	prefix accepted: 
 :11.8321
No:10.9159
 play:10.8292	prefix accepted: 
 Current:10.4844	prefix accepted: 
 Player:10.2126	prefix accepted: Play
 (:10.0659
 if:9.62766
 Pl:9.01803
 no:8.98953	prefix accepted: 
  :8.3682
 N:8.36488
 curr:8.32176
 p:8.25339	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  P
Nature of error: Constructor is not defined  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ausedOn" | "laying"
root ::= completions

Top 20 Logits:
aused:20.8538
ause:14.2332
ushed:12.5179	rejected
aus:11.5844
ased:11.2874	prefix accepted:a
LAY:11.1171	rejected
ending:10.9773	rejected
 paused:10.7354	rejected
osed:10.4322	rejected
au:10.4241
ared:10.2249	prefix accepted:a
lapsed:10.1198	prefix accepted:la
leased:10.0701	prefix accepted:l
lain:10.0306	prefix accepted:la
anned:9.73047	prefix accepted:a
ained:9.4397	prefix accepted:a
ended:8.94845	rejected
ued:8.84804	rejected
ashed:8.78693	prefix accepted:a
aved:8.64311	prefix accepted:a
aled:8.57	prefix accepted:a

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, Paused

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, Paused
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:20.1959
on:12.715	rejected
(:12.5161	rejected
S:12.3264	rejected
Off:12.1286	prefix accepted:O
ON:11.8896	prefix accepted:O
O:12.1286
In:11.5119	rejected
Current:11.1825	rejected
):10.7979	rejected
Play:10.6724	rejected
n:10.23	rejected
One:10.1959	prefix accepted:On
Of:10.182	prefix accepted:O
_:10.0629	rejected
 On:9.97329	rejected
No:9.86232	rejected
d:9.7583	rejected
By:9.66879	rejected
From:9.55323	rejected
Out:9.38564	prefix accepted:O

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, Paused
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Id -> PlayListState)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:20.0897
(-:16.0555	prefix accepted:(
()):13.7526	prefix accepted:(
 (:13.5615
((:12.704	prefix accepted:(
):11.9984
([:11.7517	prefix accepted:(
():11.6844	prefix accepted:(
 id:11.633	prefix accepted: 
[:11.4984	rejected
(_:11.1671	prefix accepted:(
(":10.9548	prefix accepted:(
(?:10.8916	prefix accepted:(
(*:10.3138	prefix accepted:(
 (-:10.2719	prefix accepted: (
(@:9.62079	prefix accepted:(
id:9.54062	rejected
($:9.51274	prefix accepted:(
 :11.633
 ):9.43349
(.:9.32981	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
id:18.9189
song:14.7545	prefix accepted:s
0:14.3061
No:12.881	rejected
current:12.8118	prefix accepted:c
i:12.3217
1:11.923
Id:10.9249	rejected
play:10.6243	rejected
if:10.6186
Play:10.3649	rejected
P:10.3642	rejected
 id:10.2037
get:10.1046	rejected
no:9.93556	rejected
2:9.92893
Int:9.89612	rejected
in:9.7812
None:9.74661	rejected
null:9.63495	rejected
Current:9.6314	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: id
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
)):21.1094	prefix accepted:)
):21.1094
)),:13.3932	prefix accepted:)
 :13.1902
));:12.9341	prefix accepted:)
 ):12.5919
))):11.9713	prefix accepted:)
))]:11.6087	prefix accepted:)
))::11.0051	prefix accepted:)
)))):10.9361	prefix accepted:)
)).:10.9296	prefix accepted:)
::10.7416	rejected
),:10.6887	prefix accepted:)
)){:10.4384	prefix accepted:)
 +:10.3394
)));:10.3107	prefix accepted:)
  :10.2769
 -:10.2577
)]:10.0556	prefix accepted:)
);:9.74081	prefix accepted:)
_:9.55611	rejected
Rejected the highest logit candidate )) with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 ):19.4739
 :14.5398
  :13.0919
 );:12.6384	prefix accepted: )

:11.5168
   :11.3183
 if:10.7622	prefix accepted: 
 ),:10.6972	prefix accepted: )
    :10.2332
 @:10.0004	prefix accepted: 
	:9.9447	rejected
 ;:9.68604	prefix accepted: 
 ,:9.48667	prefix accepted: 
      :9.01159
     :8.81925
       :8.58227
 ).:8.56755	prefix accepted: )
                :8.43519
 |:8.39543	prefix accepted: 
 +:8.29474	prefix accepted: 
 ]:8.24303	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.3398
 :16.2174
  :15.9892
      :14.9923
   :14.5118
    :14.1676
 #:13.1011	prefix accepted: 
 (*:12.6246	prefix accepted: 
        :12.6103
       :12.4991
     :12.4897
                :12.2247
            :12.1641
          :11.8986
         :11.4627
	:11.3287	rejected
 end:11.3029
              :11.2341
           :11.1563
 if:11.1039	prefix accepted: 
             :10.6639

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :21.611
      :18.4856
    :15.3085
       :15.2099
   :15.0551
        :14.9054

:14.8767
  :14.5728
 :13.8413
	:13.8134	rejected
          :13.7668
         :13.6295
           :13.625
                :13.6234
            :13.5397
end:12.3054
|:12.3048
              :12.2824
             :11.8135
#:11.3654	rejected
               :10.7931

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:21.7668
 #:16.2794	prefix accepted: 
 end:15.6384
 (*:14.5658	prefix accepted: 
 else:13.4724	prefix accepted: e
 case:13.2796	prefix accepted: 

:13.2084
 if:12.4275	prefix accepted: 
 //:12.0406	prefix accepted: 
 P:12.0212	prefix accepted: 
 --:11.8955	prefix accepted: 
 _:11.662	prefix accepted: 
 *:11.6349	prefix accepted: 
 (:11.2897	prefix accepted: 
 (_:11.0217	prefix accepted: 
 ||:11.0182	prefix accepted: |
 }:11.0139	prefix accepted: 
 -:10.981	prefix accepted: 
 p:10.9427	prefix accepted: 
 elif:10.8904	prefix accepted: e
 current:10.881	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 P:18.237
 _:14.2566
 Play:12.8199
 paused:12.7304
P:11.7878
 Remove:11.0651	prefix accepted: 
 :11.0651
 No:10.8118
_:10.3169
 Pa:10.249
 p:9.5658
 pause:9.24626
 Rem:9.21572	prefix accepted: 
 PA:8.80656	prefix accepted: P
 playing:8.72012
 Add:8.59584	prefix accepted: 
 x:8.46117
 other:8.42945
 play:8.32573
Play:8.211
 Song:8.18741	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ausedOn" | "laying"
root ::= completions

Top 20 Logits:
aused:21.665
ause:17.0566
aus:14.3897
au:13.9469
ased:13.4693	prefix accepted:a
ushed:11.8466	rejected
osed:11.5793	rejected
used:10.8937	rejected
 paused:10.8334	rejected
ared:10.5449	prefix accepted:a
oused:10.4152	rejected
auss:10.3088	prefix accepted:aus
P:9.8523	rejected
added:9.46459	prefix accepted:a
apsed:9.45833	prefix accepted:a
ued:9.38263	rejected
anned:9.28455	prefix accepted:a
aved:9.00326	prefix accepted:a
ained:8.94256	prefix accepted:a
p:8.91528	rejected
lapsed:8.81169	prefix accepted:la

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | Paused

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | Paused
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  Paused
Nature of error: Constructor is not defined  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:20.0587
on:13.3145	rejected
(:13.1438	rejected
O:12.5149
S:11.9854	rejected
ON:11.4635	prefix accepted:O
 On:10.8714	rejected
In:10.8268	rejected
 on:10.7486	rejected
 =>:10.6068	rejected
One:10.4286	prefix accepted:On
_:10.3859	rejected
n:10.0577	rejected
(_:9.95424	rejected
Current:9.90972	rejected
Of:9.76247	prefix accepted:O
o:9.65364	rejected
Off:9.64881	prefix accepted:O
():9.53789	rejected
son:9.48346	rejected
 ->:9.33224	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | Paused
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.5297
(_:17.3216	prefix accepted:(
():13.3239	prefix accepted:(
 (:12.6533
 _:11.7566	prefix accepted: 
((:11.6028	prefix accepted:(
 song:11.404	prefix accepted: 
 =>:10.8248
 (_:10.7105	prefix accepted: (
 :11.7566
(*):9.50238	prefix accepted:(
 ->:9.48188	prefix accepted: 
  :9.1896
(__:8.82472	prefix accepted:(
(-:8.54994	prefix accepted:(
(":8.50078	prefix accepted:(
(*:8.48858	prefix accepted:(
([:8.39934	prefix accepted:(
   :8.38138
 id:8.34641	prefix accepted: 
({:8.25393	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
song:18.5279
p:13.1914
id:13.082
i:12.4024
current:12.3226
play:12.2643
old:11.5568
s:11.4623
P:11.3887	rejected
 song:10.8972
son:10.788
S:10.4663	rejected
prev:10.3039
sing:10.051
previous:9.99448
sound:9.7247
Id:9.67688	rejected
x:9.67259
last:9.63523
curr:9.49623
new:9.48627

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
Id:21.2371
ID:15.1497
id:14.7239
_:14.6613
I:14.5737
):13.7889
d:13.5716
Ids:12.6414
i:12.4184
s:12.3158
P:11.9995
ld:11.604
l:11.5016
If:11.2978
Is:10.8648
p:10.7576
Play:10.7265
In:10.7232
D:10.6189
n:10.4126
t:10.4071

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songId
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):20.4624
)=:14.9988	prefix accepted:)
 ):13.5657
)->:12.9216	prefix accepted:)
 as:12.6633	prefix accepted: 
 =>:12.3683	prefix accepted: 
1:12.0236
2:11.1823
_:10.6972
_):10.6674	prefix accepted:_
)):10.4754	prefix accepted:)
P:10.4423
),:10.333	prefix accepted:)
 =:10.0023	prefix accepted: 
)':9.97007	prefix accepted:)
'):9.77672	rejected
)_:9.70514	prefix accepted:)
r:9.68799
n:9.60389
0:9.28844
)|:9.22086	prefix accepted:)

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:19.749
 :15.1847
 if:13.7429	prefix accepted: 
 ->:12.9611	prefix accepted: 
  :11.2725
 when:10.6958	prefix accepted: 

:10.2935
 =:10.1687
 then:9.99129	prefix accepted: 
 as:9.76056	prefix accepted: 
 >:9.67638	prefix accepted: 
 &&:9.62578	prefix accepted: 
 :=:9.59797	prefix accepted: 
 ==>:9.55908	prefix accepted: =
=>:9.53994
if:9.33172	rejected
   :9.33143
	:9.15223	rejected
 else:9.01635	prefix accepted: 
 !=:8.96636	prefix accepted: 
 |:8.80845	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:17.4243
 if:17.0171
 pl:16.4769
 :16.2859
  :12.5985
if:12.3358

:12.2294
(:12.0732
 ((:11.8289	prefix accepted: (
 let:11.6606
 songs:11.4509
pl:11.0174
 play:10.6169	prefix accepted: pl
 p:10.3317
   :10.1973
 {:9.99005	prefix accepted: 
 print:9.41903	prefix accepted: p
 plt:9.39976	prefix accepted: pl
 case:9.32128
    :9.11317
 [:9.00544

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:19.4751
 songs:14.0542
if:12.8528
List:12.3246
pl:12.2475
sing:11.5046	prefix accepted:s
play:11.293	prefix accepted:pl
current:11.1433	prefix accepted:c
s:11.5046
remove:10.7688	rejected
id:10.3784
list:10.0572	prefix accepted:l
get:9.77255
son:9.67767
P:9.57501	rejected
 if:9.55549
p:9.51718
 song:9.51293
so:9.11415
ids:9.05125	prefix accepted:id
Remove:8.92865	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  song
Nature of error: Variable song is not bound  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id" | "s"
root ::= completions

Top 20 Logits:
s:19.0495
,:12.1331	rejected
Id:11.8023
S:11.6774	rejected
):10.2585	rejected
Ids:10.197	prefix accepted:Id
es:9.91741	rejected
i:9.69842	rejected
is:9.3314	rejected
Inf:8.72618	prefix accepted:I
 =:8.67964	rejected
sBy:8.50133	prefix accepted:s
In:8.3819	prefix accepted:I
ids:8.35394	rejected
 ,:8.26034	rejected
Is:8.18673	prefix accepted:I
ss:7.99087	prefix accepted:s
 :7.98771	rejected
id:7.9847	rejected
.:7.96806	rejected
Info:7.96028	prefix accepted:I

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:19.8692
 ,:15.2246
 @:13.2753
 P:11.1412	prefix accepted: 
@:11.0965
,,:10.7726	prefix accepted:,
,(:10.5305	prefix accepted:,
 :11.1412
.:10.3101	rejected
):9.60752
),:9.5944	prefix accepted:)
 [:9.14318	prefix accepted: 
 Play:8.95707	prefix accepted: 
::8.90015	rejected
P:8.6794	rejected
[:8.67675	rejected
 (:8.53598	prefix accepted: 
,[:8.52621	prefix accepted:,
 +:8.29361	prefix accepted: 
 List:8.23051	prefix accepted: 
 =:8.10127	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "current" | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 Play:17.5512
 P:16.9943
 current:14.093
 No:13.3151
P:13.0922
 :12.5464
 if:12.1548
 playing:12.1075	prefix accepted: 
Play:12.0806
current:11.1732
 Current:10.886	prefix accepted: 
 play:10.5929	prefix accepted: 
 song:10.5881	prefix accepted: 
 Player:10.1861	prefix accepted: Play
 Song:10.1756	prefix accepted: 
 (:10.0451
 paused:9.8729	prefix accepted: 
 p:9.24677	prefix accepted: 
 songs:8.95601	prefix accepted: 
 Pl:8.92798
 played:8.7834	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ausedOn" | "laying"
root ::= completions

Top 20 Logits:
aused:22.0613
ause:14.9147
aus:12.8173
ushed:12.6271	rejected
ased:12.4323	prefix accepted:a
ained:12.0057	prefix accepted:a
LAY:11.5941	rejected
ending:11.4763	rejected
au:11.4327
leased:11.3928	prefix accepted:l
 paused:11.3484	rejected
aled:11.2819	prefix accepted:a
anned:11.007	prefix accepted:a
lapsed:10.97	prefix accepted:la
ared:10.8647	prefix accepted:a
osed:10.1791	rejected
lain:9.86147	prefix accepted:la
alled:9.69522	prefix accepted:a
aved:9.58744	prefix accepted:a
used:9.50272	rejected
ued:9.45721	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, Paused

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, Paused
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:20.727
O:13.292
on:12.7415	rejected
(:12.6955	rejected
ON:12.3687	prefix accepted:O
S:12.2903	rejected
In:11.5885	rejected
Of:11.0437	prefix accepted:O
Off:11.0149	prefix accepted:O
One:10.9032	prefix accepted:On
n:10.8292	rejected
d:10.3773	rejected
Current:10.2968	rejected
_:10.1559	rejected
By:10.0933	rejected
 On:9.94645	rejected
):9.89461	rejected
Out:9.81569	prefix accepted:O
Or:9.55204	prefix accepted:O
From:9.39886	rejected
N:9.38236	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, Paused
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Id -> PlayListState)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:20.6402
 (:13.2588
((:12.712	prefix accepted:(
 song:11.624	prefix accepted: 
():11.58	prefix accepted:(
(-:11.5637	prefix accepted:(
()):11.2147	prefix accepted:(
):10.7593
 id:10.6536	prefix accepted: 
(_:10.2208	prefix accepted:(
([:10.1545	prefix accepted:(
 :11.624
[:9.54481	rejected
song:9.4983	rejected
(":9.43022	prefix accepted:(
 ):9.24125
)(:9.05952	prefix accepted:)
(!:8.91213	prefix accepted:(
(*:8.84793	prefix accepted:(
_:8.64698	rejected
(?:8.58055	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
song:19.0356
id:17.7813
i:13.8253
sing:11.5503	prefix accepted:s
 song:11.535
Id:11.3879	rejected
if:11.2258
current:11.1363	prefix accepted:c
son:10.86
sound:10.6739	prefix accepted:so
ids:10.334	prefix accepted:id
ID:10.1008	rejected
0:10.1007
S:9.92571	rejected
1:9.91524
s:11.5503
is:9.63499	prefix accepted:i
sent:9.63304	prefix accepted:s
sun:9.49321	prefix accepted:s
script:9.36167	prefix accepted:s
idi:9.20015	prefix accepted:id

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:21.2587
I:14.371
ID:13.0634	prefix accepted:I
):12.7633	rejected
)):12.5477	rejected
d:12.467	rejected
_:12.3482	rejected
id:12.3243	rejected
s:11.6905	rejected
i:11.184	rejected
Ids:11.1693	prefix accepted:Id
Is:10.8407	prefix accepted:I
In:10.5031	prefix accepted:I
D:10.4699	rejected
.:10.0892	rejected
l:9.77748	rejected
t:9.71694	rejected
If:9.66577	prefix accepted:I
 Id:9.64458	rejected
P:9.53079	rejected
ld:9.35789	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
):19.8049
)):19.4955	prefix accepted:)
 :13.7596
 ):13.2563
));:12.5512	prefix accepted:)
))):12.4545	prefix accepted:)
)),:12.4052	prefix accepted:)
)))):12.1616	prefix accepted:)
))]:11.9469	prefix accepted:)
 +:11.5853
),:11.2592	prefix accepted:)
)).:11.2008	prefix accepted:)
)));:10.9296	prefix accepted:)
))::10.8716	prefix accepted:)
)){:10.5252	prefix accepted:)
)]:10.4267	prefix accepted:)
))`:10.2562	prefix accepted:)
+:10.2471
  :9.98104
)*:9.95225	prefix accepted:)
 -:9.77983

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 ):18.8463
 :14.3786
 if:11.9286	prefix accepted: 
 @:11.7064	prefix accepted: 
 );:11.6576	prefix accepted: )
  :10.7653

:10.0036
 ),:9.79608	prefix accepted: )
   :9.04594
 ;:8.7976	prefix accepted: 
@:8.7335	rejected
 ,:8.70412	prefix accepted: 
 ){:8.51083	prefix accepted: )
 *):8.45383	prefix accepted: 
 ]:8.43613	prefix accepted: 
 =:8.3362	prefix accepted: 
 |:8.16234	prefix accepted: 
	:8.12166	rejected
 ).:8.08483	prefix accepted: )
 +:7.99264	prefix accepted: 
    :7.9738

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.1182
 :16.6923
  :15.6005
      :15.2896
   :14.4546
    :14.3232
 end:13.4989
        :13.195
       :12.9083
     :12.535
          :12.3758
         :12.0258
                :11.8842
            :11.8196
           :11.2826
              :10.9714
 #:10.951	prefix accepted: 
end:10.6452
	:10.5832	rejected
             :10.3796
 in:10.3505	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
      :20.4728
 :18.1843
  :17.9441

:16.8516
    :16.6455
   :16.1001
        :15.6691
            :15.4722
     :15.438
       :15.3918
                :14.5399
end:14.3217
          :14.2803
         :13.8614
           :13.5829
in:13.5226	rejected
              :12.8332
             :12.7746
	:12.5066	rejected
               :12.0037
#:11.4435	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:22.996
 end:16.4239
 in:15.79	prefix accepted: 
 #:15.1647	prefix accepted: 
 |:15.0589
	:14.7083	rejected
 (*:13.6493	prefix accepted: 
 *:13.6381	prefix accepted: 
 _:12.1748	prefix accepted: 
 case:12.0639	prefix accepted: 
 remove:11.7769	prefix accepted: 
 if:11.5967	prefix accepted: 
 else:11.4555	prefix accepted: e
 -:11.3285	prefix accepted: 
 ||:11.1905	prefix accepted: |
 //:11.0074	prefix accepted: 
 p:10.9871	prefix accepted: 
 (:10.9478	prefix accepted: 
 where:10.8432	prefix accepted: 
0:10.7422	rejected
 P:10.692	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :21.6161
  :17.0843
   :15.5519
      :15.1013
    :14.8046

:14.5147
     :13.9746
end:13.9579
|:13.4991
       :12.752
in:12.7509	rejected
        :12.6149
 |:12.5914
 in:12.4312	prefix accepted: 
 end:12.2802
#:12.0831	rejected
            :11.7099
let:11.6485	rejected
                :11.326
          :11.2499
 #:11.1755	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.43
 #:16.7667	prefix accepted: 
 end:16.5866
 (*:15.3227	prefix accepted: 
 in:13.7017	prefix accepted: 
 //:13.6446	prefix accepted: 
 /*:12.9794	prefix accepted: 
 *:12.3193	prefix accepted: 

:12.0227
 let:11.862	prefix accepted: 
 case:11.6793	prefix accepted: 
 --:11.4082	prefix accepted: 
 _:11.333	prefix accepted: 
 if:11.0357	prefix accepted: 
 fun:10.8214	prefix accepted: 
 @:10.8042	prefix accepted: 
 -:10.7873	prefix accepted: 
 Play:10.7799	prefix accepted: 
 {:10.6649	prefix accepted: 
 (:10.6391	prefix accepted: 
 ~:10.5173	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Remove:18.2688	prefix accepted: 
 Play:15.547
 Rem:14.0191	prefix accepted: 
Remove:12.2953	rejected
 P:12.1936
 _:11.3675
 No:11.2799
 :18.2688
 remove:10.8422
 Song:9.55279	prefix accepted: 
 Add:9.52716	prefix accepted: 
 Re:9.41384	prefix accepted: 
 R:9.34604	prefix accepted: 
Play:9.28733
 Player:9.13577	prefix accepted: Play
 Delete:9.06398	prefix accepted: 
 Res:8.90446	prefix accepted: 
 Next:8.84156	prefix accepted: N
 Get:8.58481	prefix accepted: 
 Stop:8.33798	prefix accepted: 
 Update:7.97847	prefix accepted: 
Rejected the highest logit candidate  Remove with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ing"
root ::= completions

Top 20 Logits:
S:17.5004	rejected
ing:14.7635
list:11.7598	rejected
ed:11.3252	rejected
List:11.24	rejected
(:11.1791	rejected
P:11.1682	rejected
Current:11.0789	rejected
Next:10.7535	rejected
_:9.94954	rejected
 song:9.79185	rejected
Remove:9.50516	rejected
Music:9.43596	rejected
Sound:9.39717	rejected
Now:9.14219	rejected
 Song:9.10604	rejected
song:9.10263	rejected
All:9.09468	rejected
Play:9.02302	rejected
On:8.97641	rejected
i:8.93496
Rejected the highest logit candidate S with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:14.1807
(_:11.4338	prefix accepted:(
S:11.2168	rejected
In:10.5215	rejected
Remove:10.5154	rejected
():10.4273	prefix accepted:(
P:10.3758	rejected
Next:10.1595	rejected
With:10.1014	rejected
_:10.0388	rejected
From:9.99781	rejected
 =>:9.97302
On:9.94346	rejected
Current:9.91051	rejected
Inf:9.76878	rejected
And:9.54821	rejected
No:9.4212	rejected
At:9.27826	rejected
All:9.11199	rejected
After:9.03822	rejected
2:8.93022	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
id:15.936
song:14.1764
i:12.8592
current:11.8657
Play:11.2299	rejected
play:11.2274
0:11.1798
Remove:10.5196	rejected
Id:10.5054	rejected
x:10.3954
P:10.3433	rejected
1:10.1934
No:10.1427	rejected
index:10.1229
new:10.0977
idx:10.0924
remove:10.009
None:9.83901	rejected
p:9.77185
ids:9.59053
s:9.53408

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: id
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):17.474
1:12.9594
)=:12.8357	prefix accepted:)
),:12.1339	prefix accepted:)
2:11.8182
,:11.4573	rejected
_:11.4375
 as:11.1105	prefix accepted: 
)->:11.0846	prefix accepted:)
 ):10.3268
::9.78394	rejected
 =>:9.70351	prefix accepted: 
)|:9.49899	prefix accepted:)
0:9.49818
'):9.47905	rejected
_):9.4336	prefix accepted:_
:::9.39491	rejected
);:9.29697	prefix accepted:)
)):9.29615	prefix accepted:)
In:8.99086
)':8.93202	prefix accepted:)

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:17.4515
 if:12.0433	prefix accepted: 
 :12.0433
 ->:11.8996	prefix accepted: 

:11.4002
 when:11.0989	prefix accepted: 
 as:10.4453	prefix accepted: 
  :10.3205
 =:9.89627
 |:9.738	prefix accepted: 
 +:9.59291	prefix accepted: 
 &&:9.26408	prefix accepted: 
 :=:9.26297	prefix accepted: 
 and:9.21057	prefix accepted: 
   :9.02183
 :::8.96031	prefix accepted: 
 &:8.76561	prefix accepted: 
 >:8.62808	prefix accepted: 
 ||:8.57074	prefix accepted: 
 in:8.57057	prefix accepted: 
 #:8.55384	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 :18.1139
 pl:16.3574

:16.3146
  :15.3159
 (:13.9934
 if:13.7165
 let:13.4526
   :13.1316
 #:12.5827	prefix accepted: 
    :12.5612
 play:12.0442	prefix accepted: pl
 (*:11.7444	prefix accepted: (
 raise:11.4556	prefix accepted: 
 ((:11.2947	prefix accepted: (
 update:11.2075
 fun:11.0783	prefix accepted: 
 case:11.0646
       :11.0422
     :11.039
        :11.0082
                :10.9658

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:21.0221
 pl:15.4468
 (:14.5724
 if:14.0543
 #:13.818	prefix accepted: 
 let:12.9455
 (*:12.9187	prefix accepted: (
 play:12.6048	prefix accepted: pl
	:12.5976	rejected
0:12.3443
1:12.2309
 case:11.8916
 ((:11.6028	prefix accepted: (
 p:11.6006
 ():11.3819	prefix accepted: (
 remove:11.3729	prefix accepted: 
 []:11.052
 id:10.9791
 //:10.8937	prefix accepted: 
 in:10.86
 ?:10.7054	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
     :19.2071
   :17.0167
       :15.2889
    :15.2805
         :13.9789
      :13.9087
  :13.8327
 :13.6571
           :12.5488
        :12.4795

:12.0706
	:12.0206	rejected
             :11.4829
          :11.4788
                :11.4333
let:10.6817
            :10.52
               :10.1215
              :10.0298
 let:8.95955
end:8.93667	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 let:22.5962
 case:16.4866
 if:16.4439
 pl:15.547
 (:15.2789
 get:14.77
 #:14.7432	prefix accepted: 
 fun:12.9419	prefix accepted: 
 play:12.9171	prefix accepted: pl
 (*:12.8318	prefix accepted: (
 match:12.7727	prefix accepted: ma
 ((:12.6942	prefix accepted: (
 ():12.2526	prefix accepted: (
 fail:12.0925	prefix accepted: 
 raise:11.7876	prefix accepted: 
 update:11.571
 print:11.4176	prefix accepted: p
 assert:11.3854	prefix accepted: a
 List:11.3053
 Play:11.2498	prefix accepted: 

:11.1506

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 songs:20.1939
 song:13.9851
 s:11.8167
 current:11.6893
 play:11.3807
 id:11.0419
 _,:10.9966	prefix accepted: _
 Songs:10.8263	prefix accepted: 
 (:10.6197
 pl:10.2167
 _:10.9966
 :10.8263
 ids:10.0147
 list:9.93972
 all:9.8913
 new:9.76661
 remove:9.67482
 state:9.50606
 xs:9.49305
 ss:9.38083
 rec:9.19512

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songs
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | "," | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
,:19.4264
 =:14.9846
 ,:14.1963
 current:11.549	prefix accepted: 
_:10.9587
_,:10.2895	prefix accepted:_
.:10.1752	rejected
::9.81458
 play:9.55771	prefix accepted: 
 ids:9.50539	prefix accepted: 
 id:9.50383	prefix accepted: 
 :11.549
 ::9.25012
 songs:9.15041	prefix accepted: 
=:9.10017
Ids:9.07339
1:9.04448
 pl:9.01839	prefix accepted: 
 state:8.94897	prefix accepted: 
 in:8.88078	prefix accepted: 
,,:8.87479	prefix accepted:,

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Tuple
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: (?, ?)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songs: ?, id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Generating Completions for prefix: ,
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "()" | "Abs" | "AddSong" | "App" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "Trim" | "Var" | "[" | "[]" | "_" | "false" | "true" | floatlit | intlit | patvar | stringlit
root ::= new-tokens

Top 20 Logits:
 current:19.5432
 state:14.6185
 _:12.9975
current:12.5079
 curr:11.4338
 play:11.2249
 playing:11.0627
 id:11.0585
 song:10.9865
 cur:10.2935
 :9.85939
 states:9.82656
 pl:9.80589
 c:9.77023
 paused:9.53107
 status:9.42863
 is:9.17212
 p:9.16429
 P:9.05517
 songs:8.95214
 old:8.93664

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: ?, songs: ?, id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: = in end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: current
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Prod [(Unknown SynSwitch); (Unknown SynSwitch)])
  LSP: Concave: Backpack: =
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: : ::
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] _ false true ~PATVAR~ ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ( [
  LSP: Convex: Lookahead: ( () Abs AddSong App NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse Trim Var [ [] _ false true ~FLOATLIT~ ~INTLIT~ ~PATVAR~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ":" | "::" | "="
root ::= completions | new-tokens

Top 20 Logits:
 =:22.0646
_:17.5917
=:14.8845
State:13.3909
 :13.3703
 ->:12.6037	prefix accepted: 
S:11.5949
 state:11.4146	prefix accepted: 
 ==:11.1484	prefix accepted: =
state:11.111
 -:10.6402	prefix accepted: 
Id:10.4447
1:10.4222
 =>:10.3495	prefix accepted: =
 <-:10.2036	prefix accepted: 
Play:10.0016

:9.98778
  :9.96809
,:9.72343	rejected
2:9.62984
->:9.41861	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current =

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current =
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "pl" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 pl:20.9855
 play:15.0465	prefix accepted: pl
pl:11.9381
 :11.6212
 get:11.4696
 p:11.2491
 action:11.0817
 current:10.981
 update:10.9121
 state:10.4211	prefix accepted: st
 in:10.3376
 song:10.3309
 (:10.2971
 list:10.2146	prefix accepted: l
 plt:10.2138	prefix accepted: pl
 f:9.8252
 Pl:9.60472

:9.57411
 pal:9.55804	prefix accepted: pa
 Play:9.36544
 id:9.26277

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current =
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <pl>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: (?, ?)
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: in end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: (?, ?)
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave or complete: pl
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: ::
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: pl
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: ?, (?, ?)
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
LSP: commas: p_ana is prod: (Unknown SynSwitch) (Unknown SynSwitch)
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: in
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 (?, ?)
? <= (?, ?)
? <= (?, ?)
  LSP: Convex: Target types: ?, (?, ?)
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "in"
root ::= new-tokens

Top 20 Logits:
 in:22.3939
 :12.6133

:11.227
.:11.0036	rejected
 and:10.594	prefix accepted: 
,:10.519
  :10.4373
1:9.83608	rejected
   :9.52751
in:9.32158
;:9.29967	rejected
_:9.29957	rejected
2:8.72988	rejected
    :8.54775
 int:8.48434	prefix accepted: in
 play:8.42019	prefix accepted: 
 at:8.38151	prefix accepted: 
 else:8.33783	prefix accepted: 
(:8.27211	rejected
0:8.22945	rejected
 on:8.16072	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:

:19.0589
 :15.0497
  :14.7189
    :13.7844
   :13.364
      :12.5314
     :11.9687
        :11.7992
       :11.6481
          :11.4406
                :11.2516
            :10.9767
         :10.9354
           :9.99206
              :9.94724
	:9.91574	rejected
 (:9.84899
             :9.32173
 if:9.24244
 #:8.84812	prefix accepted: 
 let:8.81606

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
     :20.7993
       :16.6703
   :15.5549
      :15.1838
    :15.028
         :14.8577
        :14.1972
  :13.5212

:13.4066
           :13.3154
 :13.2021
          :12.9765
	:12.9731	rejected
                :12.0993
            :11.7569
             :11.049
               :10.5626
case:10.5388
end:10.2454	rejected
              :10.2426
(*:9.7567	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <let = in<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 case:22.5653
 if:18.3089
 (:17.2411
 let:15.5809
 #:15.4163	prefix accepted: 
 match:15.4015	prefix accepted: ma
 List:13.9424
 ((:13.3077	prefix accepted: (
 song:12.8279
 (*:12.813	prefix accepted: (
 ():12.8102	prefix accepted: (
 {:12.4403	prefix accepted: 
 get:12.3367
 print:12.3104	prefix accepted: p
 play:12.039	prefix accepted: pl
 pl:12.039
 [:11.8545
 songs:11.7829
 current:11.7224	prefix accepted: c
 cases:11.699	prefix accepted: case
 P:11.5395	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <case end<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs id current songs id current songs action pl update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "()" | "-" | "Abs" | "AddSong" | "App" | "List.cons" | "List.contains" | "List.eq" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.is_empty" | "List.length" | "List.rev" | "List.tl" | "NoSongSelected" | "PauseCurrentSong" | "PausedOn" | "PlaySong" | "Playing" | "RemoveSong" | "Reverse" | "String.reverse" | "String.starts_with" | "String.transform" | "Trim" | "Var" | "[" | "[]" | "abs" | "abs_float" | "acos" | "action" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "current" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "fun " | "get_songs" | "get_state" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "parse_term" | "pi" | "pl" | "sin" | "songs" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "test " | "true" | "type " | "update" | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 current:18.5203
 id:12.9655
 get:12.6213
 List:12.2764
 action:12.1753
 curr:11.7696
 (:11.563
 play:11.5236	prefix accepted: pl
 songs:11.4607
 pl:11.5236
 song:11.2912
 remove:11.0077	prefix accepted: 
 :11.0077
 is:10.0523
 c:9.88884
 contains:9.85005	prefix accepted: co
 i:9.78211
 cur:9.72765
 list:9.57237	prefix accepted: l
current:9.37282
 cu:9.29423

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Generating Completions for prefix: current
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >. + - * / ** +. -. *. /. **. ++ :: @
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. :: < <. <= <=. == ==. > >. >= >=. @ \/
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 ?
  LSP: Convex: Target types: ?
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current songs id current songs id current songs action pl update get_state get_songs List.contains List.filter List.fold_right List.fold_left List.init List.eq List.rev List.is_empty List.tl List.length List.cons parse_term term_to_string String.transform String.reverse String.starts_with string_sub string_concat string_trim string_compare string_length mod atan acos asin tan cos sin sqrt log10 log exp floor ceil abs_float abs bool_of_string float_of_string int_of_string string_of_bool string_of_float string_of_int float_of_int int_of_float is_nan is_infinite is_finite min_int max_int pi epsilon_float nan neg_infinity infinity Playing PausedOn NoSongSelected PlaySong PauseCurrentSong RemoveSong AddSong Var Abs App Reverse Trim () [] false true ~INTLIT~ ~FLOATLIT~ ~STRINGLIT~ ! - ( [ case  fun  if  let  test  type 
  LSP: Convex: Lookahead: ! ( () - Abs AddSong App List.cons List.contains List.eq List.filter List.fold_left List.fold_right List.init List.is_empty List.length List.rev List.tl NoSongSelected PauseCurrentSong PausedOn PlaySong Playing RemoveSong Reverse String.reverse String.starts_with String.transform Trim Var [ [] abs abs_float acos action asin atan bool_of_string case  ceil cos current epsilon_float exp false float_of_int float_of_string floor fun  get_songs get_state id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity parse_term pi pl sin songs sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string test  true type  update ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :19.3941

:16.7233
  :15.3534
 of:13.9914	prefix accepted: 
   :12.6399
    :11.8699
_:11.2117	rejected
 |:11.0941
.:11.0192	rejected
 #:10.9037	prefix accepted: 
     :10.8109
                :10.7312
       :10.5265
,:10.453
 (:10.4386	prefix accepted: 
::10.3739
      :10.288
        :10.1749
 =:10.1662	prefix accepted: 
         :10.0223
 in:9.87699	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:22.665
	:12.9356	rejected
 #:11.959	prefix accepted: 
 (*:10.9768	prefix accepted: 
 if:10.7897	prefix accepted: 
 (:10.628	prefix accepted: 
 Remove:10.5417	prefix accepted: 
 =>:10.5317	prefix accepted: 
 ?:10.26	prefix accepted: 
 remove:10.2058	prefix accepted: 
 //:10.1641	prefix accepted: 
 as:10.0587	prefix accepted: 
 of:10.0444	prefix accepted: 
 *:10.0271	prefix accepted: 
 ->:9.94794	prefix accepted: 
 in:9.75581	prefix accepted: 
 =:9.73983	prefix accepted: 
 |:9.65117
 ==:9.60271	prefix accepted: 
1:9.45549	rejected
 {:9.40665	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :20.7604
       :16.5608
      :15.3729
   :14.9607
    :14.7075
         :14.379
        :14.261
          :13.2224

:13.0753
           :12.8824
	:12.8486	rejected
 :12.7727
  :12.5652
                :12.4389
            :11.913
             :11.4523
               :11.106
              :10.9446
|:10.6485
#:10.4522	rejected
(*:9.42945	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: ?
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: ?
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: ::
  LSP: Concave: Infix: Lookahead types: ?
  LSP: Concave: Infix: Lookahead: ::
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: ::
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "," | "::" | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:19.5394
 #:13.758	prefix accepted: 
 (*:10.9585	prefix accepted: 
 //:10.3553	prefix accepted: 
 *:10.2255	prefix accepted: 
 ||:10.1758	prefix accepted: |

:10.1225
 end:10.0915
 (-:9.84078	prefix accepted: 
 if:9.74446	prefix accepted: 
 /*:9.53517	prefix accepted: 
 id:9.44543	prefix accepted: 
 -:9.27592	prefix accepted: 
 ->:9.20495	prefix accepted: 
 i:9.07297	prefix accepted: 
 !:9.06943	prefix accepted: 
 .:9.05028	prefix accepted: 
 [:8.99596	prefix accepted: 
 +:8.98801	prefix accepted: 
 <:8.78144	prefix accepted: 
 {:8.7765	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 Play:17.5975
 No:14.8339
 P:14.2947
 Remove:12.5444	prefix accepted: 
Play:11.9463
 _:11.5762
 playing:11.1015
 Rem:10.8005	prefix accepted: 
 :12.5444
 Add:9.76637	prefix accepted: 
 Song:9.72921	prefix accepted: 
 Player:9.6784	prefix accepted: Play
 Current:9.48252	prefix accepted: 
 (:9.38799
 play:9.23258
 Pl:8.93486
 #:8.51035	prefix accepted: 
 remove:8.28373
P:8.25194
 N:8.21717
 None:8.14632	prefix accepted: No

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Play

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Play
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Play>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Play"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Play
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Play
LSP: Generating Completions for prefix: Play
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ing"
root ::= completions

Top 20 Logits:
ing:20.8483
S:16.7892	rejected
in:12.6226
ed:12.5164	rejected
i:12.4712
(:12.0041	rejected
ings:11.9675	prefix accepted:ing
ng:11.8347	rejected
P:11.0879	rejected
ling:10.8671	rejected
Sing:10.8434	rejected
ign:10.5765	prefix accepted:i
sing:10.5522	rejected
ong:10.4946	rejected
ig:10.4834	prefix accepted:i
ting:10.3769	rejected
eing:9.9634	rejected
In:9.89458	rejected
On:9.86057	rejected
List:9.73521	rejected
ning:9.71964	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Play
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Playing>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Playing
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: Playing
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: Playing
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:19.5556
(_:15.4082	prefix accepted:(
():13.1149	prefix accepted:(
 song:12.4953	prefix accepted: 
 =>:12.2067
 (:11.2571
 ->:10.6555	prefix accepted: 
((:10.3143	prefix accepted:(
 _:10.2488	prefix accepted: 
 id:10.0544	prefix accepted: 
 :12.4953
S:9.17638	rejected
=>:9.1541
_:8.58799	rejected
(*):8.54534	prefix accepted:(
  :8.51918
   :8.19106
([:8.13988	prefix accepted:(
 i:8.04739	prefix accepted: 
(*:7.95324	prefix accepted:(
 if:7.85539	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
song:19.5234
id:14.1216
i:13.4429
current:12.7864
play:12.5273
s:12.1104
S:11.9083	rejected
 song:11.7774
x:11.1003
son:11.0786
sing:10.7253
0:10.7117
curr:10.5711
ids:10.551
old:10.5439
n:10.532
sound:10.5165
1:10.44
p:10.4275
P:10.3731	rejected
no:10.2372

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
Id:21.4907
_:15.1527
ID:14.5491
id:14.4992
I:13.8887
):13.8743
d:13.0758
Ids:13.0335
s:12.4383
i:11.88
ld:11.6379
l:10.9958
y:10.6744
Play:10.3755
1:10.1752
t:10.0827
Name:10.044
If:9.98089
 id:9.94449	prefix accepted: 
In:9.86842
P:9.8354

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songId
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):20.7726
)=:14.1784	prefix accepted:)
),:13.1177	prefix accepted:)
)->:12.8594	prefix accepted:)
 ):11.9695
1:11.5699
 =>:11.4559	prefix accepted: 
)::10.4554	prefix accepted:)
 as:10.355	prefix accepted: 
_):10.2658	prefix accepted:_
2:9.92177
)):9.82671	prefix accepted:)
)>:9.73118	prefix accepted:)
)|:9.62809	prefix accepted:)
_:10.2658
);:9.49182	prefix accepted:)
,:9.45662	rejected
0:9.40433
 ==:9.33654	prefix accepted: 
)_:9.22975	prefix accepted:)
)*:9.10512	prefix accepted:)

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.0613
 ->:14.4399	prefix accepted: 
 if:13.879	prefix accepted: 
 :14.4399
 when:11.4748	prefix accepted: 
  :11.1108

:10.9666
 &&:10.4976	prefix accepted: 
 ||:10.4722	prefix accepted: 
 then:10.3385	prefix accepted: 
 >:9.84816	prefix accepted: 
   :9.79008
 ==>:9.77468	prefix accepted: =
 |:9.72504	prefix accepted: 
 :=:9.5414	prefix accepted: 
 and:9.53853	prefix accepted: 
 =:9.77468
 or:9.46945	prefix accepted: 
=>:9.32408
 ==:9.27729	prefix accepted: =
    :9.13718

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 if:18.8244
 (:16.5501
 :14.5455
 pl:13.9271

:12.5041
  :12.0482
if:11.393
 ((:11.3913	prefix accepted: (
 id:11.1348
 {:10.7753	prefix accepted: 
(:10.4151
   :10.1358
 songs:10.0872
 play:9.95273	prefix accepted: pl
 p:9.92675
 [:9.49504
 let:9.45849
    :9.4379
 List:9.41178
pl:9.38635
 #:9.28541	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!" | "(" | "-" | "List.contains" | "List.eq" | "List.fold_left" | "List.fold_right" | "List.is_empty" | "List.length" | "String.reverse" | "String.starts_with" | "String.transform" | "abs" | "abs_float" | "acos" | "asin" | "atan" | "bool_of_string" | "case " | "ceil" | "cos" | "epsilon_float" | "exp" | "false" | "float_of_int" | "float_of_string" | "floor" | "id" | "if " | "infinity" | "int_of_float" | "int_of_string" | "is_finite" | "is_infinite" | "is_nan" | "let " | "log" | "log10" | "max_int" | "min_int" | "mod" | "nan" | "neg_infinity" | "pi" | "sin" | "songId" | "sqrt" | "string_compare" | "string_concat" | "string_length" | "string_of_bool" | "string_of_float" | "string_of_int" | "string_sub" | "string_trim" | "tan" | "term_to_string" | "true" | "type " | floatlit | intlit | stringlit
root ::= new-tokens

Top 20 Logits:
 song:20.645
 id:15.457
 List:12.9632
 i:12.8885
 is:12.2554
 not:12.207	prefix accepted: n
 (:12.0395
 songs:11.2508	prefix accepted: song
 current:11.1371	prefix accepted: c
 :10.9371
 Song:10.7386	prefix accepted: S
 ids:10.59	prefix accepted: id
 get:10.5628	prefix accepted: 
 true:10.5497
 s:10.2868
 !:10.1811
 son:10.032
 contains:9.8825	prefix accepted: co
 sid:9.71993	prefix accepted: si
(:9.6658
 remove:9.54712	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:20.2291
_:14.0434	rejected
 ==:13.6672	rejected
I:13.2123
 !=:12.6649	rejected
id:12.6216	rejected
i:11.8751	rejected
ID:11.8664	prefix accepted:I
Is:11.4899	prefix accepted:I
Ids:11.3088	prefix accepted:Id
d:11.108	rejected
In:11.0651	prefix accepted:I
 <:10.7712	rejected
 >:10.6661	rejected
 id:10.62	rejected
.:10.5137	rejected
 >=:10.3942	rejected
 <=:10.3711	rejected
 =:10.1834	rejected
 ===:9.52194	rejected
 <>:9.32862	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: (Exp (Common (Inconsistent Expectation {ana = Bool; syn = (Var "Id")})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songId
Nature of error: Expecting type Bool but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: == != <= >= < >
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= new-tokens

Top 20 Logits:
 ==:21.1042
 !=:16.4602
 =:14.4142
 <>:13.5608	prefix accepted: <
 $:13.19	prefix accepted: 
 <:13.5608
==:13.0453
 is:12.7922	prefix accepted: 
 >:12.5914
 ===:12.312	prefix accepted: ==
 :13.19
 <=:11.5662
 ~:11.448	prefix accepted: 
 !==:11.3497	prefix accepted: !=
 >=:11.3204
 !:11.0546
=:10.6644
 +:10.5589
$:10.3255	rejected
 /:10.1696
 not:10.1695	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId ==

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId ==
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >==<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Integer Equality
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Bool
  LSP: Info: Seft type: Bool
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex or complete: ==
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: ==
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: && \/ $== == != <= >= < > ==. !=. <=. >=. <. >.
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Bool
Int <= Bool
Float <= Bool
String <= Bool
  LSP: Convex: Target types: Int, Float, Bool, String
  LSP: Convex: Backpack: 
  LSP: Convex: Base: false true ! ( case  if  let  type 
  LSP: Convex: Lookahead: ! ( - List.contains List.eq List.fold_left List.fold_right List.is_empty List.length String.reverse String.starts_with String.transform abs abs_float acos asin atan bool_of_string case  ceil cos epsilon_float exp false float_of_int float_of_string floor id if  infinity int_of_float int_of_string is_finite is_infinite is_nan let  log log10 max_int min_int mod nan neg_infinity pi sin songId sqrt string_compare string_concat string_length string_of_bool string_of_float string_of_int string_sub string_trim tan term_to_string true type  ~FLOATLIT~ ~INTLIT~ ~STRINGLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "."
new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= completions | new-tokens

Top 20 Logits:
 id:20.4627
 i:13.1876
id:11.3025
 Id:11.222	prefix accepted: 
 song:11.1861
 :11.222
 current:10.6643	prefix accepted: c
 play:10.3422	prefix accepted: 
 (:9.84406
 ids:9.70121	prefix accepted: id
 -:9.37224
 x:9.35799	prefix accepted: 
 idx:9.09992	prefix accepted: id
 n:8.84169	prefix accepted: 
 ":8.78926	prefix accepted: 
 d:8.76571	prefix accepted: 
 is:8.70223	prefix accepted: i
 sid:8.69349	prefix accepted: s
 s:8.69349
 get:8.65454	prefix accepted: 
 then:8.61838	prefix accepted: t

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId ==
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Int
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: then else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Integer Equality
  LSP: Info: BidiCtx: Expected type: Bool
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != * ** + - / < <= == > >=
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != * ** + - / < <= == > >=
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: id
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Int, Float, Bool, String
  LSP: Concave: Infix: Lookahead: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Backpack: then
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: != !=. $== && * ** **. *. + ++ +. - -. / /. < <. <= <=. == ==. > >. >= >=. \/
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Int
  LSP: Convex: Target types: Int
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "!=" | "*" | "**" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "then"
root ::= new-tokens

Top 20 Logits:
 then:20.5985
 &&:12.8512	prefix accepted: 
 :12.8512
 ||:11.906	prefix accepted: 

:10.4599
 the:10.2148
 =>:9.9678	prefix accepted: =
 pl:9.93675	prefix accepted: 
 (:9.92678	prefix accepted: 
 ((:9.77651	prefix accepted: 
 else:9.61507	prefix accepted: 
  :9.59995
 ?:9.21124	prefix accepted: 
 than:9.09893	prefix accepted: th
 ->:9.09889	prefix accepted: -
 (*:9.05863	prefix accepted: 
 true:9.03606	prefix accepted: t
 {:8.9612	prefix accepted: 
 Then:8.95941	prefix accepted: 
then:8.66245
 ():8.51776	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:18.4413
 pl:14.8404
 :13.2486
 play:12.1476	prefix accepted: pl
 ((:11.8395	prefix accepted: (
 [:11.4871
 current:11.4172	prefix accepted: c

:11.3538
(:10.8834
 songs:10.7673
 ([:10.68	prefix accepted: (
 p:10.6086
 ():10.5748	prefix accepted: (
 {:10.3461	prefix accepted: 
  :10.2369
 if:10.0013
 []:9.99558
 [(:9.95943	prefix accepted: [
 None:9.7323	prefix accepted: 
 true:9.44983	prefix accepted: t
 No:9.36126	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:19.3643
List:14.4488
remove:12.2765	rejected
pl:12.1557
current:12.1354	prefix accepted:c
play:12.0951	prefix accepted:pl
id:11.6567
sing:11.6318	prefix accepted:s
Remove:11.1559	rejected
 songs:10.9626
filter:10.8798	rejected
ids:10.5704	prefix accepted:id
get:10.5473
list:10.5271	prefix accepted:l
delete:10.3403	rejected
s:11.6318
P:9.51235	rejected
true:9.49613	prefix accepted:t
[]:9.37011
Play:9.29657	rejected
S:9.22476	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id" | "s"
root ::= completions

Top 20 Logits:
s:20.4133
S:14.2511	rejected
,:12.2223	rejected
Id:12.1151
Ids:11.0549	prefix accepted:Id
es:10.7765	rejected
):10.4937	rejected
List:10.4574	rejected
.:10.2563	rejected
_:10.2523	rejected
song:9.36666	prefix accepted:s
[:9.13494	rejected
sBy:8.91085	prefix accepted:s
is:8.61145	rejected
ls:8.29492	rejected
os:8.27749	rejected
Is:8.23695	prefix accepted:I
i:8.17132	rejected
In:8.171	prefix accepted:I
Info:8.10878	prefix accepted:I
 +:8.09542	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:19.6058
 @:15.2123
 ,:14.4823
@:11.6291
):9.54148
.:9.49123	rejected
,,:9.38106	prefix accepted:,
 :9.09371
 +:8.8938	prefix accepted: 
[:8.61819	rejected
 -:8.52832	prefix accepted: 
@@:8.44933	prefix accepted:@
 ++:8.31094	prefix accepted: 
::8.27347	rejected
 P:8.16712	prefix accepted: 
 ::8.16358	prefix accepted: 
 \:8.15107	prefix accepted: 
 [:8.12945	prefix accepted: 
[@:8.12129	rejected
:::8.06369	rejected
 \\:8.06156	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "current" | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 current:18.2221
 No:16.016
 P:14.3581
 Play:13.5115
current:13.0736
 playing:11.7046	prefix accepted: 
 Remove:11.4289	prefix accepted: 
 play:11.0181	prefix accepted: 
 Current:10.6721	prefix accepted: 
 Song:10.5069	prefix accepted: 
 id:10.4958	prefix accepted: i
 state:10.4851	prefix accepted: 
 :11.7046
 song:10.2437	prefix accepted: 
 no:10.1105	prefix accepted: 
 Pl:9.97371
 curr:9.85459
 pl:9.60591	prefix accepted: 
 paused:9.48159	prefix accepted: 
 Id:9.22185	prefix accepted: 
 p:9.15504	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <current>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: current
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: current
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
):19.8296
 ):14.3966
_:13.1087	rejected
 @:11.6256	prefix accepted: 
 else:10.9872	prefix accepted: 
)):10.6018	prefix accepted:)
@:10.2415	rejected
)(:10.1539	prefix accepted:)
 :11.6256
),:9.87535	prefix accepted:)

:9.77276
,:9.5133	rejected
_):9.21493	rejected
);:9.21296	prefix accepted:)
).:8.92097	prefix accepted:)
.:8.91089	rejected
 state:8.90177	prefix accepted: 
  :8.87652
 -:8.78944	prefix accepted: 
P:8.36344	rejected
 +:8.30941	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: else end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Parenthesized expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: If expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: else
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "else"
root ::= new-tokens

Top 20 Logits:
 else:21.2488
 :13.508

:13.3469
  :12.0699
else:11.9234
 els:11.6443
 el:10.6538
 end:10.3362	prefix accepted: e
 elif:10.328	prefix accepted: el
 #:10.1931	prefix accepted: 
 (*:10.151	prefix accepted: 
 (:10.026	prefix accepted: 
 otherwise:9.91974	prefix accepted: 
   :9.90024
 pl:9.25047	prefix accepted: 
 P:9.14308	prefix accepted: 
    :9.09184
 if:8.77594	prefix accepted: 
 ((:8.70617	prefix accepted: 
 @:8.57275	prefix accepted: 
 p:8.21638	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <if then else<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:18.7917
 pl:13.8203
 :13.1649
 ((:12.8078	prefix accepted: (
 play:11.8747	prefix accepted: pl
 if:11.6994

:11.6173
 ([:11.4265	prefix accepted: (
(:11.4128
 update:10.9691
 [:10.8859
 ():10.7933	prefix accepted: (
  :10.5451
 remove:10.2736	prefix accepted: 
 songs:10.2004
 [(:10.0397	prefix accepted: [
 p:9.78691
 raise:9.73807	prefix accepted: 
 add:9.61753	prefix accepted: a
 current:9.49646	prefix accepted: c
 {:9.328	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:19.7383
List:13.0474
remove:12.2558	rejected
play:11.8828	prefix accepted:pl
current:11.4808	prefix accepted:c
sing:11.432	prefix accepted:s
 songs:11.4054
pl:11.8828
id:10.7842
Remove:10.6862	rejected
s:11.432
delete:10.0328	rejected
P:9.95726	rejected
ids:9.8333	prefix accepted:id
list:9.75281	prefix accepted:l
get:9.6688
filter:9.45501	rejected
if:9.19632
Play:9.15566	rejected
son:9.15136
[]:9.13391

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id" | "s"
root ::= completions

Top 20 Logits:
s:20.7254
Id:12.7844
,:12.4024	rejected
is:11.5119	rejected
es:11.3063	rejected
ls:10.5737	rejected
Ids:10.4096	prefix accepted:Id
Is:10.2212	prefix accepted:I
i:10.059	rejected
=:9.97639	rejected
ings:9.91748	rejected
ss:9.87493	prefix accepted:s
.:9.77155	rejected
(:9.65112	rejected
ids:9.64236	rejected
_:9.59038	rejected
l:9.38263	rejected
[:9.25656	rejected
song:8.98918	prefix accepted:s
):8.90382	rejected
us:8.83123	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:20.001
 ,:14.7463
 @:14.2706
@:11.4514
 P:10.5635	prefix accepted: 
.:10.3298	rejected
):10.2263
,,:10.1282	prefix accepted:,
 No:10.1221	prefix accepted: 
 :10.5635
::9.21968	rejected
),:9.17691	prefix accepted:)
[:8.91748	rejected
,(:8.8751	prefix accepted:,
 +:8.75261	prefix accepted: 
 [:8.75248	prefix accepted: 

:8.67456
 ::8.58193	prefix accepted: 
 ++:8.54974	prefix accepted: 
P:8.49618	rejected
 Remove:8.44261	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "current" | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 P:17.3052
 No:16.8802
 Play:13.9026
 current:13.1087
 Remove:11.9577	prefix accepted: 
 paused:11.4526	prefix accepted: 
P:11.3385
 Current:11.331	prefix accepted: 
 Song:10.657	prefix accepted: 
 song:10.4681	prefix accepted: 
 :11.9577
 playing:10.3641	prefix accepted: 
 Rem:9.87101	prefix accepted: 
 no:9.58508	prefix accepted: 
 play:9.47746	prefix accepted: 
 (:9.43842
 N:9.34238
 removed:9.28895	prefix accepted: 
Play:9.27169
No:9.21224
 Not:9.10579	prefix accepted: No

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ausedOn" | "laying"
root ::= completions

Top 20 Logits:
aused:21.1923
ause:15.1614
aus:12.5551
ased:12.1234	prefix accepted:a
ained:11.3359	prefix accepted:a
ushed:10.9959	rejected
au:10.7658
ared:10.3102	prefix accepted:a
 paused:10.1672	rejected
ending:10.044	rejected
lapsed:9.94885	prefix accepted:la
lain:9.69001	prefix accepted:la
leased:9.48833	prefix accepted:l
anned:9.44548	prefix accepted:a
rep:9.13548	rejected
osed:8.98675	rejected
ais:8.84307	prefix accepted:a
auss:8.81008	prefix accepted:aus
LAY:8.55986	rejected
aged:8.5579	prefix accepted:a
aved:8.54002	prefix accepted:a

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, Paused

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, Paused
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:20.7354
S:13.8492	rejected
(:13.1859	rejected
O:12.862
on:12.3535	rejected
In:11.8223	rejected
Off:11.7117	prefix accepted:O
Current:11.5767	rejected
ON:11.5246	prefix accepted:O
One:11.3619	prefix accepted:On
):10.9038	rejected
_:10.7659	rejected
():10.753	rejected
n:10.5308	rejected
No:10.4161	rejected
d:10.3621	rejected
()):10.1322	rejected
Of:10.1067	prefix accepted:O
State:10.0188	rejected
 On:10.0097	rejected
Play:9.89856	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, Paused
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Id -> PlayListState)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:20.0768
():11.959	prefix accepted:(
):11.6407
()):11.6202	prefix accepted:(
 (:11.3862
 ):10.5881
 song:10.5192	prefix accepted: 
((:10.1528	prefix accepted:(
 id:9.47068	prefix accepted: 
(_:9.15757	prefix accepted:(
)(:8.75173	prefix accepted:)
[:8.74854	rejected
(-:8.67494	prefix accepted:(
(":8.63014	prefix accepted:(
song:8.62526	rejected
 :10.5192

:8.32305
2:8.24328	rejected
_:8.24213	rejected
([:8.12803	prefix accepted:(
(*:8.10665	prefix accepted:(

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
song:19.8194
id:15.7285
i:13.4442
P:12.7193	rejected
current:12.3198	prefix accepted:c
No:11.7553	rejected
 song:11.2451
0:11.2273
s:11.1901
S:11.0695	rejected
Id:10.7264	rejected
1:10.7006
ids:10.5662	prefix accepted:id
sing:10.5032	prefix accepted:s
p:10.4448	rejected
play:10.3897	rejected
sound:10.3074	prefix accepted:so
is:10.2765	prefix accepted:i
son:10.2371
get:9.77752	rejected
c:12.3198

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:21.6102
I:14.1765
id:13.9049	rejected
i:12.5594	rejected
):12.0969	rejected
D:11.8842	rejected
Is:11.7823	prefix accepted:I
List:11.7164	rejected
In:11.689	prefix accepted:I
Ids:11.6386	prefix accepted:Id
d:11.6155	rejected
_:11.5501	rejected
)):11.4161	rejected
If:11.2677	prefix accepted:I
Ind:10.7711	prefix accepted:I
ID:10.4967	prefix accepted:I
It:10.4584	prefix accepted:I
 Id:10.3709	rejected
.:10.3144	rejected
Int:10.3017	prefix accepted:I
Dir:10.1915	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
):20.0707
)):18.2196	prefix accepted:)
 ):12.1018
));:11.9941	prefix accepted:)
))):11.2327	prefix accepted:)
),:11.2266	prefix accepted:)
 :10.9826
)).:10.7911	prefix accepted:)
)))):10.5582	prefix accepted:)
))]:10.5377	prefix accepted:)
)),:10.4815	prefix accepted:)
))::10.0889	prefix accepted:)
)(:10.0814	prefix accepted:)
)]:10.0537	prefix accepted:)
)));:9.95	prefix accepted:)
);:9.65652	prefix accepted:)
)){:9.52606	prefix accepted:)
).:9.28664	prefix accepted:)

:9.23211
)':9.21538	prefix accepted:)
::9.06024	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 ):19.6212
 :12.777
 );:12.3269	prefix accepted: )
 @:11.1419	prefix accepted: 

:10.9822
  :10.9296
 ),:10.9102	prefix accepted: )
 ;:9.75439	prefix accepted: 
 ).:9.5986	prefix accepted: )
 ,:9.4066	prefix accepted: 
 ::9.29805	prefix accepted: 
   :9.28739
 ]:8.7521	prefix accepted: 
 *):8.52267	prefix accepted: 
    :8.49931
 [:8.44764	prefix accepted: 
 ){:8.38277	prefix accepted: )
 (:8.29131	prefix accepted: 
@:8.24137	rejected
 ^:8.04856	prefix accepted: 
	:8.01133	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.9027
 :14.0007
  :13.7735
   :12.536
    :12.172
 end:11.833
      :11.7591
 else:10.87	prefix accepted: e
        :10.7786
     :10.739
       :10.5943
                :10.011
          :9.91584
 #:9.64378	prefix accepted: 
            :9.59651
else:9.48612	prefix accepted:e
end:9.45657
 (*:9.3685	prefix accepted: 
         :9.28296
	:9.2329	rejected
           :8.99668

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :20.8714
      :14.835
       :13.5573
   :13.523
    :13.456
        :13.0328

:13.0214
  :12.8616
 :12.6127
	:12.4209	rejected
                :12.2864
         :12.1135
          :12.0768
           :11.9231
end:11.7938
            :11.4222
|:11.0958
in:10.7557	rejected
#:10.2153	rejected
              :10.1911
             :9.92843

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:22.1072
 #:15.6804	prefix accepted: 
 end:14.6328
 (*:12.7978	prefix accepted: 

:12.0579
 case:11.5674	prefix accepted: 
 else:11.5496	prefix accepted: e
 //:11.2038	prefix accepted: 
 *:11.0447	prefix accepted: 
 if:10.6919	prefix accepted: 
 --:10.6347	prefix accepted: 
 (:10.5706	prefix accepted: 
 }:10.3786	prefix accepted: 
 ::10.3215	prefix accepted: 
 -:10.291	prefix accepted: 
 ||:10.2414	prefix accepted: |
 /*:10.2197	prefix accepted: 
 _:10.0262	prefix accepted: 
 in:9.99533	prefix accepted: 
 ...:9.97844	prefix accepted: 
 P:9.83206	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 No:20.7601
 P:14.3934
 _:14.0751
 Play:13.1292
 no:10.9951
 N:10.7001
No:10.169
 :10.0492
 None:9.9696	prefix accepted: No
 Remove:9.84543	prefix accepted: 
 Not:9.84347	prefix accepted: No
 NO:9.70885	prefix accepted: N
 Current:9.25046	prefix accepted: 
 (:8.81105
 Song:8.75151	prefix accepted: 
 paused:8.58737
 Add:8.57072	prefix accepted: 
 playing:8.56688
 p:8.4467
 S:8.4451	prefix accepted: 
 Other:8.28132	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | No

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | No
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <No>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "No"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  No
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: No
LSP: Generating Completions for prefix: No
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "SongSelected"
root ::= completions

Top 20 Logits:
S:22.2025
SON:11.4722	prefix accepted:S
 Song:11.2404	rejected
Selected:11.2242	prefix accepted:S
_:11.183	rejected
Play:11.0934	rejected
Sound:10.8909	prefix accepted:So
e:10.0968	rejected
P:9.96998	rejected
SS:9.94544	prefix accepted:S
Sing:9.88972	prefix accepted:S
Se:9.88086	prefix accepted:S
Current:9.88069	rejected
User:9.70972	rejected
Sh:9.41383	prefix accepted:S
So:10.8909
 song:9.3699	rejected
Selection:9.36244	prefix accepted:S
State:8.86731	prefix accepted:S
M:8.84138	rejected
String:8.74715	prefix accepted:S

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoS

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoS
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | No
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoS>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "NoS"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  NoS
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoS
LSP: Generating Completions for prefix: NoS
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ongSelected"
root ::= completions

Top 20 Logits:
ong:22.9768
on:13.7438
ongs:12.9144	prefix accepted:ong
song:11.7705	rejected
n:11.1683	rejected
oon:10.9103	prefix accepted:o
ongo:10.8136	prefix accepted:ong
ond:10.6951	prefix accepted:on
ng:10.2564	rejected
og:10.1087	prefix accepted:o
ony:10.1057	prefix accepted:on
om:10.0387	prefix accepted:o
one:9.8695	prefix accepted:on
onn:9.69631	prefix accepted:on
ogn:9.56455	prefix accepted:o
 song:9.53243	rejected
ou:9.43149	prefix accepted:o
ung:9.37247	rejected
ons:9.29272	prefix accepted:on
ont:9.08831	prefix accepted:on
onic:9.00876	prefix accepted:on

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSong

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSong
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoS
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSong>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "NoSong"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  NoSong
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: NoSong
LSP: Generating Completions for prefix: NoSong
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Selected"
root ::= completions

Top 20 Logits:
Selected:23.5579
Select:16.0723
Selection:13.4852	prefix accepted:Select
selected:13.4237	rejected
Se:12.9939
S:12.9531
SELECT:12.6439	prefix accepted:S
Rem:12.356	rejected
Selector:12.2641	prefix accepted:Select
Current:11.1265	rejected
 =>:10.713	rejected
 Selected:10.5711	rejected
Remove:10.5624	rejected
 selected:10.5559	rejected
ed:10.5554	rejected
sel:10.4503	rejected
SE:10.3977	prefix accepted:S
P:10.1754	rejected
E:10.0451	rejected
Play:9.88955	rejected
T:9.80914	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSong
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <NoSongSelected>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: NoSongSelected
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: NoSongSelected
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:20.0112
=>:13.1198
 ->:12.699	prefix accepted: 
 :12.699
  :10.4722
 ||:10.4062	prefix accepted: 
 if:10.3486	prefix accepted: 
 then:10.309	prefix accepted: 
 |:10.1446	prefix accepted: 

:9.78858
 or:9.63472	prefix accepted: 
 =:9.59712
 >:9.16738	prefix accepted: 
,:9.113	rejected
   :9.0373
_:9.03492	rejected
 &&:8.98294	prefix accepted: 
(:8.95288	rejected
	:8.88297	rejected
P:8.66644	rejected
 and:8.55686	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:18.087
 pl:14.3071
 :13.2269
 if:12.1394
 play:11.5714	prefix accepted: pl
(:10.881

:10.5985
 ((:10.5687	prefix accepted: (
 p:10.477
  :10.3241
 let:9.80665
pl:9.49104
 [:9.46668
 raise:9.4487	prefix accepted: 
 fail:9.23342	prefix accepted: 
 {:9.20358	prefix accepted: 
 ():9.10253	prefix accepted: (
 update:9.04338
 return:8.8959	prefix accepted: 
 ([:8.80065	prefix accepted: (
 throw:8.6297	prefix accepted: t

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:19.8041
play:12.2615	prefix accepted:pl
pl:12.2615
List:11.7781
 songs:11.4829
sing:11.341	prefix accepted:s
current:11.2679	prefix accepted:c
id:10.8139
s:11.341
ids:10.3555	prefix accepted:id
list:10.2904	prefix accepted:l
get:9.99655
remove:9.78467	rejected
[]:9.53214
add:9.48719	prefix accepted:a
No:9.448	rejected
P:9.35742	rejected
p:9.18324
son:9.14486
true:9.0548	prefix accepted:t
Play:9.02084	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "s"
root ::= completions

Top 20 Logits:
s:19.9307
,:12.683	rejected
Id:11.5448	rejected
S:11.4168	rejected
us:11.1798	rejected
es:11.1596	rejected
is:11.0634	rejected
ls:10.8223	rejected
as:9.96545	rejected
Ids:9.9457	rejected
ids:9.63258	rejected
Is:9.50543	rejected
als:9.37042	rejected
.:9.18991	rejected
os:9.12261	rejected
ss:8.99658	prefix accepted:s
):8.97402	rejected
ns:8.92625	rejected
List:8.87987	rejected
i:8.77826	rejected
ps:8.74749	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:20.1737
 ,:14.0603
 @:12.9358
@:10.9149
.:10.1382	rejected
,,:10.1006	prefix accepted:,
 P:9.90675	prefix accepted: 
 [:9.7224	prefix accepted: 
):9.43544
[:9.32634	rejected
,[:9.30839	prefix accepted:,
 :9.90675
::9.14964	rejected
),:9.06445	prefix accepted:)
P:8.9974	rejected
 [],:8.97124	prefix accepted: 
,(:8.38692	prefix accepted:,
 Play:8.33465	prefix accepted: 
 +:8.26299	prefix accepted: 
[@:8.21821	rejected
 ::8.18254	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "current" | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 P:18.0839
 No:15.031
 Play:14.5455
 current:14.004
P:12.2058
 Current:12.0804	prefix accepted: 
 paused:11.3345	prefix accepted: 
 playing:11.1651	prefix accepted: 
 :12.0804
 Song:10.1029	prefix accepted: 
Play:10.0343
current:10.0184
 song:10.0089	prefix accepted: 
 play:9.9911	prefix accepted: 
 Player:9.16653	prefix accepted: Play
No:9.09708
 (:8.96125
 no:8.93802	prefix accepted: 
 N:8.88948
 Songs:8.83377	prefix accepted: 
 Id:8.7899	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ausedOn" | "laying"
root ::= completions

Top 20 Logits:
aused:23.0454
ause:15.6013
ased:13.2588	prefix accepted:a
aus:12.6857
ushed:12.517	rejected
 paused:12.1856	rejected
au:12.1345
ained:11.7871	prefix accepted:a
osed:11.425	rejected
ending:11.292	rejected
ared:11.2601	prefix accepted:a
lapsed:10.8769	prefix accepted:la
anned:10.7043	prefix accepted:a
aved:10.6903	prefix accepted:a
leased:10.3202	prefix accepted:l
ended:10.2795	rejected
used:10.1128	rejected
auss:9.98951	prefix accepted:aus
anced:9.88282	prefix accepted:a
oused:9.80532	rejected
aled:9.61343	prefix accepted:a

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, Paused

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, Paused
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:21.626
O:13.6646
(:12.895	rejected
S:12.6162	rejected
In:12.3723	rejected
ON:12.355	prefix accepted:O
on:12.3091	rejected
Off:11.996	prefix accepted:O
One:11.6941	prefix accepted:On
Of:11.581	prefix accepted:O
n:11.2071	rejected
No:10.6033	rejected
Out:10.5627	prefix accepted:O
):10.4064	rejected
 On:10.3393	rejected
_:10.3166	rejected
P:10.2578	rejected
Not:10.2331	rejected
Only:10.2224	prefix accepted:On
d:10.2119	rejected
From:10.1564	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, Paused
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)  
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Id -> PlayListState)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:20.7061
():12.2579	prefix accepted:(
 (:11.6833
()):11.6032	prefix accepted:(
):11.198
(-:10.6707	prefix accepted:(
((:10.5207	prefix accepted:(
(":10.1845	prefix accepted:(
(_:10.0079	prefix accepted:(
[:9.81517	rejected
 song:9.69958	prefix accepted: 
 id:9.68804	prefix accepted: 
 ):9.64965
([:9.18956	prefix accepted:(
)(:9.10522	prefix accepted:)
id:8.94529	rejected
(*:8.83823	prefix accepted:(
No:8.60141	rejected
song:8.42677	rejected
(?:8.34888	prefix accepted:(
n:8.2573	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
id:21.6675
song:15.5689	prefix accepted:s
i:12.884
current:12.691	prefix accepted:c
P:11.9707	rejected
Id:11.6064	rejected
No:11.5265	rejected
ids:11.3599	prefix accepted:id
play:11.2396	rejected
0:11.2271
Play:11.1274	rejected
1:10.7877
 id:10.3887
is:10.0776	prefix accepted:i
Current:9.97488	rejected
if:9.9251
s:15.5689
idi:9.64328	prefix accepted:id
p:9.61055	rejected
S:9.4788	rejected
2:9.15125

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <id>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: id
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: id
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: id id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
):19.9692
)):17.3459	prefix accepted:)
 ):11.523
::11.1019	rejected
));:10.646	prefix accepted:)
)),:10.6045	prefix accepted:)
),:10.5242	prefix accepted:)
))::10.4233	prefix accepted:)
))):10.3895	prefix accepted:)
 :10.2027
))]:10.0852	prefix accepted:)
)))):9.85514	prefix accepted:)
)).:9.641	prefix accepted:)
,:9.579	rejected
)]:9.35005	prefix accepted:)
)(:9.31786	prefix accepted:)
)){:9.27148	prefix accepted:)
)));:9.24989	prefix accepted:)
 +:9.19917
1:8.94999	rejected
]:8.78286	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 ):20.4191
 :13.2065
 );:11.7551	prefix accepted: )
 ),:11.2018	prefix accepted: )
  :11.1844

:10.9565
 ,:10.2307	prefix accepted: 
 @:10.1255	prefix accepted: 
 ;:9.59632	prefix accepted: 
 ::9.55829	prefix accepted: 
 ).:9.44076	prefix accepted: )
 ]:9.42539	prefix accepted: 
   :9.21505
    :8.70933
 *):8.49251	prefix accepted: 
 }:8.40442	prefix accepted: 
 ^:8.26284	prefix accepted: 
 +:8.20477	prefix accepted: 
 |:8.1583	prefix accepted: 
 ){:8.13564	prefix accepted: )
 -:8.08908	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.1272
 :13.5548
  :13.2937
      :12.6211
   :11.9248
    :11.5457
 end:10.6642
     :10.4027
        :10.1352
       :9.89222
 #:9.87891	prefix accepted: 
                :9.51972
          :9.45308
end:9.24415
            :9.2187
         :8.83992
	:8.75882	rejected
 (*:8.65688	prefix accepted: 
              :8.60019
           :8.58875
 *:8.5714	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
     :21.1414
      :16.3329
    :13.8925
   :13.85
 :13.2504
  :13.1736

:13.0763
       :12.9036
        :12.418
	:12.3074	rejected
end:12.2437
           :11.6065
                :11.5305
          :11.4226
|:11.4085
         :11.3547
            :11.0079
#:10.4082	rejected
in:10.3978	rejected
 end:9.85175
 |:9.68368

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
     

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
     
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:20.8361
 end:13.4423
 #:13.133	prefix accepted: 
 eq:11.2851	prefix accepted: e
 in:10.7515	prefix accepted: 

:10.1667
 *:9.72256	prefix accepted: 
 .:9.6594	prefix accepted: 
 (:9.46204	prefix accepted: 
 _:9.23365	prefix accepted: 
 (*:9.19594	prefix accepted: 
 `:9.15072	prefix accepted: 
 ::9.12749	prefix accepted: 
 else:9.10067	prefix accepted: e
 [:8.87243	prefix accepted: 
 -:8.79093	prefix accepted: 
 /:8.75344	prefix accepted: 
|:8.66017
 Eq:8.57597	prefix accepted: 
 ,:8.55124	prefix accepted: 
 //:8.52948	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      |

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      |
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
     
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "NoSongSelected" | "PausedOn" | "Playing" | "_" | patvar
root ::= new-tokens

Top 20 Logits:
 P:19.0131
 Play:12.4547
 _:12.4294
 paused:11.854
 Remove:11.3499	prefix accepted: 
 No:10.7669
 Pa:10.2927
 Rem:10.2439	prefix accepted: 
P:10.1171
 :11.3499
 PA:8.97852	prefix accepted: P
 p:8.47809
 pause:8.42199
 Add:8.32665	prefix accepted: 
_:8.24428
 Song:8.24032	prefix accepted: 
 Current:8.21761	prefix accepted: 
 In:8.10131	prefix accepted: 
 playing:8.00288
 Ps:7.97551	prefix accepted: P
 #:7.91773	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      |
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ausedOn" | "laying"
root ::= completions

Top 20 Logits:
aused:22.3527
ause:15.099
ased:14.1585	prefix accepted:a
osed:12.8987	rejected
 paused:12.6814	rejected
ushed:12.4382	rejected
aus:12.3439
lapsed:12.3069	prefix accepted:la
ained:11.9788	prefix accepted:a
ashed:11.9679	prefix accepted:a
anned:11.9235	prefix accepted:a
au:11.7382
aged:11.7078	prefix accepted:a
added:11.7059	prefix accepted:a
ared:11.5837	prefix accepted:a
aw:11.5458	prefix accepted:a
aled:11.436	prefix accepted:a
aved:11.4306	prefix accepted:a
asted:11.3904	prefix accepted:a
ended:10.9121	rejected
apsed:10.839	prefix accepted:a

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | Paused

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | Paused
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Pat (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:20.4741
O:13.0031
(:12.456	rejected
on:12.2007	rejected
S:12.0324	rejected
ON:11.6527	prefix accepted:O
In:11.1928	rejected
One:10.8988	prefix accepted:On
No:10.5983	rejected
n:10.5574	rejected
_:10.3696	rejected
Of:10.2066	prefix accepted:O
Off:10.1534	prefix accepted:O
P:10.0349	rejected
 On:9.76543	rejected
d:9.55746	rejected
By:9.32691	rejected
():9.29952	rejected
N:9.28239	rejected
Current:9.03675	rejected
o:8.97491	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | Paused
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Pat
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Constructor
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "=>"
root ::= new-tokens

Top 20 Logits:
(:20.0647
(_:14.4541	prefix accepted:(
():11.876	prefix accepted:(
 (:11.2231
((:10.5835	prefix accepted:(
 song:10.0187	prefix accepted: 
 =>:9.86707
 _:9.7056	prefix accepted: 
 ->:8.76399	prefix accepted: 
 :10.0187
_:8.28055	rejected
song:8.22337	rejected
  :8.20142
S:8.08622	rejected
   :8.02944
r:7.97368	rejected

:7.95574
(":7.89783	prefix accepted:(
_(:7.8848	rejected
 =:7.79617
 id:7.76607	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Info: Cls: Empty pattern hole
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty pattern hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Generating Completions for prefix: (
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
  LSP: Convex: Backpack: 
  LSP: Convex: Base: NoSongSelected _ ~PATVAR~ (
  LSP: Convex: Lookahead: ( NoSongSelected PausedOn Playing _ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "_" | intlit | patvar
root ::= new-tokens

Top 20 Logits:
song:20.9499
id:13.2686
i:12.7383
son:12.4528
s:12.1396
P:11.8397	rejected
play:11.6878
sing:11.3614
current:11.3576
 song:11.3405
S:11.1381	rejected
p:11.0761
sound:10.8616
is:10.0893
No:9.99132	rejected
x:9.97761
SON:9.97207	rejected
1:9.94784
sun:9.85206
0:9.84112
no:9.74104

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {song: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: song
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: song
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
Id:22.1261
id:14.133
):13.5684
I:13.5618
ID:13.4599
_:12.8856
Ids:11.833
d:11.7847
i:11.7566
s:10.7984
In:10.5541
l:10.3836
If:10.3274
Is:10.223
t:10.1099
y:10.0053
D:9.86054
ld:9.79631
It:9.70409
P:9.62199
 ):9.11747

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable binding
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable binding
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Constructor application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: songId
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
  LSP: Convex: Backpack: 
  LSP: Convex: Base: _ ~PATVAR~ ~INTLIT~ (
  LSP: Convex: Lookahead: ( _ ~INTLIT~ ~PATVAR~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= extend-patvar
new-tokens ::= whitespace | "(" | ")"
root ::= completions | new-tokens

Top 20 Logits:
):20.8379
)=:13.0003	prefix accepted:)
 ):12.186
 =>:11.591	prefix accepted: 
)->:11.2712	prefix accepted:)
 as:10.5217	prefix accepted: 
1:10.1494
)):9.69906	prefix accepted:)
_:9.56235
_):9.55403	prefix accepted:_
),:9.37684	prefix accepted:)
n:9.12647
)_:9.07259	prefix accepted:)
2:8.95134
r:8.93348
,:8.85913	rejected
t:8.7643
 =:8.7273	prefix accepted: 
 :11.591
)(:8.69979	prefix accepted:)
x:8.66106

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor application
  LSP: Info: Sort: Pat
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: => end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Constructor application
  LSP: Info: BidiCtx: Expected type: PlayListState
  LSP: Info: Bidi Parent Cls: Case expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Backpack: =>
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "=>"
root ::= new-tokens

Top 20 Logits:
 =>:21.2906
 :14.0807
 ->:13.6213	prefix accepted: 
 if:12.0375	prefix accepted: 
 =:11.1669
  :10.4846

:10.383
 >:10.0935	prefix accepted: 
 :=:9.91671	prefix accepted: 
 ==>:9.8393	prefix accepted: =
 then:9.81485	prefix accepted: 
 else:9.50901	prefix accepted: 
=>:9.42285
   :9.40955
 &&:9.16124	prefix accepted: 
 !=:9.02962	prefix accepted: 
 pl:8.91869	prefix accepted: 
 as:8.8829	prefix accepted: 
P:8.78704	rejected
 ==:8.74161	prefix accepted: =
 P:8.71393	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) =>

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) =>
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >| =><
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-convex
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
 (:19.1529
 pl:15.5411
 :14.9237
 if:13.5146
(:11.8958

:11.715
 ((:11.4479	prefix accepted: (
  :10.9232
 p:10.8449
 play:10.6729	prefix accepted: pl
 case:10.2861
 let:10.1203
pl:9.8188
 songs:9.78214
   :9.36387
 [:9.29229
    :8.68301
 {:8.62758	prefix accepted: 
 current:8.5546	prefix accepted: c
 ():8.45758	prefix accepted: (
 update:8.43156

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) =>
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: <( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: |
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.cons" | "List.filter" | "List.fold_left" | "List.fold_right" | "List.init" | "List.length" | "List.rev" | "List.tl" | "[" | "[]" | "abs" | "case " | "get_songs" | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "pl" | "songId" | "songs" | "string_compare" | "string_length" | "type " | "update" | intlit
root ::= new-tokens

Top 20 Logits:
song:21.0235
 songs:13.1575
List:12.3873
play:12.1089	prefix accepted:pl
pl:12.1089
sing:11.6985	prefix accepted:s
current:11.017	prefix accepted:c
remove:10.8318	rejected
s:11.6985
if:10.1626
list:10.1166	prefix accepted:l
id:10.1041
son:10.1009
P:10.0279	rejected
Remove:9.40175	rejected
get:9.35267
ids:9.19464	prefix accepted:id
filter:9.15292	rejected

:9.12432
 song:9.1165
p:9.10985

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id" | "s"
root ::= completions

Top 20 Logits:
s:20.7786
,:13.5709	rejected
Id:9.93936
es:9.79285	rejected
 :9.10799	rejected
 ,:8.93348	rejected
 @:8.93214	rejected
):8.88026	rejected
ss:8.58404	prefix accepted:s
ns:8.50836	rejected
(:8.39615	rejected
_:8.27254	rejected
 Id:8.1242	rejected
 s:8.1167	rejected
is:8.04756	rejected
a:7.99605	rejected
sn:7.98168	prefix accepted:s
d:7.85368	rejected
os:7.70418	rejected
us:7.63079	rejected
[:7.61807	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songs>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: [Id]
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayList"); syn = (List (Var "Id"))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  songs
Nature of error: Expecting type PlayList but got inconsistent type [Id]
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: songs
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: [Id]
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: @
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songs
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (List (Var "Id"))
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: ,
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "," | "@"
root ::= new-tokens

Top 20 Logits:
,:20.0632
 ,:13.0478
,[:12.4836	prefix accepted:,
 @:10.2979
,,:10.2415	prefix accepted:,
.:10.0938	rejected
 :9.85435
[:9.81662	rejected
 Id:9.61969	prefix accepted: 
,(:9.27423	prefix accepted:,
@:9.1469
):8.85689
_:8.65636	rejected
.,:8.62275	rejected
 [:8.49634	prefix accepted: 
Id:8.27073	rejected
 [],:8.23123	prefix accepted: 
,-:8.08098	prefix accepted:,
,.:7.95024	prefix accepted:,
_,:7.91585	rejected
),:7.89442	prefix accepted:)

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs,

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs,
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >,<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Tuple literal
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: ([Id], PlayListState)
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-convex or complete: ,
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Generating Completions for prefix: ,
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayList
[Int] <= PlayList
[Int] <= PlayList
Int <= [Int] <= PlayList
Int <= [Int] <= PlayList
  LSP: Convex: Target types: Int, PlayList, [Int]
  LSP: Convex: Backpack: 
  LSP: Convex: Base: pl ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.cons List.filter List.fold_left List.fold_right List.init List.length List.rev List.tl [ [] abs case  get_songs id if  int_of_float int_of_string let  max_int min_int mod pl songId songs string_compare string_length type  update ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "List.fold_left" | "List.fold_right" | "NoSongSelected" | "PausedOn" | "Playing" | "case " | "current" | "get_state" | "if " | "let " | "type "
root ::= new-tokens

Top 20 Logits:
 P:18.9723
 Play:15.1807
 No:14.2632
 current:13.5567
P:12.5305
 :11.802
 song:11.451	prefix accepted: 
 paused:11.3407	prefix accepted: 
 Current:11.0557	prefix accepted: 
 Song:10.0408	prefix accepted: 
 Remove:9.98055	prefix accepted: 
 playing:9.87119	prefix accepted: 
 play:9.71544	prefix accepted: 
current:9.47202
 songs:8.98542	prefix accepted: 
 p:8.70837	prefix accepted: 
 (:8.7031
Play:8.68252
 id:8.68147	prefix accepted: i
 N:8.59246
 Pa:8.54913

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, P

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, P
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs,
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <P>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "P"))))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  P
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: P
LSP: Generating Completions for prefix: P
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "ausedOn" | "laying"
root ::= completions

Top 20 Logits:
aused:23.9292
ause:15.0349
ased:13.3719	prefix accepted:a
anned:13.1144	prefix accepted:a
ushed:12.9576	rejected
 paused:12.8669	rejected
au:12.1888
ained:12.1725	prefix accepted:a
aved:11.7038	prefix accepted:a
aus:11.5145
osed:11.3812	rejected
ared:10.9354	prefix accepted:a
lapsed:10.8427	prefix accepted:la
added:10.7662	prefix accepted:a
ended:10.2818	rejected
anced:10.1714	prefix accepted:a
leased:10.0585	prefix accepted:l
ending:10.0584	rejected
apsed:9.85125	prefix accepted:a
P:9.79859	rejected
ashed:9.67235	prefix accepted:a

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, Paused

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, Paused
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, P
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <Paused>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (Common (NoType (FreeConstructor "Paused"))))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  Paused
Nature of error: Constructor is not defined
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: Paused
LSP: Generating Completions for prefix: Paused
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "On"
root ::= completions

Top 20 Logits:
On:22.0201
O:14.6877
(:13.1376	rejected
ON:12.7849	prefix accepted:O
S:12.0709	rejected
on:11.7585	rejected
In:11.5991	rejected
One:11.56	prefix accepted:On
Off:11.4929	prefix accepted:O
n:11.3909	rejected
Of:11.108	prefix accepted:O
 On:10.6683	rejected
Out:10.6376	prefix accepted:O
Om:10.4936	prefix accepted:O
_:10.4565	rejected
Over:10.3392	prefix accepted:O
d:10.3145	rejected
N:10.0875	rejected
From:10.0286	rejected
Or:9.85356	prefix accepted:O
P:9.84892	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, Paused
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <PausedOn>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Constructor
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: (Id -> PlayListState)
  LSP: Info: Error Status: (Exp
   (Common
      (Inconsistent
         Expectation {ana = (Var "PlayListState");
           syn = (Arrow ((Var "Id"), (Var "PlayListState")))})))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  PausedOn
Nature of error: Expecting type PlayListState but got inconsistent type (Id -> PlayListState)
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave or complete: PausedOn
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: (Id -> PlayListState)
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: (
LSP: Generating Completions for prefix: PausedOn
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Unknown Internal)])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | ")"
root ::= new-tokens

Top 20 Logits:
(:20.4641
((:11.0767	prefix accepted:(
No:10.7141	rejected
 (:10.3927
():9.65056	prefix accepted:(
):9.33539
()):9.09708	prefix accepted:(
(":8.88348	prefix accepted:(
 play:8.85501	prefix accepted: 
[:8.75008	rejected
 :8.85501
 state:8.69633	prefix accepted: 
Play:8.65148	rejected
P:8.65147	rejected
(_:8.61341	prefix accepted:(
(-:8.58074	prefix accepted:(

:8.51868
([:8.39487	prefix accepted:(
 current:8.19276	prefix accepted: 
 song:8.09857	prefix accepted: 
 ):8.00674

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Incomplete Tile: >( )<
  LSP: Syntax: Rightwards piece is Convex Grout
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Info: Cls: Empty expression hole
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Empty expression hole
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-convex or complete: (
LSP: Generating new left convex tokens
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Generating Completions for prefix: (
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: * ** + - / :: @
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - / :: @
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 PlayListState
  LSP: Convex: Target types: PlayListState
  LSP: Convex: Backpack: 
  LSP: Convex: Base: current current current NoSongSelected ( case  if  let  type 
  LSP: Convex: Lookahead: ( List.fold_left List.fold_right NoSongSelected PausedOn Playing case  current get_state if  let  type 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "(" | "-" | "List.fold_left" | "List.fold_right" | "List.length" | "abs" | "case " | "id" | "if " | "int_of_float" | "int_of_string" | "let " | "max_int" | "min_int" | "mod" | "songId" | "string_compare" | "string_length" | "type " | intlit
root ::= new-tokens

Top 20 Logits:
song:21.0155
id:16.1668
i:13.9316
P:13.7386	rejected
current:12.4486	prefix accepted:c
No:12.319	rejected
son:11.9941
 song:11.793
sing:11.7845	prefix accepted:s
p:11.6028	rejected
s:11.7845
0:11.0475
1:10.8966
Id:10.8539	rejected
ids:10.7083	prefix accepted:id
is:10.5703	prefix accepted:i
play:10.5465	rejected
S:10.4758	rejected
sound:10.3805	prefix accepted:so
sun:10.3683	prefix accepted:s
no:10.2379	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(song

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(song
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <song>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: ?
  LSP: Info: Error Status: (Exp (FreeVariable "song"))
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id  
Error in term:
  song
Nature of error: Variable song is not bound
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Free token; only completion
  LSP: Syntax: Must complete: song
LSP: Generating Completions for prefix: song
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: (
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

completions ::= "Id"
root ::= completions

Top 20 Logits:
Id:22.9729
I:14.2009
Is:13.3805	prefix accepted:I
id:13.3551	rejected
ID:13.0383	prefix accepted:I
Ids:12.4438	prefix accepted:Id
If:12.1009	prefix accepted:I
In:12.0368	prefix accepted:I
):11.95	rejected
Ind:11.7913	prefix accepted:I
_:11.3947	rejected
 Id:10.9324	rejected
D:10.6827	rejected
)):10.5982	rejected
J:10.4004	rejected
i:10.3993	rejected
.:10.2415	rejected
It:10.2349	prefix accepted:I
d:10.1516	rejected
Check:10.0218	rejected
(:9.88795	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(song
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <songId>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Variable reference
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: Id
  LSP: Info: Seft type: Id
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Variable reference
  LSP: Info: BidiCtx: Expected type: Id
  LSP: Info: Bidi Parent Cls: Application
  LSP: Syntax: Can insert left-concave or complete: songId
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: Id
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
LSP: Generating Completions for prefix: songId
  LSP: Concave: Infix: Left child Self type: ?
  LSP: Concave: Infix: Base: + - * / **
  LSP: Concave: Infix: Lookahead types: Id
  LSP: Concave: Infix: Lookahead: * ** + - /
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: * ** + - /
  LSP: Concave: Postfix: 
  LSP: Convex: Ty paths:
 Id
  LSP: Convex: Target types: Id
  LSP: Convex: Backpack: 
  LSP: Convex: Base: songId id id min_int max_int ~INTLIT~ - ( case  if  let  type 
  LSP: Convex: Lookahead: ( - List.fold_left List.fold_right List.length abs case  id if  int_of_float int_of_string let  max_int min_int mod songId string_compare string_length type  ~INTLIT~
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")" | "*" | "**" | "+" | "-" | "/"
root ::= new-tokens

Top 20 Logits:
):19.7209
)):16.5324	prefix accepted:)
 ):12.2232
 :12.0856
))):11.7003	prefix accepted:)
)))):11.1026	prefix accepted:)
))]:11.0051	prefix accepted:)
));:10.8013	prefix accepted:)
)),:10.0646	prefix accepted:)
)]:9.91529	prefix accepted:)
),:9.69419	prefix accepted:)
)));:9.48508	prefix accepted:)
)).:9.31016	prefix accepted:)

:9.06999
 +:9.06927
);:9.03562	prefix accepted:)
))`:8.97674	prefix accepted:)
)*:8.82034	prefix accepted:)
))::8.76287	prefix accepted:)
  :8.70561
)`:8.62302	prefix accepted:)

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId)

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId)
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: >( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Application
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayListState
  LSP: Info: Seft type: PlayListState
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: ) end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Tuple literal
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Parenthesized expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayListState
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Prod [(List (Var "Id")); (Var "PlayListState")])
  LSP: Concave: Backpack: )
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: 
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | ")"
root ::= new-tokens

Top 20 Logits:
 ):19.454
 :14.1209
 );:12.7646	prefix accepted: )
 ),:11.8459	prefix accepted: )

:11.2423
  :11.1047
 end:10.5927	prefix accepted: 
 ).:10.1924	prefix accepted: )
   :9.73767
 ]:9.42399	prefix accepted: 
 *):9.34884	prefix accepted: 
    :9.30938
 ){:9.24547	prefix accepted: )
 ,:8.44553	prefix accepted: 
 if:8.23975	prefix accepted: 
      :8.22499
 @:8.19428	prefix accepted: 
 ;:8.00443	prefix accepted: 
     :7.63785
                :7.58646
 +:7.5062	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId)
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:17.0086
 :14.9878
      :14.122
 end:13.9703
  :13.836
 in:13.0007	prefix accepted: 
    :12.755
   :12.7137
        :11.7492
       :11.159
     :11.1095
end:11.0404
          :10.7439
            :10.6949
                :10.5134
         :10.0925
           :9.7646
	:9.5973	rejected
              :9.49798
in:9.20973	rejected
 #:8.64954	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
      :19.1397
 :16.6631
  :16.1098
   :15.1132

:15.0251
    :14.8883
end:14.8876
     :14.5939
       :14.0798
        :14.0733
in:14.0477	rejected
            :13.8484
                :12.8129
 in:12.5448	prefix accepted: 
          :12.4572
           :12.4272
         :12.1813
 end:11.5016
              :11.2569
             :11.1757
	:10.8027	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:22.5744
 end:18.8664
 in:16.8698	prefix accepted: 
	:14.263	rejected
 |:14.1858
 #:13.6504	prefix accepted: 
 (*:11.7653	prefix accepted: 
 *:11.6699	prefix accepted: 
 ||:11.4926	prefix accepted: |
0:11.4502	rejected
 else:11.2156	prefix accepted: e
 with:11.0783	prefix accepted: 
 id:10.9071	prefix accepted: 
 case:10.8519	prefix accepted: 
 as:10.8377	prefix accepted: 
 done:10.6972	prefix accepted: 
 and:10.6648	prefix accepted: 
1:10.6469	rejected
 of:10.6135	prefix accepted: 
 -:10.5715	prefix accepted: 
 fun:10.5182	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 :20.3427
  :16.3855
end:15.6956
   :15.2398
      :14.5257
in:14.3951	rejected
    :14.1799
     :13.9959

:13.8135
 end:13.3746
 in:13.3081	prefix accepted: 
|:12.5975
       :12.3862
        :11.9617
done:11.8684	rejected
let:11.6549	rejected
#:11.6217	rejected
 |:11.1232
                :10.8349
            :10.7526
          :10.7126

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <( )>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Parenthesized expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {songId: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 |:18.7929
 end:17.1504
 #:15.5601	prefix accepted: 
 in:14.435	prefix accepted: 
 (*:13.9115	prefix accepted: 
 //:11.9373	prefix accepted: 
 let:11.5558	prefix accepted: 
 /*:11.4346	prefix accepted: 
 case:11.4124	prefix accepted: 
 *:11.3078	prefix accepted: 

:11.1083
 play:10.6642	prefix accepted: 
 _:10.6211	prefix accepted: 
 Play:10.5314	prefix accepted: 
 --:10.5271	prefix accepted: 
 fun:10.4018	prefix accepted: 
 id:10.2036	prefix accepted: 
 End:10.1583	prefix accepted: 
 if:10.0925	prefix accepted: 
 ~:9.97534	prefix accepted: 
 @:9.86581	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:18.3201
 in:17.685	prefix accepted: 
 :17.685
  :16.1814
    :14.5521
   :14.4303
;:13.3859	rejected
        :13.0525
 end:12.6735
      :12.4084
 #:12.3807	prefix accepted: 
       :12.3067
                :12.0404
 handle:11.9975	prefix accepted: 
     :11.8732
	:11.7321	rejected
         :11.4472
#:11.4348	rejected
          :11.4049
 where:11.2706	prefix accepted: 
 (*:11.0697	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
in:17.5312	rejected
  :14.6988

:14.2769
 in:14.2052	prefix accepted: 
end:14.0323
    :13.2351
 :14.2052
   :12.574
      :12.1887
#:11.3733	rejected
        :11.0732
     :10.7319
       :10.6572
                :10.5095
          :9.92294
```:9.87551	rejected
let:9.82248	rejected
            :9.8084
fun:9.26094	rejected
              :9.19043
}:9.1885	rejected
Rejected the highest logit candidate in with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 in:19.0497	prefix accepted: 

:16.794
 #:16.6323	prefix accepted: 
 end:15.5584
 |:15.0961
 (*:14.7253	prefix accepted: 
 fun:13.6659	prefix accepted: 
 where:13.6509	prefix accepted: 
 case:13.5963	prefix accepted: 
 handle:13.1435	prefix accepted: 
 let:12.9465	prefix accepted: 
 pl:12.7768	prefix accepted: 
 ;:12.2688	prefix accepted: 
 ;;:12.0964	prefix accepted: 
 ~:12.0563	prefix accepted: 
 //:12.011	prefix accepted: 
 ```:11.9573	prefix accepted: 
 ":11.8438	prefix accepted: 
 /*:11.6587	prefix accepted: 
 }:11.5339	prefix accepted: 
 """:11.5153	prefix accepted: 
Rejected the highest logit candidate  in with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
  

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
  
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
 in:19.0103	prefix accepted: 

:17.2774
 #:16.5979	prefix accepted: 
 end:15.7024
 |:15.171
 (*:14.8176	prefix accepted: 
 case:14.347	prefix accepted: 
 fun:13.68	prefix accepted: 
 where:13.5524	prefix accepted: 
 handle:13.4364	prefix accepted: 
 let:13.1653	prefix accepted: 
 pl:13.079	prefix accepted: 
 ~:12.3908	prefix accepted: 
 //:12.2229	prefix accepted: 
 ;:12.0902	prefix accepted: 
 ;;:11.8924	prefix accepted: 
 ```:11.8753	prefix accepted: 
 ":11.8468	prefix accepted: 
 *:11.8398	prefix accepted: 
 /*:11.7605	prefix accepted: 
 -:11.5346	prefix accepted: 
Rejected the highest logit candidate  in with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
  
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:20.1488
 in:17.8241	prefix accepted: 
 #:15.6212	prefix accepted: 
 |:14.3336
 end:13.7521
	:13.6438	rejected
 (*:13.4845	prefix accepted: 
 let:12.9021	prefix accepted: 
 case:12.4857	prefix accepted: 
 where:12.2569	prefix accepted: 
 ;:12.1456	prefix accepted: 
 *:12.0085	prefix accepted: 
 (:11.9362	prefix accepted: 
0:11.905	rejected
 fun:11.8573	prefix accepted: 
 //:11.8438	prefix accepted: 
 ":11.8108	prefix accepted: 
1:11.7611	rejected
 pl:11.4329	prefix accepted: 
 /*:11.4205	prefix accepted: 
 --:11.1702	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
in:16.2598	rejected
  :14.3416
#:14.2413	rejected
 in:14.1986	prefix accepted: 
 :14.1986

:13.5044
let:13.1572	rejected
end:12.9112
    :12.7593
   :12.3383
|:12.3297
      :11.771
 #:11.6188	prefix accepted: 
        :11.1481
(*:11.0245	rejected
                :10.7088
       :10.6148
     :10.5444
type:10.2088	rejected
fun:10.1461	rejected
~:10.1346	rejected
Rejected the highest logit candidate in with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.9724
 in:17.491	prefix accepted: 
 #:15.9655	prefix accepted: 
 (*:14.0911	prefix accepted: 
 |:13.9224
 let:13.4304	prefix accepted: 
	:13.3666	rejected
 end:13.3619
 *:13.0819	prefix accepted: 
 fun:12.4243	prefix accepted: 
0:12.2826	rejected
1:12.2791	rejected
 type:11.9286	prefix accepted: 
 (:11.7828	prefix accepted: 
 -:11.6175	prefix accepted: 
 /*:11.4751	prefix accepted: 
 case:11.397	prefix accepted: 
 ```:11.17	prefix accepted: 
2:11.0549	rejected
 <:11.0377	prefix accepted: 
 //:11.0251	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
in:15.9929	rejected
#:14.4464	rejected
 :14.3624
  :14.351
let:13.8313	rejected

:13.7929
    :13.72
 in:13.6212	prefix accepted: 
   :13.0185
end:12.4987
      :12.1532
(*:11.9208	rejected
        :11.6553
type:11.464	rejected
 #:11.4573	prefix accepted: 
|:11.2751
                :11.2567
     :10.9919
       :10.7402
          :10.5641
            :10.53
Rejected the highest logit candidate in with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:15.4872
 in:14.5314	prefix accepted: 
 :14.5314
;:12.2696	rejected
 #:12.1202	prefix accepted: 
  :12.0916
    :11.7772
   :11.7061
.:10.9851	rejected
;;:10.6583	rejected
 end:10.6233
#:9.97096	rejected
                :9.92338
in:9.81065	rejected
 let:9.7732	prefix accepted: 
	:9.70649	rejected
     :9.57871
      :9.53816
 ::9.46933	prefix accepted: 
):9.43896	rejected
 (*:9.42468	prefix accepted: 

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 

LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 
LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:19.1638
 #:15.2146	prefix accepted: 
 in:14.7958	prefix accepted: 
 (*:12.9921	prefix accepted: 
 =:12.745	prefix accepted: 
1:12.6062	rejected
0:12.3728	rejected
 *):11.9453	prefix accepted: 
	:11.8784	rejected
2:11.6829	rejected
 //:11.3928	prefix accepted: 
 *:11.3743	prefix accepted: 
 end:11.3467
 ::11.3014	prefix accepted: 
 ;:11.1924	prefix accepted: 
 ":11.0883	prefix accepted: 
3:10.9178	rejected
 ->:10.9154	prefix accepted: 
 -->:10.8597	prefix accepted: 
 <:10.8422	prefix accepted: 
 |:10.8021

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 


LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 

LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 
LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:15.6051
in:14.7008	rejected
#:14.0971	rejected
  :13.8704
    :13.5799
 :13.1748
let:12.7458	rejected
   :12.6949
```:12.2775	rejected
end:11.9594
                :11.8386
(*:11.7155	rejected
|:11.5946
      :11.5935
        :11.4587
"":11.261	rejected
":11.1503	rejected
       :11.0279
     :11.0106
          :10.7882
type:10.7644	rejected

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 



LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 


LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 

LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
#:14.3343	rejected
let:13.4815	rejected

:13.2719
type:11.9489	rejected
in:11.672	rejected
(*:11.4143	rejected
    :10.7938
  :10.7464
```:10.5712	rejected
 :10.5306
   :9.98109
end:9.77152
module:9.43412	rejected
                :9.42509
        :9.15594
----------------:9.13885	rejected
##:9.12436	rejected
 #:9.02384	prefix accepted: 
fun:9.01797	rejected
"":8.99424	rejected
~:8.98827	rejected
Rejected the highest logit candidate # with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 




LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 



LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 


LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:
#:14.247	rejected

:14.0252
let:13.6485	rejected
type:12.5396	rejected
(*:11.8047	rejected
    :11.653
  :11.2256
 :10.8355
in:10.787	rejected
   :10.6578
module:10.2065	rejected
                :10.1949
        :10.1143
```:10.0658	rejected
end:9.92799
##:9.86602	rejected
----------------:9.74771	rejected
/*:9.65111	rejected
      :9.45552
fun:9.43111	rejected
################:9.4152	rejected
Rejected the highest logit candidate # with logit -inf

================
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 





LSP: Command: Completions(Types)
LSP: New token mode: # Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 




LSP: Process zipper: Recieved string:
# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
fun pl, action ->
  case action 
  | AddSong(id) =>
      let songs, current_state = pl in
      if List.contains(is_infinite, id) then 
        (songs, NoSongSelected)  
      else (songs @ [id] , current_state)
      
  | PauseCurrentSong => 
      let songs, current = pl in
      case current 
      | Playing(songId) => (songs, PausedOn(songId) )
      | NoSongSelected => pl
      | PausedOn(songId) => pl
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  | Playing(id) => 
      let songs, current = pl in
      case current 
      | Playing(songId) => if songId == id then (songs, current) else (songs, PausedOn(songId) )
      | NoSongSelected => (songs, PausedOn(id) )
      | PausedOn(songId) => (songs, PausedOn(songId) )
      
  end
   
  
end 



LSP: Process Zipper: Found serialized zipper, deserializing
  LSP: Syntax: Leftward is Secondary: trimming
  LSP: Syntax: Leftward is Complete Tile: <case end>
  LSP: Syntax: No rightwards piece
  LSP: Info: Cls: Case expression
  LSP: Info: Sort: Exp
  LSP: Info: Expected type: PlayList
  LSP: Info: Seft type: PlayList
  LSP: Info: Error Status: None
  LSP: Info: Typing Context: {current: PlayListState, songs: [Id], id: Id, current: PlayListState, songs: [Id], action: PlayListAction, pl: PlayList, update: ((PlayList, PlayListAction) -> PlayList), get_state: (PlayList -> PlayListState), get_songs: (PlayList -> [Id]), PlayList:: ([Id], PlayListState), Playing: (Id -> PlayListState), PausedOn: (Id -> PlayListState), NoSongSelected: PlayListState, PlayListState:: (Playing(Id) + PausedOn(Id) + NoSongSelected), PlaySong: (Id -> PlayListAction), PauseCurrentSong: PlayListAction, RemoveSong: (Id -> PlayListAction), AddSong: (Id -> PlayListAction), PlayListAction:: (PlaySong(Id) + PauseCurrentSong + RemoveSong(Id) + AddSong(Id)), Id:: Int, List.contains: (((? -> Bool), [?]) -> Bool), List.filter: (((? -> Bool), [?]) -> [?]), List.fold_right: ((((?, ?) -> ?), [?], ?) -> ?), List.fold_left: ((((?, ?) -> ?), ?, [?]) -> ?), List.init: ((Int, (Int -> ?)) -> [?]), List.eq: ((((?, ?) -> Bool), [?], [?]) -> Bool), List.rev: ([?] -> [?]), List.is_empty: ([?] -> Bool), List.tl: ([?] -> [?]), List.length: ([?] -> Int), List.cons: ((?, [?]) -> [?]), parse_term: (String -> (Term, String)), term_to_string: (Term -> String), Var: (String -> Term), Abs: ((String, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), App: ((rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}) -> Term), Term:: rec α.{(Var(String) + Abs((String, α)) + App((α, α)))}, String.transform: ((String, [StringTransform]) -> String), Reverse: StringTransform, Trim: StringTransform, StringTransform:: (Reverse + Trim), String.reverse: (String -> String), String.starts_with: ((String, String) -> Bool), string_sub: ((String, Int, Int) -> String), string_concat: ((String, [String]) -> String), string_trim: (String -> String), string_compare: ((String, String) -> Int), string_length: (String -> Int), mod: ((Int, Int) -> Int), atan: (Float -> Float), acos: (Float -> Float), asin: (Float -> Float), tan: (Float -> Float), cos: (Float -> Float), sin: (Float -> Float), sqrt: (Float -> Float), log10: (Float -> Float), log: (Float -> Float), exp: (Float -> Float), floor: (Float -> Float), ceil: (Float -> Float), abs_float: (Float -> Float), abs: (Int -> Int), bool_of_string: (String -> Bool), float_of_string: (String -> Float), int_of_string: (String -> Int), string_of_bool: (Bool -> String), string_of_float: (Float -> String), string_of_int: (Int -> String), float_of_int: (Int -> Float), int_of_float: (Float -> Int), is_nan: (Float -> Bool), is_infinite: (Float -> Bool), is_finite: (Float -> Bool), min_int: Int, max_int: Int, pi: Float, epsilon_float: Float, nan: Float, neg_infinity: Float, infinity: Float}
  LSP: Info: Backpack stack: end end in
  LSP: Info: ALL errors:
Error in term:
  id
Nature of error: Expecting type [?] but got inconsistent type Id
  LSP: Info: BidiCtx: Cls: Case expression
  LSP: Info: BidiCtx: Expected type: PlayList
  LSP: Info: Bidi Parent Cls: Let expression
  LSP: Syntax: Can insert left-concave
LSP: Generating new left concave tokens
  LSP: Concave: Infix: Left child Self type: PlayList
  LSP: Concave: Infix: Base: 
  LSP: Concave: Infix: Lookahead types: Int, PlayList, [Int]
  LSP: Concave: Infix: Lookahead: 
LSP: commas: p_ana is prod: (List Int) (Sum
   [("Playing", (Some Int)); ("PausedOn", (Some Int));
     ("NoSongSelected", None)])
LSP: commas: self syn is (Var "PlayList")
  LSP: Concave: Backpack: end
  LSP: Concave: N-ary: 
  LSP: Concave: Infix: 
  LSP: Concave: Postfix: |
LSP: Grammar:
whitespace ::= [ \n]+
intlit ::= [0-9]+
extend-intlit ::= [0-9]+
floatlit ::= [0-9]+ "." [0-9]+
extend-floatlit ::= [0-9]* "." [0-9]+
stringlit ::= "\"" [^"]* "\""
extend-stringlit ::= [^"]* "\""
patvar ::= [a-z][a-zA-Z0-9_]*
extend-patvar ::= [a-zA-Z0-9_]*
typvar ::= [A-Z][a-zA-Z0-9_]*
extend-typvar ::= [a-zA-Z0-9_]*
constructor ::= [A-Z][a-zA-Z0-9_]*
extend-constructor ::= [a-zA-Z0-9_]*

new-tokens ::= whitespace | "end" | "|"
root ::= new-tokens

Top 20 Logits:

:15.186
#:14.749	rejected
let:14.09	rejected
type:13.1069	rejected
    :12.5181
(*:12.5155	rejected
  :12.0674
 :11.577
   :11.565
        :11.065
                :11.0534
in:10.935	rejected
module:10.7649	rejected
```:10.7612	rejected
##:10.5301	rejected
end:10.5163
/*:10.2993	rejected
      :10.2524
----------------:10.2237	rejected
       :10.1814
	:10.1503	rejected
